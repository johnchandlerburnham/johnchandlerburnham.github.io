<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>John Chandler Burnham - Notes (TRPL 06/21): Enums and Pattern Matching</title>
        <link rel="stylesheet" type="text/css" href="../../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../../../">posts</a>
                <a href="../../../about.html">about</a>
                <a href="../../../projects.html">projects</a>
                <a href="https://github.com/johnchandlerburnham">github</a>
                <a href="https://fosstodon.org/@johnburnham">fediverse</a>
            </div>
        </div>
        <div id="content">
            <h1>Notes (TRPL 06/21): Enums and Pattern Matching</h1>
          <h1 id="enums-and-pattern-matching">6 Enums and Pattern Matching</h1>
<p>Cool, so now we’ve got sum types.</p>
<h2 id="defining-an-enum">6.1 Defining an Enum</h2>
<p>see <code>enums/src/main.rs</code></p>
<p>This section is showing us the pattern that:</p>
<pre><code>(a || b) &amp;&amp; c == a &amp;&amp; c || b &amp;&amp; c</code></pre>
<p>Or in context:</p>
<pre><code>(V4 || V6) &amp;&amp; String == V4 &amp;&amp; String || V6 &amp;&amp; String</code></pre>
<p>Or with numbers:</p>
<pre><code>(1 + 1) * 1 = 1 * 1 + 1 * 1</code></pre>
<p>Still, it’s a very useful pattern!</p>
<h3 id="the-option-enum-and-its-advantages-over-null-values">The Option Enum and Its Advantages Over Null Values</h3>
<blockquote>
<p>This little piggy had roast beef, This little piggy had none,</p>
<p>-<em>Mother Goose</em></p>
</blockquote>
<p>You know what my favorite thing about the <code>Option</code> type in Rust is? It’s that <code>Some</code> and <code>None</code> are both four letters long. This is also the case in OCaml and it often makes the vertical alignment of code much prettier, than e.g. Haskell’s <code>Just</code> and <code>Nothing</code> type constructors for the <code>Maybe</code> type.</p>
<p>Here’s a nice post describing the monadic structure of the <code>Option</code> type: https://hoverbear.org/2014/08/12/option-monads-in-rust/</p>
<h2 id="the-match-control-flow-operator">6.2 The match Control Flow Operator</h2>
<p>see <code>enums/src/main2.rs</code></p>
<p>Good old pattern matching. It’s the best.</p>
<h3 id="matches-are-exhaustive">Matches are Exhaustive</h3>
<p>Compile-time totality checking is always helpful. I bet there’s a compiler flag somewhere to turn this off though.</p>
<h3 id="the-_-placeholder">The <code>_</code> Placeholder</h3>
<p>Ah <code>_</code>, my old friend. Man, for a systems language Rust really does use a lot of recognizable functional idioms.</p>
<h2 id="concise-control-flow-with-if-let">6.3 Concise Control Flow with <code>if let</code></h2>
<p>see <code>enums/src/main3.rs</code></p>
<p>Interesting that <code>0u8</code> is <code>0 : u8</code>, that’s a convenient shorthand syntax for literals.</p>
        </div>
        <div id="footer">
          <p>&copy; <script>document.write(new Date().getFullYear());</script>
             John Chandler Burnham.
            Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </p>
        </div>
    </body>
</html>
