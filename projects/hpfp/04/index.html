<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>John Chandler Burnham - Notes (HPFP 04/11): Basic Datatypes</title>
        <link rel="stylesheet" type="text/css" href="../../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../../../">jcb</a>
                <a href="../../../posts.html">posts</a>
                <a href="../../../projects.html">projects</a>
                <a href="https://github.com/johnchandlerburnham">github</a>
                <a href="https://twitter.com/John_C_Burnham">twitter</a>
            </div>
        </div>
        <div id="content">
            <h1>Notes (HPFP 04/11): Basic Datatypes</h1>
          <h1 id="basic-datatypes">4 Basic Datatypes</h1>
<h2 id="what-are-types">4.2 What are types?</h2>
<p><strong>Types</strong>: Haskell has expressions. Type the number <code>1</code> into the REPL That’s an expression. Type <code>addOne = (+) 1</code>. The function <code>addOne</code> is also an expression. Try to imagine all the possible expressions we could type into GHCi. This is hard to do because the number of possible expressions is infinite. But if we try to imagine lots of different expressions, we should start to notice patterns. <code>1</code> is an expression, so is <code>2</code>, so is <code>3</code>, and so on. All positive integers are expressions. <code>-1</code> is an expression, so <code>-2</code> and <code>-3</code>. Negative integers are expressions. <code>0</code> is an expression, therefore all integers are expressions. The pair <code>(1,1)</code> is an expression, so is <code>(1,2)</code>, so is <code>(23,58982)</code>. All pairs of integers are expressions. We can keep going like this forever, finding new patterns of ways to group expressions together. Every time we find a new expression-pattern, if we can precisely describe the structure of that pattern, we have a type.</p>
<p>When we played with the <code>String</code> type in the preceding chapter, we were, in effect, saying “Let’s for the moment think about only those expressions that have the <code>String</code> pattern, which looks like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]</a></code></pre></div>
<p>Haskell mandates that expressions have types, and the compiler will not let us run code where the types do not match up.</p>
<p>Try running:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> not <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">4</span><span class="fu">:</span><span class="dv">5</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    • <span class="dt">Couldn't</span> match expected <span class="kw">type</span> ‘<span class="dt">Bool</span>’ with actual <span class="kw">type</span> ‘[<span class="dt">Char</span>]’</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘not’, namely ‘<span class="st">&quot;foo&quot;</span>’</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="dt">In</span> the expression<span class="fu">:</span> not <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> not <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> not</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">not<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p><code>not</code> is a function which takes a <code>Bool</code> and returns a <code>Bool</code>. If we try to call <code>not</code> with a <code>String</code> we get a type error. Our expression was not “well-typed.”</p>
<p>We can also define new patterns, like</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Grocery</span> <span class="fu">=</span> <span class="dt">Milk</span> <span class="fu">|</span> <span class="dt">Eggs</span> <span class="fu">|</span> <span class="dt">Flour</span></a></code></pre></div>
<p>So the type system is a tool for defining new patterns in the space of possible expressions, and then checking that in the code we want to run, all the types fit together perfectly.</p>
<p>If you have ever played with Legos, you already have an intuition for how this ought to work.</p>
<p align="center">
<img src="https://upload.wikimedia.org/wikipedia/commons/3/32/Lego_Color_Bricks.jpg" width="400px" alt="Legos">
</p>
<p>There are a lot of different ways to fit Lego’ together. Two standard two by four Lego bricks of the same color can be combined 24 ways (ignoring symmetries). But there are also a lot of ways that you can’t fit pieces together. You can’t, for example, place a brick on top of two adjacent bricks at different heights. No amount of force will get the pieces to bend (Lego’s are very tough) that way. You can’t “coerce” Lego’s into doing whatever you want. The shapes are what they are, and it’s up to you the builder to figure out some interesting way to fit them together.</p>
<p>Haskell expressions are like Lego pieces. And types are like their shapes. But unlike with Lego’s, you get to design entirely new pieces, as well as put them together.</p>
<h2 id="anatomy-of-a-data-declaration">4.3 Anatomy of a data declaration</h2>
<p>In the data declaration:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span></a></code></pre></div>
<p>It’s important to keep in mind that everything to left of the <code>=</code> are types, and everything to the right are expressions.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="dt">False</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">6</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> <span class="dt">Data</span> constructor not <span class="kw">in</span> scope<span class="fu">:</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span>  <span class="co">-- Defined at &lt;interactive&gt;:4:1</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="kw">instance</span> [safe] <span class="dt">Show</span> <span class="dt">Bool</span> <span class="co">-- Defined at &lt;interactive&gt;:4:35</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="dt">Prelude</span><span class="fu">&gt;</span></a></code></pre></div>
<p><code>Bool</code> and <code>False</code> live in two different spaces. <code>Bool</code> lives in type-space and <code>False</code> lives in data-space. This is a really important distinction! Type-space disappears after code gets compiled, so you can’t interact with them in running code (or “runtime”).</p>
<p><strong>compile-time</strong>: When code gets compiled. Types are used in compile-time, but not in runtime. Compiler errors happen at compile-time.</p>
<p><strong>run-time</strong>: When code gets run. Haskell types vanish at run-time. A run-time error might be an exception like:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> head []</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</a></code></pre></div>
<p>Another thing to remember is that since type-space and data-space are distinct, the same name can live in both spaces:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">Thing</span> a <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Thing</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="dt">Thing</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Thing</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Thing</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="dt">Thing</span> <span class="dv">1</span></a></code></pre></div>
<p><code>Thing</code> the data constructor lives in data-space:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Thing</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="dt">Thing</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Thing</span> a</a></code></pre></div>
<p>And <code>Thing</code> the type constructor lives in type-space:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Thing</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">Thing</span> a  <span class="co">-- Defined at &lt;interactive&gt;:24:1</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">instance</span> [safe] <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Thing</span> a)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="co">-- Defined at &lt;interactive&gt;:24:33</span></a></code></pre></div>
<p>But this is just two names that happen to be the same. We could equivalently say:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">MakeThing</span> a <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>and everything behaves the same:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">MakeThing</span> a <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Thing</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">5</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    <span class="dt">Data</span> constructor not <span class="kw">in</span> scope<span class="fu">:</span> <span class="dt">Thing</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> t</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">MakeThing</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="dt">MakeThing</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Thing</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> <span class="dt">Data</span> constructor not <span class="kw">in</span> scope<span class="fu">:</span> <span class="dt">Thing</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MakeThing</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="dt">MakeThing</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Thing</span> a</a>
<a class="sourceLine" id="cb11-13" data-line-number="13"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Thing</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">MakeThing</span> a  <span class="co">-- Defined at &lt;interactive&gt;:4:1</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="kw">instance</span> [safe] <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Thing</span> a)</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">  <span class="co">-- Defined at &lt;interactive&gt;:4:37</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17"><span class="dt">Prelude</span><span class="fu">&gt;</span></a></code></pre></div>
<h3 id="exercises-mood-swing">Exercises: Mood Swing</h3>
<ol type="1">
<li><code>Mood</code></li>
<li><code>Blah</code> or <code>Woot</code></li>
<li>Woot is a value whose type is Mood, should be <code>changeMood :: Mood -&gt; Mood</code></li>
<li><a href="https://github.com/johnchandlerburnham/hpfp/blob/master/04/Mood.hs">see <code>Mood.hs</code></a></li>
<li><a href="https://github.com/johnchandlerburnham/hpfp/blob/master/04/Mood.hs">see <code>Mood.hs</code></a></li>
</ol>
<h2 id="numeric-types">4.4 Numeric types</h2>
<p>Numeric types will not completely make sense without typeclasses.</p>
<p><strong>Typeclass</strong>: A collection of types that share common properties. For example, the typeclass <code>Show</code> is defined as</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Show</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">  showsPrec ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="ot">  showList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ShowS</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">  <span class="ot">{-# MINIMAL showsPrec | show #-}</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  <span class="co">-- Defined in ‘GHC.Show’</span></a></code></pre></div>
<p>Which is for our purposes equivalent to:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p>So any type that is an instance of <code>Show</code> has a function called <code>show</code> that lets you turn a value of that type into a <code>String</code>.</p>
<p>Let’s try it:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Something</span> <span class="fu">=</span> <span class="dt">Something</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Something</span> <span class="kw">where</span> show <span class="dt">Something</span> <span class="fu">=</span> <span class="st">&quot;Something&quot;</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dt">Something</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="st">&quot;Something&quot;</span></a></code></pre></div>
<p>Of course, this is tedious, so Haskell gives us a <code>deriving</code> mechanism that does effectively this:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Something</span> <span class="fu">=</span> <span class="dt">Something</span> <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dt">Something</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="st">&quot;Something&quot;</span></a></code></pre></div>
<p>The reason this is relevant is that <code>Num</code>, <code>Fractional</code> and <code>Integral</code> are all typeclasses, not types:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Num</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">  (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="ot">  abs ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="ot">  signum ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="ot">  fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">  <span class="ot">{-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    <span class="co">-- Defined in ‘GHC.Num’</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"></a>
<a class="sourceLine" id="cb16-13" data-line-number="13"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Fractional</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14"><span class="kw">class</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-15" data-line-number="15"><span class="ot">  (/) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-16" data-line-number="16"><span class="ot">  recip ::</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="ot">  fromRational ::</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-18" data-line-number="18">  <span class="ot">{-# MINIMAL fromRational, (recip | (/)) #-}</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19">    <span class="co">-- Defined in ‘GHC.Real’</span></a>
<a class="sourceLine" id="cb16-20" data-line-number="20"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Integral</span></a>
<a class="sourceLine" id="cb16-21" data-line-number="21"><span class="kw">class</span> (<span class="dt">Real</span> a, <span class="dt">Enum</span> a) <span class="ot">=&gt;</span> <span class="dt">Integral</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-22" data-line-number="22"><span class="ot">  quot ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-23" data-line-number="23"><span class="ot">  rem ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-24" data-line-number="24"><span class="ot">  div ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-25" data-line-number="25"><span class="ot">  mod ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb16-26" data-line-number="26"><span class="ot">  quotRem ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)</a>
<a class="sourceLine" id="cb16-27" data-line-number="27"><span class="ot">  divMod ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)</a>
<a class="sourceLine" id="cb16-28" data-line-number="28"><span class="ot">  toInteger ::</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb16-29" data-line-number="29">  <span class="ot">{-# MINIMAL quotRem, toInteger #-}</span></a>
<a class="sourceLine" id="cb16-30" data-line-number="30">    <span class="co">-- Defined in ‘GHC.Real’</span></a></code></pre></div>
<p>But this is getting pretty deep into the “typeclass zoo.” Better leave this for chapters 5 and 6.</p>
<h2 id="comparing-values">4.5 Comparing Values</h2>
<p>Let’s think about what a comparison is. Things are different from one another, sometimes in a lot of different ways. An apple can be red, crisp and sweet while an orange can be orange, fleshy and tart. It’s tough to compare two things when they differ in a lot of different ways, hence the expression “you can’t compare apples and oranges.”</p>
<p>But actually, you can compare apples and oranges, and as long as you restrict the comparison to a single dimension of difference, it’s pretty easy. A particular apple a particular orange both have size, so you can say one is bigger than the other. And that’s a comparison! Color, taste, texture, ripeness, country of origin, there are loads of dimensions in which a comparison could make sense.</p>
<p>Let’s be even more constrained for a moment and think about what equality is. What does it mean for something to be the same as something else? Again, it’s easier to think about this if we only consider one dimension of difference at a time. Our apple and orange both have weight, and those weights can be the same, or different.</p>
<p>Let’s model this by making a type <code>Fruit</code> which can be either an <code>Apple</code> or and <code>Orange</code>, each of which contains an <code>Int</code> that represents their weight:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Fruit</span> <span class="fu">=</span> <span class="dt">Apple</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Orange</span> <span class="dt">Int</span></a></code></pre></div>
<p>Lets make a particular apple that weighs 4 units, and an orange that weighs 5 units&quot;</p>
<pre><code>&gt; apple  = Apple 4
&gt; orange = Orange 5</code></pre>
<p>In general, the question of what it means for two things to be equal is a really subtle and interesting one. Here, our common sense and knowledge of arithmetic says <code>5</code> is bigger than <code>4</code>, so the <code>orange</code> is not the same weight but is actually bigger than the <code>apple</code>.</p>
<p>Let’s ask GHCi if the <code>apple</code> is equal to the <code>orange</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> apple <span class="fu">==</span> orange</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">11</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    • <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Eq</span> <span class="dt">Fruit</span>) arising from a use <span class="kw">of</span> ‘<span class="fu">==</span>’</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    • <span class="dt">In</span> the expression<span class="fu">:</span> apple <span class="fu">==</span> orange</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> apple <span class="fu">==</span> orange</a></code></pre></div>
<p>This is saying, in so many words: “Is <code>apple</code> equal to <code>orange</code>? That depends on what the meaning of the word <del>is</del> equals is.” Equals is defined through the <code>Eq</code> typeclass:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">  (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a></code></pre></div>
<p>For any type <code>a</code>, an equals is a function that takes two <code>a</code>s and a returns a <code>Bool</code>. If they’re equal, then <code>(==)</code> returns <code>True</code>, otherwise <code>False</code> (<code>(/=)</code> is the negation “not equals”).</p>
<p>Let’s see what happens if we tell GHCi to derive an <code>Eq</code> instance for <code>Fruit</code>, basically to do a default thing that makes sense:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Fruit</span> <span class="fu">=</span> <span class="dt">Apple</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Orange</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="fu">&gt;</span> apple <span class="fu">=</span> <span class="dt">Apple</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="fu">&gt;</span> orange <span class="fu">=</span> <span class="dt">Orange</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="fu">&gt;</span> apple <span class="fu">==</span> orange</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="dt">False</span></a></code></pre></div>
<p>Okay, that seems to be what we expected, but let’s see what happens if we make both fruits the same size:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="fu">&gt;</span> apple <span class="fu">=</span> <span class="dt">Apple</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="fu">&gt;</span> orange <span class="fu">=</span> <span class="dt">Orange</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="fu">&gt;</span> apple <span class="fu">==</span> orange</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="dt">False</span></a></code></pre></div>
<p>When we told GHCi to just figure out an equality function, it didn’t have any way of knowing that the <code>Int</code> inside the <code>Apple</code> and <code>Orange</code> data constructors was the only thing we cared about, so it derived an <code>(==)</code> function that also takes the data constructors themselves into account.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="fu">&gt;</span> apple <span class="fu">=</span> <span class="dt">Apple</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="fu">&gt;</span> orange <span class="fu">=</span> <span class="dt">Orange</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="fu">&gt;</span> apple <span class="fu">==</span> apple</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="dt">True</span></a></code></pre></div>
<p>If we only want <code>(==)</code> to consider the weight <code>Int</code> we have to write our own <code>Eq</code> instance:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Fruit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Fruit</span> <span class="fu">=</span> <span class="dt">Apple</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">Orange</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4"></a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Fruit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  (<span class="fu">==</span>) a b <span class="fu">=</span> (weight a) <span class="fu">==</span> (weight b)</a>
<a class="sourceLine" id="cb24-7" data-line-number="7"></a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">weight ::</span> <span class="dt">Fruit</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">weight (<span class="dt">Apple</span> a) <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">weight (<span class="dt">Orange</span> a) <span class="fu">=</span> a</a></code></pre></div>
<p>If we load this into GHCi, this should now do what we expect:</p>
<pre><code>&gt; (Apple 4) == (Orange 4)
True</code></pre>
<p>By the way, we could have gotten around having to write the cumbersome <code>weight</code> function if we had used Haskell’s record syntax in our <code>Fruit</code> data constructors:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Fruit</span> <span class="fu">=</span> <span class="dt">Apple</span> {<span class="ot"> weight ::</span> <span class="dt">Int</span> } <span class="fu">|</span> <span class="dt">Orange</span> {<span class="ot"> weight ::</span> <span class="dt">Int</span> }</a></code></pre></div>
<p>This automatically generates the weight functions we want.</p>
<p>The <code>Ord</code> typeclass is very much like <code>Eq</code>, but is focused on “bigness” rather than equality:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Ord</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"><span class="ot">  compare ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">  (&lt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="ot">  (&lt;=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6"><span class="ot">  (&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7"><span class="ot">  (&gt;=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8"><span class="ot">  max ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"><span class="ot">  min ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>It’s called <code>Ord</code> because it’s short for “Orderable”, as in “can be put in order.” I like expanding typeclass names by adding and “-able” to the end of them. <code>Eq</code> is the class of “Equable” types, <code>Show</code> is the class of “Showable” types, etc. etc.</p>
<h2 id="go-on-and-bool-me">4.6 Go on and Bool me</h2>
<p>Okay, one very very pattern in Haskell is the overlapping language used for logical disjunction (OR) and addition, and logical conjunction (AND) and multiplication. A type (like <code>Bool</code>) that can be either one thing (like <code>True</code>) or another (like <code>False</code>) is called a “sum” type. A type (like a tuple <code>(a, b)</code> that has to have one thing and another is called a “product” type. This language comes from a branch of math called category theory, but is actually much less scary than it seems at first. The basic idea is that when you try to count (or enumerate) all the possible values that can be in a type, an OR (in Haskell a <code>|</code>) in your constructor acts like adding number of possibilities on both sides of the disjunction, whereas an AND acts like multiplying the possibilities on both sides of the conjunction. Hence, “sum” for adding, and “product” for multiplying.</p>
<p>Haskell doesn’t have a special syntax for product types, it just puts the two parts of the next to each other separated by a space, so <code>a b</code> is the product type of <code>a</code> and <code>b</code>, while <code>a | b</code> is the sum type of <code>a</code> and <code>b</code>.</p>
<p>This concept will be explained more in later chapters.</p>
<h3 id="exercises-find-the-mistakes">Exercises: Find the Mistakes</h3>
<ol type="1">
<li><code>not True &amp;&amp; True</code></li>
<li><code>not (x == 6) where x = 5</code></li>
<li><code>(1 * 2) &gt; 5</code></li>
<li><code>[&quot;Merry&quot;] &gt; [&quot;Happy&quot;]</code></li>
<li><code>[&quot;1, 2, 3&quot;] ++ &quot;look at me!&quot;</code></li>
</ol>
<h2 id="chapter-exercises">4.9 Chapter Exercises</h2>
<ol type="1">
<li><p><code>length :: [a] -&gt; Int</code></p></li>
<li><ol type="a">
<li>5</li>
<li>3</li>
<li>2</li>
<li>5</li>
</ol></li>
<li><code>Int</code> is not a <code>Fractional</code></li>
<li>Use infix `<code>div`</code> instead</li>
<li><code>Bool</code>, returns <code>True</code></li>
<li><code>Bool</code>, returns <code>False</code></li>
<li><ol type="a">
<li>Works, <code>False</code></li>
<li>Error, no instance <code>(Num Char)</code></li>
<li>Works, returns <code>8</code></li>
<li>Works returns <code>False</code></li>
<li>No instance <code>(Num Bool)</code></li>
</ol></li>
<li><a href="https://github.com/johnchandlerburnham/hpfp/blob/master/04/Exercises.hs">see <code>Exercises.hs</code></a></li>
<li><a href="https://github.com/johnchandlerburnham/hpfp/blob/master/04/Exercises.hs">see <code>Exercises.hs</code></a></li>
<li><p><a href="https://github.com/johnchandlerburnham/hpfp/blob/master/04/Exercises.hs">see <code>Exercises.hs</code></a></p></li>
</ol>
<h3 id="correcting-syntax">Correcting syntax</h3>
<p><a href="https://github.com/johnchandlerburnham/hpfp/blob/master/04/CorrectingSyntax.hs">see <code>CorrectingSyntax.hs</code></a></p>
<h3 id="match-the-function-names-to-their-types">Match the function names to their types</h3>
<ol type="1">
<li><ol start="3" type="a">
<li></li>
</ol></li>
<li><ol start="2" type="a">
<li></li>
</ol></li>
<li><ol type="a">
<li></li>
</ol></li>
<li><ol start="4" type="a">
<li></li>
</ol></li>
</ol>
        </div>
        <div id="footer">
          <p>&copy; <script>document.write(new Date().getFullYear());</script>
             John Chandler Burnham.
            Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </p>
        </div>
    </body>
</html>
