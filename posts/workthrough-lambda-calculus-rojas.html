<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>John Chandler Burnham - Workthrough: A Tutorial Introduction to the Lambda Calculus (Rojas)</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">jcb</a>
                <a href="../posts.html">posts</a>
                <a href="../projects.html">projects</a>
                <a href="https://github.com/johnchandlerburnham">github</a>
            </div>
        </div>

        <div id="content">
            <h1>Workthrough: A Tutorial Introduction to the Lambda Calculus (Rojas)</h1>
              <div class="info">
    Posted on November 14, 2017
    
        by jcb
    
</div>
<div class="info">
    
    Tags: <a href="../tags/workthrough.html">workthrough</a>, <a href="../tags/math.html">math</a>, <a href="../tags/haskell.html">haskell</a>
    
</div>

<hr>

<hr>
<h2>Contents</h2>
<ul>
<li><a href="#definition">1 Definition</a><ul>
<li><a href="#free-and-bound-variables">1.1 Free and bound variables</a></li>
<li><a href="#substitutions">1.2 Substitutions</a></li>
</ul></li>
<li><a href="#arithmetic">2 Arithmetic</a><ul>
<li><a href="#addition">2.1 Addition</a></li>
<li><a href="#multiplication">2.2 Multiplication</a></li>
</ul></li>
<li><a href="#conditionals">3 Conditionals</a><ul>
<li><a href="#logical-operations">3.1 Logical operations</a></li>
<li><a href="#a-conditional-test">3.2 A conditional test</a></li>
<li><a href="#the-predecessor-function">3.3 The predecessor function</a></li>
<li><a href="#equality-and-inequalities">3.4 Equality and inequalities</a></li>
</ul></li>
<li><a href="#recursion">4 Recursion</a></li>
<li><a href="#projects-for-the-reader">5 Projects for the reader</a><ul>
<li><a href="#less-than-and-greater-than">1 “less than” and “greater than”</a></li>
<li><a href="#positive-and-negative-integers">2 Positive and Negative Integers</a></li>
<li><a href="#addition-and-subtraction-of-integers">3 Addition and Subtraction of Integers</a></li>
<li><a href="#division-of-positive-integers-recursively">4 Division of positive integers recursively</a></li>
<li><a href="#factorial">5 Factorial</a></li>
<li><a href="#rational-numbers">6 Rational Numbers</a></li>
<li><a href="#addition-subtraction-multiplication-and-division-of-rationals">7 Addition, Subtraction, Multiplication, and Division of Rationals</a></li>
<li><a href="#lists-of-numbers">8 Lists of Numbers</a></li>
<li><a href="#list-head">9 List Head</a></li>
<li><a href="#list-length">10 List Length</a></li>
<li><a href="#turing-machine">11 Turing Machine</a></li>
</ul></li>
</ul>
<hr>
<p><strong>Work in progress</strong></p>
<p>This is a workthrough of a short paper introducing the Lambda Calculus by Raul Rojas. A link to the paper is here: <a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf" class="uri">http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf</a></p>
<p>I found this paper as a follow-up resource listed in Chapter 1 of Haskell Programming from First Principle by Chris Allen and Julie Moronuki, my workthrough for which can be found here: <a href="../posts/workthrough-hpfp.html">Workthrough: Haskell Programming From First Principles, Allen &amp; Moronuki</a></p>
<p>Please note that I am using the <code>\</code> character to indicate λ. This is partially so that my notation is closer to Haskell, and partially so I don’t have to write <code>&amp;lambda</code> all the time in the Markdown file this page is being generated from. In my first draft of these notes I actually wrote everything in LaTex (using <a href="www.mathjax.org">MathJax</a> to display it on the page). Despite how great LaTex is (and MathJax!), this was a huge mistake as it proved to be horrifically labor-intensive. So all the pseudocode on this page is just going to be in ascii.</p>
<h1 id="definition">1 Definition</h1>
<p><strong>Lambda Calculus</strong>: The text says “the smallest universal programming language of [sic] the world [, consisting] of a single transformation rule (variable substitution) and a single function definition scheme.” I’m inferring that by “smallest” the author means “simplest,” but I would be interested to see the claim that “lambda calculus is the simplest possible programming language” developed further. What does it mean for a programming language to be “simple”?</p>
<p>[NB. I will investigate this claim later and link back here]</p>
<p>Lamda Calculus consists of <em>expressions</em>:</p>
<p><strong>expression</strong>: an expression is a <em>name</em>, a <em>function</em> or an <em>application</em>. Any expression can be optionally surrounded by parentheses for clarity.</p>
<p><strong>name</strong>: Also called a <em>variable</em>. Represents values, denoted by single lettters: `</p>
<pre><code>a, b, c ...</code></pre>
<p><strong>function</strong>: Also called an <em>abstraction</em>, Represents functions (in the mathematical sense). Notation is of the form</p>
<pre><code>\N. E</code></pre>
<p>where <code>N</code> is a name and <code>E</code> is an expression. <code>N</code> is called the <em>head</em> and <code>E</code> is called the <em>body</em> of the function.</p>
<p><strong>application</strong>: Represents the concept of apply a function to an argument. Notation is of the form</p>
<pre><code>F N</code></pre>
<p>where <code>F</code> and <code>N</code> are expressions. Application associates to the left, so</p>
<pre><code>F M N</code></pre>
<p>is equivalent to</p>
<pre><code>((F M) N)</code></pre>
<p><strong>evaluation</strong>: In an application expresion `</p>
<pre><code>F N</code></pre>
<p>where <code>F</code> is a function, if the <em>name</em> in the head of <code>F</code> occurs anywhere in the body of <code>F</code>, replace each occurence of that name with the expression <code>N</code>, and return the body.</p>
<p>Example:</p>
<pre><code>(\x. x) y</code></pre>
<p>evaluates to simply <code>y</code>, and</p>
<pre><code>(\x. x y) y</code></pre>
<p>evaluates to <code>y y</code>.</p>
<p><strong>the identity function</strong>:</p>
<pre><code>id = \x. x</code></pre>
<p>returns whatever it is applied to.</p>
<h2 id="free-and-bound-variables">1.1 Free and bound variables</h2>
<p><strong>bound variable</strong>: The name in the head of a function is called a <em>bound</em> variable, because the function binds it as a paramter.</p>
<p><strong>free variables</strong>: Any names in the body of a function are not bound by the function and therefore are <em>free</em>.</p>
<p>The formal definition of free vs. bound in this text is confusing. The definition is overly detailed and obscures the idea of a function <em>binding</em> a variable.</p>
<p>The principle is that a variable is bound if and only if it is in the body of a function that <em>binds</em> it. Any variables not so bound are free. A variable cannot be both bound and free in the scope of a single function, and we really only care about single functions, since we evaluate lambda expressions one abstraction at a time.</p>
<p>The example given of <code>y</code> being both “bound” and “free” in</p>
<pre><code>(\x. x y) (\y. y)</code></pre>
<p>is right but misleading. <code>y</code> is “free” in the scope of the first function, but bound in the second. Despite all appearences, though, these are not the same <code>y</code>.</p>
<p><code>\y. y</code> is the identity function. So is <code>\x. x</code> or <code>\n. n</code>, and any other expression of the same form which replaces the <code>y</code>’s with any other letter. These are all equivalent ways to write the same function. And therefore we can substitute any of them for any other. This property of not caring which letters of the alphabet we use as long as the form is the same is called alpha equivalence.</p>
<p>In the case of the example in the text, through alpha equivalence,</p>
<pre><code>(\x. x y) (\y. y) =&gt; (\x. x y) (\n. n)</code></pre>
<p>And presto, <code>y</code> is not bound at all in this expression, according to the definition given in the text.</p>
<p>The reason this is important is because scope matters. A statement might be true at one scope and false in another, and if we’re not careful to keep a clear idea of what scope we’re operating at, we can start badly confusing ourselves and others.</p>
<p>As an example, let’s add an abstraction over <code>y</code> to the above:</p>
<pre><code>\y. (\x. x y) (\y. y)</code></pre>
<p>Now <code>y</code> is not free in the expression at all. But we would be badly mistaken if when we applied this abstraction to an expression <code>N</code> we did this:</p>
<pre><code>(\y. (\x. x y) (\y. y)) N =&gt; (\x. x N) (\y. N)</code></pre>
<p>Again, the <code>y</code> in <code>(\y.y)</code> is not the same <code>y</code> as the one in the head of the outer abstraction. Instead, we have to do this:</p>
<pre><code>(\y. (\x. x y) (\y. y)) N =&gt; (\x. x N)(\y. y)</code></pre>
<p>Which makes sense, since</p>
<pre><code>(\x. x y)(\y. y) =&gt; (\x. x y)(\n. n)</code></pre>
<p><strong>name-shadowing</strong>: When, in nested abstractions, a variable in an inner abstraction has the same name as a variable in an outer abstraction.</p>
<h2 id="substitutions">1.2 Substitutions</h2>
<p>The description of substitution in the text is a little haphazard, and I think the formalism in the previous section would have been better served in this one.</p>
<p>Here’s what I would have included (see <a href="https://en.wikipedia.org/wiki/Lambda_calculus">Wikipedia</a>):</p>
<p><strong>alpha equivalence</strong>: Renaming the bound (formal) variables in the expression. Used to avoid name collisions. Let <code>x</code> and <code>y</code> be names and let <code>M[x]</code> be an expression <code>M</code> containing some <code>x</code> terms. Then in the following function,</p>
<pre><code>(\x.M[x]) =&gt; (\y.M[x:=y]) </code></pre>
<p>where <code>M[x:=y]</code> denotes replacing each instance of <code>x</code> in <code>M</code> with <code>y</code>.</p>
<p><strong>beta reduction</strong>: Substituting the bound variable by the argument expression in the body of the abstraction. Let <code>x</code> be a name and let <code>M</code> and <code>E</code> be expressions. Then in the following application,</p>
<pre><code>((\x.M) E) =&gt; M[x:=E]</code></pre>
<p>where <code>M[x:=E]</code> denotes replacing each instance of <code>x</code> in <code>M</code> with <code>E</code>.</p>
<p>Name shadowing can make both alpha equivalence and beta reduction more complicated, so the above definitions only really apply without exception when the variable names in all the lambda abstraction heads are different.</p>
<h1 id="arithmetic">2 Arithmetic</h1>
<p>Thus far, everything we’ve seen with lambda calculus has been a symbol manipulation game, and not obviously meaningful. So we’re going to put some meaning into it by coming up with a way to do arithmetic.</p>
<p>First, we’re going to need numbers. Specifically, we’re going to need to find a coherent way to represent the natural numbers</p>
<pre><code>0, 1, 2, 3, ...</code></pre>
<p>as lambda expressions. The way we’re going to do this is by implementing of Peano numbers in lambda calculus.</p>
<p>[N.B. I will find/write a good explanation of Peano numbers, link it here, and rework this to be clearer]</p>
<p>First, we’re going to pick an expression for <code>0</code>, which we’ll call <code>Zero</code>, and then a successor function <code>succ</code>, so that</p>
<pre><code>0 = Zero
1 = succ Zero
2 = succ (succ Zero)
...</code></pre>
<p>and so on. This is the standard Peano definition of the natural numbers.</p>
<p>But there’s a neat trick we can do in our lambda calculus implementation of Peano numbers. Notice how the Peano numbers are defined as a zero and then layers of a succesor function on top of zero. We know how to express functions in lambda calculus, so what if we rewrote the above definition of Peano numbers as functions of two parameters <code>s</code> and <code>z</code>, which will stand in for whatever expressions we pick for the successor function and the zero, respectively. We’ll call these lambda functions that return numbers <code>n_</code>, where <code>n</code> is the number they return:</p>
<p>Let’s start with <code>0_</code>. We know that all the <code>n_</code> functions are functions of <code>s</code>, (<code>succ</code>) and <code>z</code> (<code>Zero</code>), so the heads of all our <code>n_</code> will be the same: <code>\s z</code>.</p>
<p>For <code>0_</code> we throw away the successor and just return the zero:</p>
<pre><code>0_ = \s z. z </code></pre>
<p>For <code>1_</code> we apply the succesor once:</p>
<pre><code>1_ = \s z. s z </code></pre>
<p>For <code>2_</code> we apply the succesor twice:</p>
<pre><code>2_ = \s z. s (s z) </code></pre>
<p>And so on, giving us the following functions:</p>
<pre><code>0_ = \s z. z
1_ = \s z. s z
2_ = \s z. s (s z)
3_ = \s z. s (s (s z))
...</code></pre>
<p>Now here’s the trick. The above functions are already lambda expressions. So while we could find other expressions that would work as numbers, we can just use the above <code>n_</code> functions as numbers directly.</p>
<p>If we do that then we already found an expression for our zero: <code>\sz.z</code>. Which is just a function that throws away its argument and returns our old friend the identity function.</p>
<p>One way to visualize this structure is to imagine <code>n_</code> as the set of functions that apply another function to an argument <code>n</code> times. <code>Zero</code> is “apply zero times” or “don’t apply”, one is “apply once”, two is “apply twice” and so on.</p>
<p>Now we just need a <code>succ</code> function. <code>succ</code> takes a number and returns that number plus one. But if our numbers are functions that apply another function to an argument some number of times, then <code>succ</code> takes a number <code>n</code>, a function <code>f</code> and an argument <code>x</code> then applies <code>f</code> to x an <code>(n+1)</code> number of times. In other words, <code>succ</code> is like an “apply once more”function.</p>
<p>Here’s what that function looks like:</p>
<pre><code>succ = \n f x. f (n f x)</code></pre>
<p>Let’s see what happens when we apply <code>succ</code> to a number:</p>
<pre><code>succ 0_ = (\n f x. f (n f x)) (\s z. z) =&gt; 
\f x. f ((\s z.z) f x) =&gt;
\f x. f x</code></pre>
<p>Through alpha equivalence <code>\f x. f x</code> is the same as <code>\s z. s z</code> which is <code>1_</code>.</p>
<p>Applying <code>succ</code> to `1_</p>
<pre><code>succ 1_ = (\n f x. f (n f x)) (\s z. s z) =&gt; 
\fx. f ((\s z. s z) f x) =&gt;
\f x. f (f x) =&gt;
2_</code></pre>
<h2 id="addition">2.1 Addition</h2>
<p>Once we understand <code>succ</code>, <code>add</code> is pretty easy . Whereas <code>succ</code> is “apply <code>f</code> to <code>x</code>, <code>n</code>-times”, <code>add</code> is “apply <code>f</code> to <code>x</code>, <code>n</code>-times, then <code>m</code>-times, for a total of <code>(n + m)</code> applications.”</p>
<pre><code>add = \m n f x. m f (n f x)</code></pre>
<p>Let’s see this in action:</p>
<pre><code>add 1_ 2_ = (\n m f x. m f (n f x)) (\s z. s z) (\s z. s (s z)) =&gt; 
\f x. (\s z. s z) f ((\s z. s (s z)) f x) =&gt;
\f x. (\z. f z) ((\s z. s (s z)) f x) =&gt; 
\f x. f (\s z. s (s z) f x) =&gt;
\f x. f (f (f x)) =&gt; 
3_</code></pre>
<p>A useful pattern we can notice is that <code>add</code> can also be expressed as:</p>
<pre><code>add = \m n f x. m f (n f x) =&gt; \m n. \f x.  m f (n f x) =&gt;
\m n. m (\f x. n f x) =&gt; \m n. m (\n f x. n f x) n =&gt;
\m n. m succ n</code></pre>
<p>This might seem less mysterious if we do the equivalence in reverse.</p>
<pre><code>\m n. m succ n =&gt; \m n. m (\n f x. f (n f x)) n =&gt; 
\m n. m (\f x. f (n f x)) =&gt; \m n. \f x. m f (n f x) =&gt; 
\m n f x. m f (n f x)
=&gt; add</code></pre>
<h2 id="multiplication">2.2 Multiplication</h2>
<p><code>multiply</code> is even easier, we just feed one number into another:</p>
<pre><code>multiply n m = \n m t. n (m t)</code></pre>
<p>If we multiply <code>2_</code> by <code>2_</code>:</p>
<pre><code>multiply 2_ 2_ =&gt;
(\n m t. n (m t)) (\s z.s (s z)) (\s z. s (s z)) =&gt;
\t. (\s z. s (s z)) (\s z. s (s z) t) =&gt;
\t. (\s z. s (s z)) (\z. t (t z)) =&gt;
\t. \z. (\z. t (t z)) ((\z. t (t z)) z) =&gt;
\t z. (\z. t (t z)) ((\z. t (t z)) z) =&gt;
\t z. (\z. t (t z)) (t (t z)) =&gt;
\t z. t (t (t (t z))) =&gt;
\s z. s (s (s (s z))) =&gt;
 4_</code></pre>
<p>Okay, maybe that was a little tough to read. Maybs a little substitution will make things cleaner?</p>
<pre><code>multiply 2_ 2_ =&gt;
(\n m t. n (m t)) 2_ 2_ =&gt;
\t. 2_ (2_ t) =&gt;
\t. 2_ (\x. t (t x)) =&gt;
\t. \z. (\x. t (t x)) ((\x. t (t x)) z) =&gt;
\t. \z. (\x. t (t x)) (t (t z)) =&gt;
\t. \z.t (t (t (t z))) =&gt;
\t z. t (t (t (t z))) =&gt;
4_</code></pre>
<p>I don’t think that helped much. There is, clearly, a reason why we do not write programs directly in lambda calculus.</p>
<h1 id="conditionals">3 Conditionals</h1>
<pre><code>true = \x y.x
false = \x y.y</code></pre>
<p>Why these expressions? Probably because it’s convenient to have <code>false</code> be the same expression as <code>0_</code>:</p>
<pre><code>false =&gt; \x y. y =&gt; \s z. z =&gt; 0_</code></pre>
<p>This matches the common convention found in imperative programming languages. We could choose to make <code>true</code> equal zero instead, and then change all the logic functions by negating their inputs, so <code>(and a b)</code> in the usual way becomes</p>
<pre><code>(and (not a) (not b))</code></pre>
<p>But I’m not sure if there’s any tangible benefit to doing this other than being contrarian.</p>
<h2 id="logical-operations">3.1 Logical operations</h2>
<pre><code>and = \x y. x y (\x y. y) =&gt; \x y. x y false</code></pre>
<p>The first parameter of <code>and</code> returns the second parameter, if it is <code>true</code> and <code>false</code> if it is <code>false</code>. The only way <code>And</code> returns <code>true</code> is if both parameters are <code>true</code>.</p>
<p>or = y. x (y. x) y = y. x true y ``</p>
<p>Same general idea as <code>And</code>. The first parameter selects <code>true</code> if <code>true</code> and <code>y</code> if <code>false</code>.</p>
<pre><code>not = \x. x false true</code></pre>
<p>Straightforward, it’s just flipping the order of the parameter.</p>
<h2 id="a-conditional-test">3.2 A conditional test</h2>
<pre><code>isZero = \x. x false not false</code></pre>
<p>If x is <code>0_</code>:</p>
<pre><code>isZero 0_ =&gt; (\x. x false not false) 0_ =&gt;
0_ false not false =&gt; 
not false =&gt; 
true </code></pre>
<p>If x is <code>1_</code>:</p>
<pre><code>isZero 1_ =&gt; (\x. x false not false) 1_ =&gt;
1_ false not false =&gt; 
(\x y. y) not false =&gt; 
(\y. y) false =&gt; 
false </code></pre>
<p>If x is <code>2_</code>:</p>
<pre><code>isZero 2_ =&gt; (\x. x false not false) 2_ =&gt;
2_ false not false =&gt; 
(\x y. y) ((\x y. y) not) false =&gt; 
(\y. y) false =&gt; 
false </code></pre>
<p>It doesn’t matter how many times we apply <code>false</code> to <code>not</code> because <code>false</code> applied to any expression is always the Identity function.</p>
<h2 id="the-predecessor-function">3.3 The predecessor function</h2>
<p>The predecessor function <code>pred</code> is like the opposite of the successor function <code>succ</code>. Instead of adding one to a number, it subtracts one from a number (the words increment and decrement are sometimes used in other contexts to describe adding or subtracting one, respectively).</p>
<p>Since numbers are functions that take other functions (higher-order functions), and apply them a certain number of times, predecessor can be thought of as an “apply one less time than this number” function.</p>
<p>Recall that <code>succ</code> is</p>
<pre><code>succ = \n f x. f (n f x)</code></pre>
<p>Naively, we might want something that looks like this</p>
<pre><code>pred n = \n f x. (invert f) (n f x)</code></pre>
<p>where <code>(invert f)</code> is the inverse function of <code>f</code>:</p>
<pre><code>(invert f) (f x) = x</code></pre>
<p>But we have a problem: Not every function is invertible.</p>
<p>Take <code>false</code> for example:</p>
<pre><code>false x = (\x y. y) x = (\y. y) = id</code></pre>
<p>Since <code>false</code> of any argument <code>x</code> is the <code>identity</code> function, and since a function can only have one ouput for any given input, there’s no way for us to build an expression for <code>(invert false).</code> And that means that we can build an <code>invert</code> function that is <em>total</em>, in that it is defined over all possible inputs.</p>
<p>But it turns out it is possible to build a total <code>pred</code> function, but we have to try another method. Instead of starting from <code>n</code> and working backwards, we’ll start from <code>0_</code> and build forwards. If we apply <code>succ</code> <code>n</code>-times to <code>0_</code>, we get <code>n</code>. So if we apply <code>succ</code> only <code>(n-1)</code>-times to <code>0_</code>., /e’ll get <code>n - 1</code> which is <code>pred n.</code></p>
<p>We’ll start by building an expression that holds a pair of numbers, <code>a_</code> and <code>b_</code>. Suppose we just put them next to each other:</p>
<pre><code>a_ b_ </code></pre>
<p>This might look fine at first, but watch what happens if we give them concrete values:</p>
<pre><code>0_ 0_ =&gt; (\s z. z) (\s z. z) 
=&gt; \z.z</code></pre>
<p>The numbers evaluate against each other! Let’s add an abstraction to stop the application:</p>
<pre><code>\x. a_ b_ </code></pre>
<p>Okay, that stops the application, but only temporarily. If we ever apply this expression to anything, it’ll just reduce back again and throw away the values in the pair.</p>
<p>What we want is some way to access the two individual values in the pair.</p>
<pre><code>\x. x a_ b_</code></pre>
<p>We already have functions which will return only their first or second arguments: <code>true</code> and <code>false</code>. We can use these to select which element of the pair we want:</p>
<pre><code>(\x. x a_ b_) true  = a_
(\x. x a_ b_) false = b_</code></pre>
<p>Great, we’ve got a pair! Now we need a function which we’ll call <code>phi</code> to turn a pair of numbers <code>(a, b)</code> into <code>(a + 1, a)</code></p>
<pre><code>phi = \p z. z (succ (p true)) (p true)</code></pre>
<p>For example,</p>
<pre><code>(\p z. z (succ (p true)) (p true)) (\x. x 2_ 1_) =&gt;
(\z. z (succ ((\x. x 2_ 1_) T)) ((\x. x 2_ 1_) T))  =&gt;
(\z. z (succ ((\x. x 2_ 1_) T)) ((\x. x 2_ 1_) T))  =&gt;
</code></pre>
<p>Now we just need to apply <code>phi</code> to <code>\x. x 0_ 0_</code>, <code>n</code>-times, and the first element will be equal to <code>n</code> and the second will be <code>n - 1</code>:</p>
<pre><code>\n. n phi (\z. z 0_ 0_)</code></pre>
<p>But since this function is supposed to be the predecessor, we really just want the second element:</p>
<pre><code>pred n = \n. n phi (\z. z 0_ 0_) F</code></pre>
<h2 id="equality-and-inequalities">3.4 Equality and inequalities</h2>
<p>A number, <code>x</code> is greater than or equal to a number <code>y</code> if applying predecessor <code>x</code>-times to <code>y</code> is 0:</p>
<pre><code>gte x y = \x y. isZero (x pred y)</code></pre>
<p>The reason this function is “greater than or equal to” and not just “equals” is that the predecessor of <code>0</code> is <code>0</code>.</p>
<p>But we can get an equals function by simply doing:</p>
<pre><code>eq x y = \x y. and (gte x y) (gte y x)</code></pre>
<p>Then, not equal is:</p>
<pre><code>neq x y = \x y. not (eq x y)</code></pre>
<p>Greater than:</p>
<pre><code>gth x y = \x y. and (gte x y) (not x y) </code></pre>
<p>Less than or equal to:</p>
<pre><code>lte x y = \x y. not (gth x y)</code></pre>
<p>Less than:</p>
<pre><code>lth x y = \x y. not (gte x y)</code></pre>
<h1 id="recursion">4 Recursion</h1>
<p><strong>recursion</strong>: A pattern where a function calls itself.</p>
<p>The basic idea behind recursion in lambda calculus is that we want to build an expression that regenerates itself as we reduce it. What I mean by that is if a function <code>F</code> is going to apply itself inside itself, it’s reduction needs to somehow build a new copy of <code>F</code>. We’re going to want to end up with some function that transforms <code>F</code> into a sequence of repeated applications of <code>F</code>:</p>
<pre><code>F (F (F ....)))</code></pre>
<p>Imagine we want to apply an expression <code>F</code> to itself once. If <code>F</code> is the identity function <code>id</code>:</p>
<pre><code>id id =&gt; (\x.x) (\x.x) =&gt; \x.x </code></pre>
<p>Let’s say we want a function that does this self-application, that we’ll call <code>M</code>:</p>
<pre><code>M = \f. f f </code></pre>
<p>Now supppose we apply <code>M</code> to <code>M</code>:</p>
<pre><code>M(M) = (\f. f f) (\f. f f) =&gt;
(\f. f f) (\f. f f) =&gt; \dots</code></pre>
<p>This is an infinite loop! <code>M(M)</code> regenerates itself perfectly, so that any reduction just goes <code>M(M) =&gt; M(M) ...</code> . <code>M(M)</code> is in fact the classic case of a non-terminating lambda expression, and is usually called Ω).</p>
<p>Infinite loops are cool, but what we really want is to modify <code>M(M)</code> so that we add an application of a function <code>R</code> at every loop:</p>
<pre><code>M (\f. R (f f)) = (\f. f f) (\f. R (f f)) =&gt;
(\f. R (f f)) (\f. R (f f)) =&gt;
R ((\f. R (f f)) (\f. R (f f)) =&gt;
R ( R ((\f. R (f f)) (\f. R (f f)))) =&gt;
...</code></pre>
<p>This is the famous <code>Y</code> combinator:</p>
<pre><code>Y = (\f. f f) (\f. R (f f)) =&gt;(\f. R (f f)) (\f. R (f f))</code></pre>
<p><strong>combinator</strong>: A lambda abstraction with no free variables.</p>
<hr />
<p>Another way to think about the <code>Y</code> combinator is as a <em>fixed-point</em> combinator.</p>
<p><strong>fixed-point</strong>. If <code>x = (f x)</code>, <code>x</code> is a <em>fixed-point</em> of the function <code>f</code>.</p>
<p>Suppose we have a function <code>fix</code> such that<code>(fix f)</code> that returns a fixed-point of <code>f</code>. Then, by the definition of a fixed-point,</p>
<pre><code>(fix f) = f (fix f)</code></pre>
<p>This can be expanded indefinitely as</p>
<pre><code>fix f =&gt; f (fix f) =&gt; f (f (fix f)) =&gt; ...</code></pre>
<p>Which is precisely the same as the <code>Y</code> combinator:</p>
<pre><code>Y f =&gt; f (Y f) = f (f (Y f))</code></pre>
<p>so we can say that <code>Y</code> is the lambda expression that implements the function <code>fix</code> for lambda functions.</p>
<hr />
<p>We know know how to recurse a function <code>R</code> an infinite number of times:</p>
<pre><code>Y R =&gt; R (Y R) =&gt; R (R (Y R)) =&gt; ...</code></pre>
<p>But suppose we want to only recurse <code>R</code> a finite number of times:</p>
<pre><code>Y R =&gt; R (Y R) =&gt; R (R (Y R)) =&gt; R ( R ( ... (R B)) ...)</code></pre>
<p>We’re going to have to bottom-out at some base-case <code>B</code>.</p>
<p>But how do we structure our function <code>R</code> so that it generates a base case, if <code>YR =&gt; R(Y R)</code>? Won’t that generate more copies of <code>R</code> no matter what we do?</p>
<p>Watch what happens if we apply <code>Y</code> to <code>0_</code>:</p>
<pre><code>Y 0_ =&gt; Y (\s z. z) -&gt; (\s z. z) Y (\s z. z) -&gt; (\s z. z) -&gt; 0_</code></pre>
<p><code>0_</code> throws away its first argument, and because it throws away the <code>Y</code>, the recursion stops. So we if build an <code>R</code> that at some point throws away the <code>Y</code> combinator, we’ll lose our means of producing new copies of <code>R</code>.</p>
<p>Let’s look at the example in the text, which is supposed to sum all the integers between <code>n</code> and <code>0_</code>:</p>
<pre><code>R = (\r n. isZero n 0_ (n succ (r (pred n))) )
sum n = Y R n </code></pre>
<p>Let’s do some reductions on this, starting with <code>sum 0_</code>:</p>
<pre><code>sum n = Y R 0_ =&gt;
Y (\r n. isZero n 0_ (n succ (r (pred n)))) 0_ =&gt;
(\rn.isZero n 0_ (n succ (r (pred n)))) (Y R) 0_ =&gt;
(isZero 0_ 0_ (0_ succ ((Y R) (pred 0_)))) =&gt;
true 0_ (0_ succ ((Y R) (pred 0_)))) =&gt;
0_</code></pre>
<p>Now <code>sum 1</code>:</p>
<pre><code>Y R 1 =&gt;
Y (\rn.isZero n 0_ (n succ (r (pred n)))) 1_ =&gt;
(\rn.isZero n 0_ (n succ (r (pred n)))) (Y R) 1_ =&gt;
(isZero 1_ 0_ (1_ succ ((Y R) (pred 1)))) =&gt;
false 0_ (1_ succ ((Y R) (pred 1)))) =&gt;
1_ succ ((Y R) (pred 1))) =&gt;
1_ succ (Y R 0) =&gt;
1_ succ 0 =&gt;
1_</code></pre>
<p>And <code>sum 2_</code> for good measure:</p>
<pre><code>Y R 2_ =&gt;
Y (\rn.isZero n 0_ (n succ (r (pred n)))) 2_ =&gt;
(\rn.isZero n 0_ (n succ (r (pred n)))) (Y R) 2_ =&gt;
(isZero 2_ 0_ (2_ succ ((Y R) (pred 2_)))) =&gt;
false 0_ (2_ succ ((Y R) (pred 2_)))) =&gt; 
2_ succ ((Y R) (pred 2_))) =&gt;
2_ succ (Y R 1_) =&gt;
2_ succ (1_ succ 0_) =&gt;
3_</code></pre>
<p>Let’s break this down into the general case:</p>
<pre><code>loop = \ test f next start. Y (\r s. test s (f (r (next s)))) start</code></pre>
<p>First we <code>test</code> our state <code>s</code> and return either <code>true</code> or <code>false</code>. In the example in the text, <code>test</code> is <code>isZero</code> and <code>s</code> is a number <code>n</code>.</p>
<p>If our test returns <code>true</code> we terminate by returning our <code>base</code>, (<code>0_</code> in the above example) otherwise we recurse and return <code>f (r (next s))</code>. The function <code>f</code> is what we’re actually interested in evaluating over our recursion. In the above the function <code>f</code> is <code>add n</code> or <code>(n succ m)</code>. The <code>r</code> is the stand-in for the rest of the recursion that will be generated with a <code>Y R</code> application. And the <code>next</code> is <code>pred</code> in the above example, because we want to count down from <code>n</code> to <code>0_</code> by 1s.</p>
<p>Supposing we want to loop a function <code>f</code> over the numbers from <code>m_</code> to <code>0_</code> (technically the term is <em>fold</em> <code>f</code> over the numbers <code>m_</code> to <code>0_</code>, but I don’t want to get into folds just now).</p>
<p>All we have to do is fill apply to loop to the corresponding variables:</p>
<pre><code>loop (\n. isZero n base) f pred m_ =&gt;  
  Y (\r n. isZero n base 
          (f (r (pred n)))
    ) 
  m_
=&gt; 
  (\r n. isZero n base (f (r (pred n)))) 
  ( Y (\r n. isZero base 
            (f (r (pred n)))
      )
  ) 
  m_
=&gt;
(\r n. isZero base 
  ( f 
    ( (Y (\r n. isZero base (f (r (pred n)))))
      (pred m_))
  )
)
=&gt;
...</code></pre>
<p>In this way we can build a wide range of finite recursive structures.</p>
<h1 id="projects-for-the-reader">5 Projects for the reader</h1>
<p>[<strong>N.B.</strong>: I have not tested any of this code. I plan on writing a Lambda Calculus interpreter at some point and when I do, I will test this code and add a link back here.]</p>
<h2 id="less-than-and-greater-than">1 “less than” and “greater than”</h2>
<p>See <a href="#equality-and-inequalities">section 3.4</a></p>
<h2 id="positive-and-negative-integers">2 Positive and Negative Integers</h2>
<p>Let <code>(\x. x np nn)</code> be the pair of natural numbers <code>np</code>, and <code>nn</code>, the integer <code>n</code> will then be the difference <code>np - nn</code>. In other words, <code>np</code> is the positive component of <code>n</code> and <code>nn</code> is the negative component.</p>
<p>However, in this representation there will be many possible expressions that signify the same integer. Let us then define the case where either <code>np</code> or <code>nn</code> equals <code>0</code> as the canonical or simplified representation.</p>
<p>To make things easier let’s define some aliases for handling pairs:</p>
<pre><code>pair = \a b. (\x . x a b)
fst = \p. p true
snd = \p. p false</code></pre>
<p><code>pair</code> makes a pair out of two elements. <code>fst</code> returns the first element of a pair. <code>snd</code> returns the second element of a pair.</p>
<p>We can then define a function <code>simplifyInt</code> as:</p>
<pre><code>simplifyInt = (\x. ( \ p n. (gte p n) 
                            (pair (n pred p) 0)
                            (pair 0 (p pred n))
                   ) 
                   (fst x)
                   (snd x)
              )
</code></pre>
<p>If <code>p</code> is greater than or equal to <code>n</code>, the number is positive, so we apply <code>pred</code> <code>n</code> times to <code>p</code>, yielding an integer <code>(p - n, 0)</code>. Otherwise, we apply <code>pred</code> <code>n</code> times to <code>p</code>, yielding an integer <code>(0, n - p)</code>.</p>
<p>In either case, the integer is now in “lowest terms”, so to speak.</p>
<h2 id="addition-and-subtraction-of-integers">3 Addition and Subtraction of Integers</h2>
<p>Adding two integers <code>(p, n)</code> and <code>(q, m)</code> is the same as adding their components and simplifying:</p>
<pre><code>addInt = \ x y. simplifyInt 
                (pair (add (fst x) (fst y)) 
                      (add (snd x) (snd y))
                )</code></pre>
<p>Subtracting is the same as adding with sign-flip function, called <code>negate</code>:</p>
<pre><code>negateInt  = \ x . pair (snd x) (fst x)
subtractInt = \ x y. addInt x (negateInt y)</code></pre>
<h2 id="division-of-positive-integers-recursively">4 Division of positive integers recursively</h2>
<p>The positive integers are the natural numbers, so we’ll have our <code>div</code> function return a natural number.</p>
<p>If in <code>div x d</code> either <code>x</code> or <code>d</code> are negative, we’ll return 0 to signify an error.</p>
<pre><code>loop = \ test f next start. Y (\r s. test s ((f s) (r (next s)))) start

divUnsafe = \ x d. loop (\s . (lth s d)) 0) (\s. succ) (\s . d pred s) x

div = \x d. (\x d . (and (gte x 0) (gte d 0) (divUnsafe x d) 0))
            (fst (simplify x))
            (fst (simplify d))</code></pre>
<h2 id="factorial">5 Factorial</h2>
<pre><code>factorial = \n . loop (\n. isZero n 1) (\n. multiply n) pred n</code></pre>
<h2 id="rational-numbers">6 Rational Numbers</h2>
<p>Our rational number representation will be a pair of integers: a numerator <code>x</code> and a divisor <code>y</code>:</p>
<pre><code>pair x y</code></pre>
<h2 id="addition-subtraction-multiplication-and-division-of-rationals">7 Addition, Subtraction, Multiplication, and Division of Rationals</h2>
<p>First we’re going to need a way to multiply integers, if we have two integers <code>x = (p - n)</code>, and <code>y = (q - m)</code>, then <code>x</code> multiplied by <code>y</code> is</p>
<pre><code>(p - n) (q - m) = (pq + nm) - (nq + pm)</code></pre>
<p>Since according to our integer representation, <code>p</code>, <code>n</code>, <code>q</code>, and <code>m</code> are all natural numbers, we can do this:</p>
<pre><code>multiplyInt = \x y. pair (add (multiply (fst x) (fst y)) 
                              (multiply (snd x) (snd y))
                         )
                         (add (multiply (snd x) (fst y)) 
                              (multiply (fst x) (snd y))
                         )</code></pre>
<p>For adding rationals, since <code>a/b + c/d = (ad + cb)/bd</code>, and <code>a,b,c,d</code> are all integers:</p>
<pre><code>addR = \x y. pair (addInt (multiplyInt (fst x) (snd y)) 
                          (multiplyInt (fst y) (snd x))
                  ) 
                  (multiplyInt (snd x) (snd y))</code></pre>
<p>For subtraction, <code>a/b - c/d = (ad - cb)/bd</code>:</p>
<pre><code>subtractR = \x y. pair (subtractInt (multiplyInt (fst x) (snd y)) 
                                    (multiplyInt (fst y) (snd x))
                  ) 
                  (multiplyInt (snd x) (snd y))</code></pre>
<p>Multiplication, <code>(a/b) * (c/d) = (ac)/(bd)</code>:</p>
<pre><code>multiplyR = \x y. pair (multiplyInt (fst x) (fst y)) 
                       (multiplyInt (snd x) (snd y))</code></pre>
<p>Division, <code>(a/b) / (c/d) = (ad)/(cb)</code>:</p>
<pre><code>divideR = \x y. pair (multiplyInt (fst x) (snd y)) 
                     (multiplyInt (snd x) (fst y))</code></pre>
<h2 id="lists-of-numbers">8 Lists of Numbers</h2>
<p>A list can be thought of as either a <code>nil</code> element or a <code>cons</code> of head and a tail, where the head is an expression and the tail is a list.</p>
<p>If <code>x,y,z</code> are list elments then lists of lengths 0 to 3 are, respectively:</p>
<pre><code>0-list = nil
1-list = cons x nil
2-list = cons x (cons y nil))
3-list = cons x (cons y (cons z nil))</code></pre>
<p>Let’s turn the above into abstractions on the variables <code>x,y,z,c,n</code> where <code>c</code> stands for <code>cons</code> and <code>n</code> stands for <code>nil</code>:</p>
<pre><code>0-list = \ c n. n
1-list = \ x c n. c x n
2-list = \ x y c n. c x (c y n)
3 list = \ x y z c n. c x (c y (c z n))</code></pre>
<p>If we pass in elements to the above list constructors (so that <code>x_, y_, z_</code> are now representing expressions rather than variables):</p>
<pre><code>0-list = \ c n. n
1-list = \ c n. c x_ n
2-list = \ c n. c x_ (c y_ n)
3 list = \ c n. c x_ (c y_ (c z_ n))</code></pre>
<p>This suggests a nice list encoding as the right-fold of some function <code>c</code> over whatever we want our list elements to be, (with <code>n</code> as the base argument).</p>
<p>We already have our <code>nil</code> from the above as <code>\ c n . n</code>, now we need our <code>cons</code> function.</p>
<p>At first glance the function 2-list looks like a decent definition for <code>cons</code>, since it combines two elements into a list.</p>
<pre><code>2-list = \ x y c n. c x (c y n)</code></pre>
<p>But our definition of <code>cons</code> is that it combines an element (the head) and a list (the tail) into a list, not two elements.</p>
<p>Watch what happens if we pass an element <code>x_</code> and a list into <code>2-list</code></p>
<pre><code>\ c n . c x_ (c (\ c n. c a_ n) n)</code></pre>
<p>In Haskell list notation, the above is <code>[x, [a]]</code>, not <code>[x, a]</code>, which is what we want.</p>
<p>But since a list is a function of <code>c</code> and <code>n</code>, we can modify 2-list slightly like so:</p>
<pre><code>cons = \ x y c n. c x (y c n)</code></pre>
<p>Now if we call <code>cons</code> with <code>x_</code> and <code>\ c n. c a_ n</code> we get</p>
<pre><code>cons x_ (\ c n. c a_ n) =&gt;
\ c n. c x_ ((\c n. c a_ n) c n) 
\ c n. c x_ (c a_ n) </code></pre>
<p>Which does what we want. I like to think of cons as folding some function <code>c</code> over the tail with <code>n</code> and then adding one more fold layer of <code>c</code> with the head.</p>
<h2 id="list-head">9 List Head</h2>
<p>Since our list is a fold of a function <code>c</code> over the elements of a list, we call our list with <code>true</code>, or <code>\ x y. x</code> to throw away the tail. As an example:</p>
<pre><code>(\ c n. c x_ (c y_ n)) true =&gt;
true x_ (c y_ n) =&gt;
x_</code></pre>
<p>But if the list is nil <code>\ c n. n</code> we want to return <code>nil</code>, so our <code>head</code> function is actually:</p>
<pre><code>head = \ l. l true nil</code></pre>
<h2 id="list-length">10 List Length</h2>
<p>We fold <code>(\ x. succ)</code> over the list with nil as <code>0_</code>:</p>
<pre><code>length = \ l. l (\ x. succ) 0_</code></pre>
<p>As an example,</p>
<pre><code>length (\ c n. c x_ (c y_ n)) =&gt;
(\ c n. c x_ (c y_ n)) succ 0_ =&gt;
(\ x. succ) x_ ((\ x. succ) y_ 0_)) =&gt;
(succ (succ 0_)) =&gt;
2_</code></pre>
<p>We add the extra abstraction over <code>succ</code> to throw away the list elements.</p>
<h2 id="turing-machine">11 Turing Machine</h2>
<p>So the rest of this document is fairly self-contained, but this question is introducting a pretty big conceptual dependency. Namely, what precisely is a Turing Machine?</p>
<p>I’ll cover this in a future post and link back here.</p>
<p>Also, if I’m going to write a Turing Machine in Lambda Calculus, I absolutely want to write proper executable code. Writing massive walls of pseudocode that don’t do anything is no fun. Code is meant to run!</p>
<p>So I’m going to go write a Lambda Calculus interpreter, vivify all the dead notation in this document, and then come back to this question.</p>

        </div>
        <div id="footer">
          <p>&copy; <script>document.write(new Date().getFullYear());</script>
             John Chandler Burnham. 
            Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> 
          </p>
        </div>
    </body>
</html>
