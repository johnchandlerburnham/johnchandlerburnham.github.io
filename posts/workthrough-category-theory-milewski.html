<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>John Chandler Burnham - Workthrough: Category Theory for Programmers (Milewski)</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">jcb</a>
                <a href="../posts.html">posts</a>
                <a href="../projects.html">projects</a>
                <a href="https://github.com/johnchandlerburnham">github</a>
            </div>
        </div>

        <div id="content">
            <h1>Workthrough: Category Theory for Programmers (Milewski)</h1>
              <div class="info">
    Posted on December 15, 2017
    
        by jcb
    
</div>
<div class="info">
    
    Tags: <a href="../tags/workthrough.html">workthrough</a>, <a href="../tags/haskell.html">haskell</a>, <a href="../tags/math.html">math</a>, <a href="../tags/category-theory.html">category-theory</a>
    
</div>

<hr>

<hr>
<h2>Contents</h2>
<ul>
<li><a href="#category-the-essence-of-composition">1 Category: The Essence of Composition</a><ul>
<li><a href="#arrows-as-functions.">1.1 Arrows as Functions.</a></li>
<li><a href="#properties-of-composition">1.2 Properties of Composition</a></li>
<li><a href="#challenges">1. 4 Challenges</a></li>
</ul></li>
<li><a href="#types-and-functions">2 Types and Functions</a><ul>
<li><a href="#what-are-types">2.3 What are Types</a></li>
<li><a href="#why-do-we-need-a-mathematical-model">2.4 Why Do we need a Mathematical Model</a></li>
<li><a href="#pure-and-dirty-functions">2.5 Pure and Dirty Functions</a></li>
<li><a href="#examples-of-types">2.6 Examples of Types</a></li>
<li><a href="#challenges-1">2.6 Challenges</a></li>
</ul></li>
<li><a href="#categories-great-and-small">3 Categories Great and Small</a><ul>
<li><a href="#no-objects">3.1 No objects</a></li>
<li><a href="#simple-graphs">3.2 Simple Graphs</a></li>
<li><a href="#orders">3.3 Orders</a></li>
<li><a href="#monoid-as-set">3.4 Monoid as Set</a></li>
<li><a href="#monoid-as-category">3.5 Monoid as Category</a></li>
<li><a href="#challenges-2">3.6 Challenges</a></li>
</ul></li>
<li><a href="#kleisli-categories">4 Kleisli Categories</a></li>
<li><a href="#products-and-coproducts">5 Products and Coproducts</a><ul>
<li><a href="#initial-object">5.1 Initial Object</a></li>
<li><a href="#terminal-object">5.2 Terminal Object</a></li>
<li><a href="#duality">5.3 Duality</a></li>
<li><a href="#isomorphisms">5.4 Isomorphisms</a><ul>
<li><a href="#theorem-any-category-has-at-most-one-initial-object-up-to-isomorphism">Theorem: Any category has at most one initial object (up to isomorphism)</a></li>
</ul></li>
<li><a href="#products">5.5 Products</a></li>
<li><a href="#coproduct">5.6 Coproduct</a></li>
<li><a href="#challenges-3">5.8 Challenges</a></li>
</ul></li>
<li><a href="#simple-algebraic-data-types">6 Simple Algebraic Data Types</a><ul>
<li><a href="#challenges-4">6.5 Challenges</a></li>
</ul></li>
</ul>
<hr>
<p><strong>Work in Progress</strong></p>
<h1 id="category-the-essence-of-composition">1 Category: The Essence of Composition</h1>
<p><strong>category</strong>: A structure consisting of objects and arrows between objects, such that arrows compose. That is, if a category has objects <code>A</code>, <code>B</code> and <code>C</code> along with arrows <code>A -&gt; B</code>, <code>B -&gt; C</code>, then it also has the arrow <code>A -&gt; C</code>.</p>
<h2 id="arrows-as-functions.">1.1 Arrows as Functions.</h2>
<p>Arrows are also called morphisms, which comes from the Greek “morphe” meaning form.</p>
<p>Notation:</p>
<ul>
<li><code>.</code> is composition, <code>(g . f)(x) = g(f(x))</code></li>
<li><code>::</code> is type of, like <code>f :: Integer</code></li>
<li><code>-&gt;</code> is an arrow, <code>f :: A -&gt; B</code> means <code>f</code> is a morphism from <code>A</code> to <code>B</code></li>
</ul>
<h2 id="properties-of-composition">1.2 Properties of Composition</h2>
<ol style="list-style-type: decimal">
<li><p>Composition of arrows is associative, so that</p>
<pre><code>h . (g . f) = (h . g) . f = h . g . f</code></pre>
<p>This makes sense with the definition of a category. Suppose a category contains objects <code>A, B, C, D</code> and arrows:</p>
<pre><code>f :: A -&gt; B
g :: B -&gt; C
h :: C -&gt; D</code></pre>
<p>Then by definition it contains:</p>
<pre><code>(f . g) :: A -&gt; C
(h . g) :: B -&gt; D
(h . g . f) :: A -&gt; D</code></pre>
<p>Associativity just means that it doesn’t matter what order we compose arrows:</p>
<pre><code>h . (g . f) == (h . g) . f == h . g . f</code></pre></li>
<li><p>There is an identity arrow <code>A -&gt; A</code> for every object <code>A</code>, such that</p>
<pre><code>f :: A -&gt; B
g :: B -&gt; A
id_a :: A -&gt; A

f . id_a = f
id_a . g = g</code></pre></li>
</ol>
<p>One thing that confuses me is that it seems like this implies that in some cases that there can’t be multiple arrows from one object to another.</p>
<p>Suppose a category <code>Cat</code> has objects <code>A</code>, <code>B</code> and arrows</p>
<pre><code>f' :: A -&gt; B
f  :: A -&gt; B
g  :: B -&gt; A
id_a :: A -&gt; A
id_b :: B -&gt; B</code></pre>
<p>If <code>Cat</code> is a category, then the compositions of <code>g . f</code> and <code>g . f'</code> must be arrows in the category:</p>
<pre><code>g . f :: A -&gt; A 
g . f' :: A -&gt; A </code></pre>
<p>But the only arrow of type <code>A -&gt; A</code> is <code>id_a</code>, so</p>
<pre><code>g . f = g . f' = id_a</code></pre>
<p>And equivalently:</p>
<pre><code>f . g = f' . g = id_b</code></pre>
<p>Which implies:</p>
<pre><code>f' = f' . id_a = f' . g . f = id_b . f = f </code></pre>
<p>So, either <code>Cat</code> is not a category, or <code>f' == f.</code></p>
<p>cf. <a href="https://en.wikibooks.org/wiki/Haskell/Category_theory#Hask,_the_Haskell_category">Haskell Wikibook page on Category Theory</a></p>
<p>I think the important thing to keep in mind here is that when looking at a possible structure to see if its a category, the structure is constant. There aren’t any implicit elements of <code>Cat</code> that could also satisfy the property that e.g <code>(g . f)</code> is in <code>Cat</code>. We actually have to look in <code>Cat</code> to find if something fits the properties. If not, it’s not a category.</p>
<p>When I first approached this topic I confused the statements:</p>
<ul>
<li>For any arrows <code>g</code> and <code>f</code> in a category <code>C</code>, their composition <code>(g . f)</code> must also be an arrow in <code>C</code>. (<strong>Right</strong>)</li>
<li>If arrows <code>g</code> and <code>f</code> are arrows in <code>C</code>, add a new arrow <code>(g . f)</code> to <code>C</code>. (<strong>Wrong</strong>)</li>
</ul>
<p>This really confused me for a bit, until I realized that when I was doing the latter I was just trying to build a superset of <code>C</code> that actually was a category. This is apparently called a “free category”.</p>
<h2 id="challenges">1. 4 Challenges</h2>
<ol style="list-style-type: decimal">
<li><code>I = (\x. x)</code> in the lambda calculus.</li>
<li><p><code>compose = (\x y z. x (y z))</code></p></li>
<li><p><code>compose I F X = (\x y z. x (y z)) I F X = I (F X) = F X</code> <code>compose F I X = (\x y z. x (y z)) F I X = F (I X) = F X</code></p></li>
<li>No, links are not composable.</li>
<li>Friendships are not composable.</li>
<li><p>When the edges are composable, and every node has a self-directed edge.</p></li>
</ol>
<hr />
<h1 id="types-and-functions">2 Types and Functions</h1>
<h2 id="what-are-types">2.3 What are Types</h2>
<p><strong>Set</strong>: A category whose objects are sets and whose arrows are functions.</p>
<p><strong>Hask</strong>: Set, except every set is extended with the bottom element <code>_|_</code>, indicating non-termination.</p>
<p>The question of whether <strong>Hask</strong> is actually a category appears to be an <a href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/comment-page-1/">interesting one</a></p>
<p>[TODO: Workthrough of <a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf">Fast and Loose Reasoning is Morally Correct</a>]</p>
<h2 id="why-do-we-need-a-mathematical-model">2.4 Why Do we need a Mathematical Model</h2>
<p><strong>operational semantics</strong>: Describing how a program runs by trying to directly reason about how it operates on some idealized abstract machine.</p>
<p><strong>denotational semantics</strong>: Describing how a program runs by building a mathematical structure that corresponds to the program and proving theorems about that structure.</p>
<h2 id="pure-and-dirty-functions">2.5 Pure and Dirty Functions</h2>
<p><strong>pure function</strong>: A function that returns the same output for the same input, and whose output and input are explicit.</p>
<p>I wonder if a function in, for example, <code>C</code> could be considered pure, but only if we treat the whole state of the machine, or maybe the whole state of the universe as the input and output types.</p>
<h2 id="examples-of-types">2.6 Examples of Types</h2>
<p><strong>Void</strong>: The type with no elements (other than <code>_|_</code>, of course, if we’re in Hask)</p>
<p><strong>()</strong>: Unit, the type with only one element: <code>()</code></p>
<h2 id="challenges-1">2.6 Challenges</h2>
<ol style="list-style-type: decimal">
<li><p>[TODO: Memoization in Haskell.]</p></li>
<li><p>4 functions</p>
<pre><code>not :: Bool -&gt; Bool
id_bool :: Bool -&gt; Bool
(const True) :: Bool -&gt; Bool
(const False) :: Bool -&gt; Bool</code></pre></li>
<li><pre><code>absurdUnit :: Void -&gt; ()
absurdTrue :: Void -&gt; Bool
absurdFalse :: Void -&gt; Bool

id_Void :: Void -&gt; Void
id_unit :: () -&gt; ()
id_bool :: Bool -&gt; Bool

not :: Bool -&gt; Bool
(const True) :: Bool -&gt; Bool
(const False) :: Bool -&gt; Bool

(const True)  :: () -&gt; Bool
(const False) :: () -&gt; Bool

unit :: Bool -&gt; ()</code></pre></li>
</ol>
<p>[TODO: Diagram]</p>
<h1 id="categories-great-and-small">3 Categories Great and Small</h1>
<h2 id="no-objects">3.1 No objects</h2>
<p>The empty category!</p>
<h2 id="simple-graphs">3.2 Simple Graphs</h2>
<p><strong>free category</strong>: A category generated by a directed graph by turning nodes into objects, edges into arrows and adding new edges for every composition of arrows.</p>
<p>Okay so generating free categories is what I was doing in chapter 2 that was confusing me. Subtle!</p>
<h2 id="orders">3.3 Orders</h2>
<p><strong>preorder</strong>: If a set <code>P</code> has a binary relation <code>pre :: P -&gt; P -&gt; Bool</code> such that for all</p>
<pre><code>x :: P, y :: P, z :: P

pre x x = True                      -- reflexive
pre x y &amp;&amp; pre y z =&gt; pre x z       -- transitive</code></pre>
<p>Then <code>pre</code> is a preorder.</p>
<p><strong>partial order</strong>: If a set <code>P</code> has a binary relation <code>part :: P -&gt; P -&gt; Bool</code> such that for all</p>
<pre><code>x :: P, y :: P

part x y = pre x y                 -- part is a preorder
part x y &amp;&amp; part y x =&gt; x == y     -- antisymmetric </code></pre>
<p>then <code>part</code> is a partial order</p>
<p><strong>total order</strong>: If a set <code>P</code> has a binary relation <code>tot :: P -&gt; P -&gt; Bool</code>, such that for all</p>
<pre><code>x :: P, y :: P

tot x y = part x y                 -- tot is a partial order
tot x y || tot y x = True          -- total (defined for all P)</code></pre>
<p>then <code>tot</code> is a total order.`</p>
<p><strong>thin category</strong>: A category where between any two objects <code>X</code> and <code>Y</code> there is at most one arrow <code>X -&gt; Y</code> from <code>X</code> to <code>Y</code>.</p>
<p><strong>hom-set</strong>: The set of arrows from an object <code>X</code> to an object <code>Y</code>.</p>
<pre><code>hom-set :: Category -&gt; Object -&gt; Object -&gt; {Arrow}</code></pre>
<p>I don’t really like the name “hom-set”. I get that “hom” stands for “homomorphism”, but I hate using apocope (eliding syllables from the ends of words) to generate new terms. It’s slangy, offloads important “info” onto implicit context, sounds ugly and confuses me. Hate it.</p>
<p>I’ve read that some books use “morphisms” as a way to describe “hom-set”. That’s a lot better, but still not perfect…</p>
<p>I kind of like thinking about the set of morphisms from <code>X</code> to <code>Y</code> as the “volley” of arrows from <code>X</code> to <code>Y</code>. I especially like that “volley” comes from Latin “volare: to fly”. And that’s really what we’re after, which arrows “fly” from <code>X</code> to <code>Y</code>:</p>
<pre><code>volley :: Category -&gt; Object -&gt; Object -&gt; {Arrow}</code></pre>
<p>We’ll also need term for all the arrow in a whole category, not just between two ojects:</p>
<pre><code>vol :: Category -&gt; {Arrow}</code></pre>
<p>Okay, it’s another apocope, but this is actually a meaningful one. “Vol” is a French word meaning “flight”. And we can think of all the arrows in a category as being like a “flock” or a “flight” of arrows.</p>
<p>I’ve also read that the vol (hom-set) of a category is not necessarily a set. So I think the term “hom-set” really fails utterly in all parts for clearly conveying the concept.</p>
<p>I’m going to use my own made-up “vol”, “volley” terminology, mostly because I think it’s pretty. I’ll try to include definitions whenever I stray to far from this context:</p>
<pre><code>volley C a b = hom-set_C(a, b)
vol C = all morphisms of C</code></pre>
<p>[TODO: Extend archery terminology to other category theory concepts]</p>
<h2 id="monoid-as-set">3.4 Monoid as Set</h2>
<p><strong>monoid</strong> A set <code>M</code> with a binary operation</p>
<pre><code>mappend :: M -&gt; M -&gt; M</code></pre>
<p>and an element `</p>
<pre><code>mempty :: M</code></pre>
<p>such that for all</p>
<pre><code>a :: M, b :: M, c :: M

mappend (mappend a b) c = mappend a (mappend b c)  -- associative
mappend mempty a = mappend a mempty = a            -- identity element</code></pre>
<p>Addition of integers is a monoid:</p>
<pre><code>(a + b) + c = a + (b + c)
0 + a = a + 0 = a</code></pre>
<p>So is multiplication of integers:</p>
<pre><code>(a * b) * c = a * (b * c)
1 * a = a * 1 = a</code></pre>
<h2 id="monoid-as-category">3.5 Monoid as Category</h2>
<p>Treat <code>M</code> as an object, rather than a set. We can convert all elements of <code>M</code> into arrows:</p>
<p>The identity element turns into the identity arrow:</p>
<pre><code>mappend a mempty = mappend mempty a = id_M a = a id_M = a  -- identity arrow</code></pre>
<p>And every element <code>x</code> of <code>M</code> turns into:</p>
<pre><code>mappend x :: M -&gt; M</code></pre>
<p>where composition of arrows becomes:</p>
<pre><code>(mappend x1) . (mappend x2) = (mappend (mappend x1 x2)) :: M -&gt; M</code></pre>
<p>E.g, if the monoid is addition of integers:</p>
<pre><code>(+ 2) . (+ 3) = (+ (2 + 3)) = (+ 5)</code></pre>
<p>And since <code>mappend</code> is associative, so is composition</p>
<pre><code>(mappend x1) . (mappend x2) . (mappend x3) 
= ((mappend x1) . (mappend x2)) . (mappend x3)
= (mappend (mappend x1 x2)) . (mappend x3)  
= mappend (mappend (mappend x1 x2) x3)
= mappend (mappend x1 (mappend x2 x3))     
= (mappend x1) . (mappend (mappend x2 x3))
= (mappend x1) . ((mappend x2) . (mappend x3))</code></pre>
<p>E.g. with the integer addition monoid:</p>
<pre><code>(+2) . (+3) . (+4) = ((+5) . (+4)) = (+9)
                   = ((+2) . (+7)) = (+9)</code></pre>
<p>And thus we’ve turned <code>M</code> into a category!</p>
<p>And we can just as easily turn <code>M</code> back into a set by taking the set of arrow with <code>vol :: Category -&gt; {Arrow}</code>, (hom-set).</p>
<h2 id="challenges-2">3.6 Challenges</h2>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><p>Graph <code>G</code> with node <code>A</code> and no edges. Adding</p>
<pre><code>id_a :: A -&gt; A</code></pre>
<p>Gives a category.</p></li>
<li>This is a category</li>
<li><p>Graph <code>G</code> with nodes <code>A</code>, <code>B</code> and edge <code>A -&gt; B</code>. Adding</p>
<pre><code>id_A :: A -&gt; A
id_B :: B -&gt; B</code></pre>
<p>Gives a category.</p></li>
<li><p>Let the single node be the object <code>String</code>. from each edge generate prepender and appender arrows for each letter, so the <code>'a'</code> edge becomes <code>(++ &quot;a&quot;)</code> and <code>(&quot;a&quot; ++)</code>. Then add an empty string (++ “”) arrow, which is the identity. Then add arrows for the compositions of all arrows. And now we have the <code>String</code> monoid category.</p></li>
</ol></li>
<li><ol style="list-style-type: lower-alpha">
<li><p>Inclusion is</p>
<ul>
<li>reflexive, since by definition all elements of <code>A</code> are in <code>A</code></li>
<li>transitive, since if <code>A</code> is in <code>B</code> all elements of <code>A</code> are also in <code>B</code></li>
<li>antisymmetric, since if <code>A</code> is in <code>B</code> and <code>B</code> is in <code>A</code>. there are no elements that they do not share, so all their elements are the same, and thus <code>A == B</code></li>
<li>not necessarily total from the information given. If the set of sets is the set of sets of integers, for example, then <code>{1}, {2}</code> are both in the set, but <code>{2}</code> is not in <code>{1}</code> and <code>{1}</code> is not in <code>{2}</code>.</li>
</ul>
<p>But if the set of sets is, e.g. the set of the empty set <code>{{}}</code>, then the inclusion relation could be total. So this is actually an interesting question:</p>
<p>I think we can define this recursively: a set with total order is either the empty set or a set of sets with total order:</p>
<p><code>T-Set = {} | Set T</code></p>
<p>But then the question is how complicated does this set get? Because all the Von Neumann ordinals:</p>
<p><code>0 = {}   1 = {0} = {{}}   2 = {1} = {{{}}}   ...</code> are in <code>T-set</code>.</p>
<p>Oh, actually, this doesn’t work, because the inclusion relation the question only goes one level deep, I think. <code>A,B,C,D</code> are not elements of <code>{{A, B}, {C, D}}</code>, so <code>0</code> is not in <code>2</code> with Von Neumann encoding.</p>
<p>But if we changed our inclusion relation to:</p>
<p><code>A</code> is in <code>B</code> if all the elements of <code>A</code> are <em>included</em> in elements of <code>B</code>.</p>
<p>Then I think we get the <code>T-Set</code> above for all the sets with total order.</p>
<p>But I’m at the limits of my set theory here. I think I’ll add a book to my reading list and come back to this.</p>
<p>[TODO. Do a workthrough on set theory]</p></li>
<li><p>Skipping. Don’t care about <code>C++</code></p></li>
</ol></li>
<li><p>And-Monoid:</p>
<pre><code>mempty = True
mappend = (&amp;&amp;)

x &amp;&amp; True = x
True &amp;&amp; x = x

(x &amp;&amp; y) &amp;&amp; z = z &amp;&amp; (y &amp;&amp; z)</code></pre>
<p>Or-Monoid:</p>
<pre><code>mempty = False
mappend = (||)

x || False = x
False || x = x

(x || y) || z = z || (y || z)</code></pre></li>
<li><p>Bool Monoid Category, has object bool and arrows:</p>
<pre><code>andTrue :: Bool -&gt; Bool   -- identity
andFalse :: Bool -&gt; Bool  -- always returns false

andFalse . andFalse = andFalse</code></pre>
<p>And is commutative, so thats all there is.</p></li>
<li><p>Addition Mod 3, has object Int3 and arrows:</p>
<pre><code>(+ 0) :: Int3 -&gt; Int3    -- identity
(+ 1) :: Int3 -&gt; Int3
(+ 2) :: Int3 -&gt; Int3

(+ 1) . (+ 2) = (+ 2) . (+ 1) = (+ 0)
(+ 1) . (+ 1) = (+ 2)
(+ 2) . (+ 2) = (+ 1)</code></pre></li>
</ol>
<h1 id="kleisli-categories">4 Kleisli Categories</h1>
<p>This is a lot of <code>C++</code> code that I’m not particularly interested in deciphering. Since I already have some familiarity with monads I’m gonna skip it and come back if I’m blocked.</p>
<h1 id="products-and-coproducts">5 Products and Coproducts</h1>
<h2 id="initial-object">5.1 Initial Object</h2>
<p><strong>initial object</strong>: The initial object is the object that has one and only one morphism going to any object in the category.</p>
<p>This is like <code>Void</code>.</p>
<h2 id="terminal-object">5.2 Terminal Object</h2>
<p><strong>terminal object</strong>: The terminal object is the object with one and only one morphism coming to it from any object in the category.</p>
<p>This is like <code>()</code></p>
<p><strong>poset</strong>: A partially ordered set.</p>
<h2 id="duality">5.3 Duality</h2>
<p><strong>opposite category</strong>: For any category <code>C</code>, the opposite or dual category <code>C^op</code> is <code>C</code> with all the arrows reversed. If <code>f</code> and <code>g</code> are arrows in <code>C</code>, then</p>
<pre><code>g . f = f^(op) . g^(op)</code></pre>
<h2 id="isomorphisms">5.4 Isomorphisms</h2>
<p><strong>inverse</strong>: If for two objects <code>A</code> and <code>B</code> there are two arrows <code>f :: A -&gt; B</code> and <code>g :: A -&gt; B</code>, such that:</p>
<pre><code>f . g = id_A
g . f = id_B</code></pre>
<p><code>f</code> and <code>g</code> are inverses, or isomorphisms, and <code>A</code> and <code>B</code> are said to be isomorphic.</p>
<h3 id="theorem-any-category-has-at-most-one-initial-object-up-to-isomorphism">Theorem: Any category has at most one initial object (up to isomorphism)</h3>
<p>Proof:</p>
<p>Suppose a category <code>C</code> has two initial objects <code>I1</code> and <code>I2</code>. Then by definition it has the identity arrows:</p>
<pre><code>id_I1 :: I1 -&gt; I1
id_I2 :: I2 -&gt; I2</code></pre>
<p>And because <code>I1</code> and <code>I2</code> are initial objects, there must be only one arrow from <code>I1</code> to <code>I2</code>, and only one arrow from <code>I2</code> to <code>I1</code>:</p>
<pre><code>f :: I1 -&gt; I2
g :: I2 -&gt; I1</code></pre>
<p>But if <code>f</code> and <code>g</code> are arrows in <code>C</code> then so are</p>
<pre><code>(f . g) :: I2 -&gt; I2
(g . f) :: I1 -&gt; 11</code></pre>
<p>And since an initial object has only one arrow to every other object in the category, including itself:</p>
<pre><code>(f . g) = id_I2 :: I2 -&gt; I2
(g . f) = id_I1 :: I1 -&gt; 11</code></pre>
<p>And therefore <code>f</code> and <code>g</code> are inverses, so <code>I1</code> and <code>I2</code> are isomorphic.</p>
<p>Furthermore, since <code>I1</code> and <code>I2</code> are initial objects, <code>f</code> and <code>g</code> are the only arrows between them, and therefore are unique isomorphism.</p>
<h2 id="products">5.5 Products</h2>
<p><strong>product</strong>: A product of two objects <code>X1</code> and <code>X2</code> in a category <code>C</code> is an object <code>X</code> with two arrows</p>
<pre><code>p1 :: X -&gt; X1, p2 :: X -&gt; X2</code></pre>
<p>with the property that for all objects <code>Y</code> in <code>C</code> with arrows</p>
<pre><code>f1 :: Y -&gt; X1, f2 :: Y -&gt; X2</code></pre>
<p>there is a unique morphism <code>f :: Y -&gt; X</code> such that</p>
<pre><code>f . p1 = f1, f . p2 = f2</code></pre>
<p>One way to think about this is whenever a product of <code>X1</code> and <code>X2</code> exists, all the objects that have arrows to <code>X1</code> and <code>X2</code> have arrows to the product object <code>X</code>. In other words, <code>X</code> is the most “downwind” or terminal-like object in the collection of objects that have morphisms to <code>X1</code> and <code>X2</code></p>
<h2 id="coproduct">5.6 Coproduct</h2>
<p><strong>coproduct</strong>: The dual of the product. Take the definition of the product and reverse the arrows. In other words, the coproduct <code>X</code> of <code>X1</code> and <code>X2</code> is the object that has arrows to every object that both <code>X1</code> and <code>X2</code> have arrows to. It is the most “upwind”, or initial-like object in the collection of objects that have arrows from both <code>X1</code> and <code>X2</code>.</p>
<h2 id="challenges-3">5.8 Challenges</h2>
<ol style="list-style-type: decimal">
<li><p>See Theorem in 5.4</p></li>
<li><p>Okay, so the arrows in a poset represent the less-than-or-equal operator <code>&lt;=</code>, so for any object in the poset <code>A</code>, all objects <code>B</code> such that <code>A &lt;= B</code> have an arrow from <code>B</code> to <code>A</code>.</p>
<p>For the product of two objects <code>X</code> and <code>Y</code>, let’s consider all the objects <code>Z_n</code> that have arrows to both <code>X</code> and <code>Y.</code></p>
<p>So any two objects in <code>Z_n</code>, <code>Z1, Z2</code> have arrows:</p>
<pre><code>Z1 -&gt; X, Z1 -&gt; Y
Z2 -&gt; X, Z2 -&gt; Y</code></pre>
<p>Now since the poset is a partial order, we cannot assume that there are arrows between any objects in <code>Z_n</code>. (Nor can we assume there are arrows <code>X -&gt; Y</code>, or <code>Y &lt;- X</code>.) Because of this in some posetal categories, the product may be undefined for two objects, for example, in the category:</p>
<pre><code>Objects: X, Y, Z1, Z2

Arrows: 
Z1 -&gt; X, Z1 -&gt; Y, Z1 -&gt; Z1
Z2 -&gt; X, Z2 -&gt; Y, Z2 -&gt; Z2
X -&gt; X
Y -&gt; Y

Diagram:

Z1 -&gt; X
|     ^
v     |
Y &lt;- Z2</code></pre>
<p>This satisfies the category properties of composition and identity (since arrows in the above category can only be composed with identity arrows) and the partial order properties, but there is no defined product of <code>Y</code> and <code>X</code></p>
<p>For the product of <code>X</code> and <code>Y</code> to exist, there must be some element <code>Z</code> of <code>Z_n</code> such that all objects <code>Z_i</code> in <code>Z_n</code> have arrows <code>Z_i -&gt; Z</code>. In other words, if arrows in a posetal category represent “less-than-or-equal”, the product of <code>X</code> and <code>Y</code> is the greatest of all objects less than or equal to <code>X</code> and <code>Y</code>, or the greatest lower bound of <code>X</code> and <code>Y</code>.</p>
<p>Interestingly, if e.g. <code>X -&gt; Y</code> then <code>X</code> is in <code>Z_n</code> because of <code>X -&gt; X</code>. And by definition is the greatest lower bound (because all <code>Z_i</code> have <code>Z_i -&gt; X</code>). So if there is an arrow between <code>X</code> and <code>Y</code>, the product is simply the minimum of the two.</p></li>
<li><p>The coproduct of two objects <code>X</code> and <code>Y</code> in a posetal category is the least upper bound of <code>X</code> and <code>Y</code>, that is, the smalllest object that is greater than or equal to both. It’s exactly like the product, but with the arrows reversed.</p></li>
<li>I have no favorite languages other than Haskell.</li>
<li><p>So despite the C++ code, I think I can translate this problem into something</p>
<p>I can do:</p>
<pre><code>i :: Int -&gt; Int
i x = x

j :: Bool -&gt; Int
j x = if x then 1 else 0</code></pre>
<p><code>Either</code> in Haskell is:</p>
<pre><code>Either a b = Left a | Right b

Left :: a -&gt; Either a b
Right :: b -&gt; Either a b</code></pre>
<p><code>Either Int Bool</code> is a “better” coproduct of <code>Int</code> and <code>Bool</code> than <code>Int</code> if there is a unique arrow <code>unleft</code> from <code>Either Int Bool</code> to <code>Int</code> such that:</p>
<pre><code>(unleft . Left) = id_Int</code></pre>
<p>This function exists:</p>
<pre><code>unleft (Left x) = x
unleft _ = 0</code></pre>
<p>Note that while <code>(unleft . Left) = id_x</code>, <code>(Left . unleft) \= id_Either</code>, because <code>Left (unleft (Right True) = Left 0</code>. If both composition equalled identity, then the two types would be isomorphic, but they are not. Either Int Bool is epimorphic (surjective) on Int, and Int is monomorphic (injective) on Either Int Bool.</p>
<p>One thing that confuses me though, is that it seems like <code>unleft</code> isn’t unique, because we could replace whatever number gets produced from a <code>Right</code> with any <code>Int</code>… So I’m clearly missing something here.</p>
<p>Oh I see! The morphism from <code>Either Int Bool -&gt; Int</code> is unique <em>given</em> two injections from <code>Int -&gt; Int</code> and <code>Bool -&gt; Int</code>. So the morphism shouldn’t be named <code>unleft</code> at all, but actually <code>embed</code>, because it embeds an Either in <code>Int</code> space.</p>
<p>Let’s look at our category:</p>
<pre><code>Objects:
Int, Int, Bool, Either Int Bool

Arrows:

i :: Int -&gt; Int
i n = n

j :: Bool -&gt; Int
j True = 1
j False = 0

Left :: Int -&gt; Either Int Bool
Left n = Left n

Right :: Bool -&gt; Either Int Bool
Right b = Right b

embed :: Either Int Bool -&gt; Int
embed (Left n) = i n
embed (Right b) = j b
</code></pre>
<p><code>embed</code> is unique for any <code>i</code> and <code>j</code> because it’s just applying <code>i</code> and <code>j</code> based on which side of the <code>Either</code> we’re on.</p>
<p>And that’s how we get the <code>factorizer</code> from the text:</p>
<pre><code>factorizer :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
factorizer i j (Left a) = i a
factorizer i j (Right b) = j b</code></pre></li>
<li><p><code>id_Int = embed . Left</code>, but <code>id_Either \= Left . embed</code>, because <code>(Left . embed) (Right True) = Left 1</code></p>
<p>So there is an <code>Either Int Bool -&gt; Int</code> arrow that factorizes <code>Int -&gt; Int but not an</code>Int -&gt; Either Int Bool<code>that factorizes</code>Either Int Bool -&gt; Either Int Bool`</p>
<p>Another way to look at this is that if we try to treat <code>Int</code> as an <code>Either</code>, we don’t know if any given integer is supposed to be a <code>Left</code> or a <code>Right</code>.</p>
<p>Like, if <code>j</code> sends <code>True, False</code> to <code>1, 0</code> and <code>i</code> sends <code>1, 0</code> to <code>1, 0</code> we don’t know if applying <code>m :: Int -&gt; Either Int Bool</code> to <code>1</code> should be a <code>Left 1</code> or a <code>Right True</code>.</p></li>
<li><p>Our Category:</p>
<pre><code>i :: Int -&gt; Int
i n 
  | n &lt; 0 = n
  | otherwise = n + 2

j :: Bool -&gt; Int
j b = if b then 1 else 0

Left :: Int -&gt; Either Int Bool
Right :: Bool -&gt; Either Int Bool</code></pre>
<p>Suppose Int is a “better” coproduct of Int and Bool with injections <code>i</code> and <code>j</code> than <code>Either Int Bool</code>. Then there must be a unique morphism <code>m :: Int -&gt; Either Int Bool</code> such that:</p>
<pre><code>m . i = Left
m . j = Right</code></pre>
<p>If on the other hand there is another morphism <code>m' :: Int -&gt; Either Int Bool</code>, <code>m /= m'</code> such that</p>
<pre><code>m' . i = Left
m' . j = Right</code></pre>
<p>Then <code>m</code> would not be a unique factorizing morphism and therefore <code>Int</code> could not be a better coproduct of <code>Int</code> and <code>Bool</code> than <code>Either Int Bool</code></p>
<p>Here’s a candidate for <code>m</code>:</p>
<pre><code>m :: Int -&gt; Either Int Bool
m n
 | n == 0 = Right False
 | n == 1 = Right True
 | n &lt; 0 = Left n
 | otherwise = Left (n - 2)</code></pre>
<p>This looks pretty unique at first glance.</p>
<p>However.</p>
<p>We can show that there is a unique morphism <code>f = (factorize i j) :: Either Int Bool -&gt; Int</code>:</p>
<pre><code>factorize :: (Int -&gt; Int) -&gt; (Bool -&gt; Int) -&gt; Either Int Bool -&gt; Int
factorize i j (Left n)  = i n
factorize i j (Right b) = j b</code></pre>
<p>such that</p>
<pre><code>f . Left = i
f . Right = j</code></pre>
<p>So if both <code>m</code> and <code>f</code> are unique morphisms, then</p>
<pre><code>f . Left = f . (m . i) = (f . m) . i = i
f . Right = f . (m . j) = (f . m) . j = j 
=&gt; (f . m) = id_Int

m . i = m . (f . Left) = (m . f) . Left = Left
m . j = m . (f . Right) = (m . f) . Right = Right 
=&gt; (m . f) = id_EitherIntBool</code></pre>
<p>which implies that <code>m</code> and <code>f</code> are isomorphisms. And since <code>m</code> and <code>f</code> are unique morphisms that fit the above conditions, <code>m</code> and <code>f</code> are unique isomorphisms. Which means <code>Either Int Bool</code> and <code>Int</code> are uniquely isomorphic, and are equivalent up to unique isomorphism. In which case <code>Int</code> cannot be a <em>better</em> coproduct that <code>Either Int Bool</code>.</p>
<p>On the other hand, if <code>m</code> is not unique, there must be another <code>m' :: Int -&gt; Either Int Bool</code>, in which case <code>Int</code> does not satisfy the universal property of coproducts.</p>
<p>Actually, I think this is a general argument which applies to any possible candidate coproduct. If we already know that there is a coproduct in the category that satisfies the universal property, then any other other coproduct that satisfies the property must be uniquely isomorphic to the first, since their isomorphisms uniquely factorize their injections.</p>
<p>Wow. That’s a mathy paragraph. I begin to see why math explanations sound as impenetrable as they usually do…</p></li>
<li><p><code>()</code> is an inferior coproduct of <code>Int</code> and <code>Bool</code> than <code>Either Int Bool</code>, because there is only one unique morphism <code>unit :: Either Int Bool -&gt; ()</code>, but no morphisms from <code>() -&gt; Either Int Bool</code> that factorize injections from <code>unit :: Int -&gt; ()</code> and <code>unit :: Bool -&gt; ()</code>.</p>
<p>But the question is asking for an inferior candidate that admits multiple morphisms between it and Either Int Bool.</p>
<p><code>Int</code> is an inferior coproduct of Int and Bool. Suppose we have the morphisms:</p>
<pre><code>Left :: Int -&gt; Either Int Bool
Right :: Bool -&gt; Either Int Bool

p :: Int -&gt; Int
p = (+3)

q :: Bool -&gt; Int
q True = 1
q False = 0</code></pre>
<p>Is there a unique morphism</p>
<pre><code>m :: Int -&gt; Either Int Bool</code></pre>
<p>such that</p>
<pre><code>m . p = Left
m . q = Right</code></pre>
<p>No! Because <code>p</code> and <code>q</code> don’t map any values to <code>2 :: Int</code>, we can have</p>
<pre><code>m :: Int -&gt; Either Int Bool
m 0 = Right False
m 1 = Right True
m 2 = (a :: Either Int Bool)
m n = n - 3</code></pre>
<p>We can return any <code>Either Int Bool</code> for <code>m 2</code> and <code>m</code> will still factorize, so we actually have infinite morphisms that satisfy the property. Therefore, Int is a very bad coproduct for Either Int Bool.</p>
<p>On the other hand, the fact that we can use <code>Int</code> as a coproduct at all (even an inferior one) is convenient, because it lets use model coproducts (and other GADTs) on computers that only know about discrete quantites.</p></li>
</ol>
<h1 id="simple-algebraic-data-types">6 Simple Algebraic Data Types</h1>
<h2 id="challenges-4">6.5 Challenges</h2>
<ol style="list-style-type: decimal">
<li><p>Isomorphism:</p>
<pre><code>f :: Maybe a -&gt; Either () a
f Nothing = Left ()
f Just a = Right a

g :: Either () a -&gt; Maybe a
g (Left ()) = Nothing
g (Right a) = Just a</code></pre></li>
<li><p>Life is too short for OOP boilerplate. Break the cycle Morty, rise above, focus on FP.</p></li>
<li><p>Let’s think about all the possible values of <code>a + a</code> and <code>2 x a</code>:</p>
<pre><code>a + a ~ Either a a = Left a | Right a
2 x a ~ (Bool, a)</code></pre>
<p>But <code>(Bool, a)</code> is just</p>
<pre><code>(True, a)
(False, a)</code></pre>
<p>so we have the isomorphism:</p>
<pre><code>f :: Either a a -&gt; (Bool, a)
f (Left a) = (True, a)
f (Right a) = (False, a)

g :: (Bool, a) -&gt; Either a a
g (True, a) = Left a
g (False, a) = Right a</code></pre></li>
</ol>

        </div>
        <div id="footer">
          <p>&copy; <script>document.write(new Date().getFullYear());</script>
             John Chandler Burnham. 
            Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> 
          </p>
        </div>
    </body>
</html>
