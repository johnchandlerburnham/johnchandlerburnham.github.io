<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>John Chandler Burnham - Workthrough: Haskell Programming (Allen & Moronuki)</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../">jcb</a>
                <a href="../posts.html">posts</a>
                <a href="../projects.html">projects</a>
                <a href="https://github.com/johnchandlerburnham">github</a>
            </div>
        </div>

        <div id="content">
            <h1>Workthrough: Haskell Programming (Allen & Moronuki)</h1>
              <div class="info">
    Posted on November  1, 2017
    
        by jcb
    
</div>
<div class="info">
    
    Tags: <a href="../tags/workthrough.html">workthrough</a>, <a href="../tags/haskell.html">haskell</a>
    
</div>

<hr>

<hr>
<h2>Contents</h2>
<ul>
<li><a href="#preliminaries">Preliminaries</a></li>
<li><a href="#all-you-need-is-lambda">1 All You Need is Lambda</a><ul>
<li><a href="#what-is-a-function">1.3 What is a Function?</a></li>
<li><a href="#the-structure-of-lambda-terms">1.4 The Structure of lambda terms</a></li>
<li><a href="#beta-reduction">1.5 Beta reduction</a><ul>
<li><a href="#intermission-equivalence-exercises-p.13">Intermission: Equivalence Exercises (p.13)</a></li>
</ul></li>
<li><a href="#evaluation-is-simplification">1.7 Evaluation is simplification</a></li>
<li><a href="#chapter-exercises-p.17">1.11 Chapter Exercises (p.17)</a><ul>
<li><a href="#combinators">Combinators</a></li>
<li><a href="#normal-form-or-diverge">Normal form or diverge?</a></li>
<li><a href="#beta-reduce">Beta Reduce</a></li>
</ul></li>
<li><a href="#follow-up-resources">1.14 Follow-up Resources</a></li>
</ul></li>
<li><a href="#hello-haskell">2 Hello Haskell!</a><ul>
<li><a href="#hello-haskell-1">2.1 Hello, Haskell</a></li>
<li><a href="#understanding-expressions">2.5 Understanding expressions</a><ul>
<li><a href="#exercises-comprehension-check">Exercises: Comprehension Check</a></li>
</ul></li>
<li><a href="#infix-operators">2.6 Infix Operators</a><ul>
<li><a href="#exercises-parentheses-and-association">Exercises: Parentheses and Association</a></li>
</ul></li>
<li><a href="#declaring-values">2.7 Declaring values</a><ul>
<li><a href="#exercises-heal-the-sick">Exercises: Heal the Sick</a></li>
</ul></li>
<li><a href="#arithmetic-functions-in-haskell">2.8 Arithmetic functions in Haskell</a></li>
<li><a href="#parenthesization">2.9 Parenthesization</a><ul>
<li><a href="#exercises-a-head-code">Exercises: A Head Code</a></li>
</ul></li>
<li><a href="#chapter-exercises">2.11 Chapter Exercises</a><ul>
<li><a href="#parenthesization-1">Parenthesization</a></li>
<li><a href="#equivalent-expressions">Equivalent expressions</a></li>
<li><a href="#more-fun-with-functions">More fun with functions</a></li>
</ul></li>
<li><a href="#follow-up-resources-1">2.13 Follow-up resources</a></li>
</ul></li>
<li><a href="#strings">3 Strings</a><ul>
<li><a href="#lists">Lists</a></li>
<li><a href="#char">Char</a></li>
<li><a href="#strings-ii">Strings II</a></li>
<li><a href="#top-level-versus-local-definitions">3.4 Top-level versus local definitions</a><ul>
<li><a href="#exercises-scope">Exercises: Scope</a></li>
</ul></li>
<li><a href="#types-of-concatenation-functions">3.5 Types of concatenation functions</a><ul>
<li><a href="#exercises-syntax-errors">Exercises: Syntax Errors</a></li>
</ul></li>
<li><a href="#chapter-exercises-1">Chapter Exercises</a><ul>
<li><a href="#reading-syntax">Reading syntax:</a></li>
<li><a href="#building-functions">Building Functions:</a></li>
</ul></li>
</ul></li>
<li><a href="#basic-datatypes">4 Basic Datatypes</a><ul>
<li><a href="#what-are-types">4.2 What are types?</a></li>
<li><a href="#anatomy-of-a-data-declaration">4.3 Anatomy of a data declaration</a><ul>
<li><a href="#exercises-mood-swing">Exercises: Mood Swing</a></li>
</ul></li>
<li><a href="#numeric-types">4.4 Numeric types</a></li>
<li><a href="#go-on-and-bool-me">4.6 Go on and Bool me</a><ul>
<li><a href="#exercises-find-the-mistakes">Exercises: Find the Mistakes</a></li>
</ul></li>
<li><a href="#chapter-exercises-2">4.9 Chapter Exercises</a><ul>
<li><a href="#correcting-syntax">Correcting syntax</a></li>
<li><a href="#match-the-function-names-to-their-types">Match the function names to their types</a></li>
</ul></li>
<li><a href="#types">5 Types</a></li>
<li><a href="#how-to-read-type-signatures">5.3 How to read type signatures</a><ul>
<li><a href="#exercises-type-matching">Exercises: Type Matching</a></li>
</ul></li>
<li><a href="#currying">5.4 Currying</a><ul>
<li><a href="#exercises-type-arguments">Exercises: Type Arguments</a></li>
</ul></li>
<li><a href="#polymorphism">5.5 Polymorphism</a></li>
<li><a href="#exercises-parametricity">Exercises: Parametricity</a></li>
<li><a href="#type-inference">5.6 Type Inference</a><ul>
<li><a href="#exercises-apply-yourself">Exercises: Apply Yourself</a></li>
</ul></li>
<li><a href="#chapter-exercises-3">5.8 Chapter Exercises</a><ul>
<li><a href="#multiple-choice">Multiple Choice</a></li>
<li><a href="#determine-the-type">Determine the type:</a></li>
<li><a href="#does-it-compile">Does it compile?:</a></li>
<li><a href="#type-variable-or-specific-type-constructor">Type variable or specific type constructor?</a></li>
<li><a href="#write-a-type-signature">Write a type signature:</a></li>
<li><a href="#given-a-type-write-the-function">Given a type, write the function:</a></li>
<li><a href="#fix-it">Fix it</a></li>
<li><a href="#type-kwon-do">Type-Kwon-Do</a></li>
</ul></li>
<li><a href="#follow-up-resources-2">5.10 Follow-up resources</a></li>
</ul></li>
<li><a href="#typeclasses">6 Typeclasses</a><ul>
<li><a href="#what-are-typeclasses">6.2 What are typeclasses?</a></li>
<li><a href="#exercises-eq-instances">Exercises: Eq Instances</a></li>
<li><a href="#exercises-tuple-experiment">Exercises: Tuple Experiment</a></li>
<li><a href="#exercises-will-they-work">Exercises: Will They Work?</a></li>
<li><a href="#chapter-exercises-4">Chapter Exercises</a><ul>
<li><a href="#multiple-choice-1">Multiple choice</a></li>
<li><a href="#does-it-typecheck">Does it typecheck?:</a></li>
<li><a href="#given-a-datatype-declaration-what-can-we-do">Given a datatype declaration, what can we do?</a></li>
<li><a href="#match-the-types">Match the types:</a></li>
<li><a href="#type-kwon-do-electric-typealoo">Type-Kwon-Do: Electric Typealoo</a></li>
</ul></li>
<li><a href="#follow-up-resources-3">6.17 Follow-up resources</a></li>
</ul></li>
<li><a href="#more-functional-patterns">7 More functional patterns</a><ul>
<li><a href="#arguments-and-parameters">7.2 Arguments and parameters</a></li>
<li><a href="#anonymous-functions">7.3 Anonymous functions</a><ul>
<li><a href="#exercises-grab-bag">Exercises: Grab bag</a></li>
</ul></li>
<li><a href="#pattern-matching">7.4 Pattern matching</a><ul>
<li><a href="#exercises-variety-pack">Exercises: Variety Pack</a></li>
</ul></li>
<li><a href="#case-expressions">7.5 Case expressions</a><ul>
<li><a href="#exercises-case-practice">Exercises: Case Practice</a></li>
</ul></li>
<li><a href="#higher-order-functions">7.6 Higher-order functions</a><ul>
<li><a href="#exercises-artful-dodgy">Exercises: Artful Dodgy</a></li>
</ul></li>
<li><a href="#guards">7.7 Guards</a><ul>
<li><a href="#exercises-guard-duty">Exercises: Guard Duty</a></li>
</ul></li>
<li><a href="#chapter-exercises-5">7.11 Chapter Exercises</a><ul>
<li><a href="#multiple-choice-2">Multiple Choice</a></li>
<li><a href="#lets-write-code">Let’s write code</a></li>
</ul></li>
<li><a href="#follow-up-resources-4">7.13 Follow-up resources</a></li>
</ul></li>
<li><a href="#recursion">8 Recursion</a><ul>
<li><a href="#factorial">8.2 Factorial</a></li>
<li><a href="#intermission-exercise">Intermission: Exercise</a></li>
<li><a href="#chapter-exercises-6">8.6 Chapter Exercises</a><ul>
<li><a href="#review-of-types">Review of types</a></li>
<li><a href="#reviewing-currying">Reviewing currying</a></li>
<li><a href="#recursion-1">Recursion</a></li>
<li><a href="#fixing-dividedby">Fixing dividedBy:</a></li>
<li><a href="#mccarthy-91-function">McCarthy 91 function:</a></li>
<li><a href="#numbers-into-words">Numbers into Words:</a></li>
</ul></li>
</ul></li>
<li><a href="#lists-1">9 Lists</a><ul>
<li><a href="#using-ranges-to-construct-lists">9.5 Using ranges to construct lists</a><ul>
<li><a href="#exercise-enumfromto">Exercise: EnumFromTo</a></li>
</ul></li>
<li><a href="#extracting-portions-of-lists">9.6 Extracting portions of lists</a><ul>
<li><a href="#exercises-thy-fearful-symmetry">Exercises: Thy Fearful Symmetry</a></li>
</ul></li>
<li><a href="#list-comprehensions">9.7 List Comprehensions</a><ul>
<li><a href="#exercises-comprehend-thy-lists">Exercises: Comprehend Thy Lists</a></li>
<li><a href="#exercises-square-cube">Exercises: Square Cube</a></li>
</ul></li>
<li><a href="#spines-and-nonstrict-evaluation">9.8 Spines and nonstrict evaluation</a><ul>
<li><a href="#exercises-bottom-madness">Exercises: Bottom Madness</a></li>
<li><a href="#intermission-is-it-in-normal-form">Intermission: Is it in normal form?</a></li>
</ul></li>
<li><a href="#transforming-lists">9.9 Transforming lists</a><ul>
<li><a href="#exercises-more-bottoms">Exercises: More Bottoms</a></li>
</ul></li>
<li><a href="#filtering-lists-of-values">9.10 Filtering lists of values</a><ul>
<li><a href="#exercises-filtering">Exercises: Filtering</a></li>
<li><a href="#zipping-exercises">Zipping exercises</a></li>
</ul></li>
<li><a href="#chapter-exercises-7">9.12 Chapter Exercises</a><ul>
<li><a href="#data.char">Data.Char</a></li>
<li><a href="#ciphers">Ciphers</a></li>
<li><a href="#writing-your-own-standard-functions">Writing your own standard functions</a></li>
</ul></li>
<li><a href="#follow-up-resources-5">9.14 Follow-up resources</a></li>
</ul></li>
<li><a href="#folding-lists">10 Folding lists</a><ul>
<li><a href="#fold-right">10.4 Fold right</a><ul>
<li><a href="#exercises-understanding-folds">Exercises: Understanding folds</a></li>
<li><a href="#exercises-database-processing">Exercises: Database Processing</a></li>
</ul></li>
<li><a href="#scans">10.9 Scans</a><ul>
<li><a href="#scans-exercises">Scans Exercises</a></li>
</ul></li>
<li><a href="#chapter-exercises-8">10.10 Chapter Exercises</a><ul>
<li><a href="#warm-up-and-reveiw">Warm-up and reveiw</a></li>
<li><a href="#rewriting-functions-using-folds">Rewriting functions using folds</a></li>
</ul></li>
<li><a href="#follow-up-resources-6">10.12 Follow-up resources</a></li>
</ul></li>
<li><a href="#algebraic-datatypes">11 Algebraic Datatypes</a><ul>
<li><a href="#data-constructors-and-values">11.5 Data constructors and values</a><ul>
<li><a href="#exercises-dog-types">Exercises: Dog Types</a></li>
</ul></li>
<li><a href="#whats-a-type-and-whats-data">11.6 What’s a type and what’s data?</a><ul>
<li><a href="#exercises-vehicles">Exercises: Vehicles</a></li>
</ul></li>
<li><a href="#what-makes-these-datatypes-algebraic">11.8 What makes these datatypes algebraic?</a><ul>
<li><a href="#exercises-cardinality">Exercises: Cardinality</a></li>
<li><a href="#exercises-for-example">Exercises: For Example</a></li>
</ul></li>
<li><a href="#newtype">11.9 newtype</a><ul>
<li><a href="#exercises-logic-goats">Exercises: Logic Goats</a></li>
</ul></li>
<li><a href="#sum-types">11.10 Sum types</a><ul>
<li><a href="#exercises-pity-the-bool">Exercises: Pity the Bool</a></li>
</ul></li>
<li><a href="#normal-form">11.12 Normal Form</a></li>
<li><a href="#exercises-how-does-your-garden-grow">Exercises: How Does Your Garden Grow?</a></li>
<li><a href="#constructing-and-deconstructing-values">11.13 Constructing and deconstructing values</a><ul>
<li><a href="#exercises-programmers">Exercises: Programmers</a></li>
</ul></li>
<li><a href="#function-type-is-exponential">11.14 Function type is exponential</a></li>
<li><a href="#exercises-the-quad">Exercises: The Quad</a></li>
<li><a href="#binary-tree">11.17 Binary Tree</a><ul>
<li><a href="#binarytree">BinaryTree</a></li>
</ul></li>
<li><a href="#chapter-exercises-9">11.18 Chapter Exercises</a><ul>
<li><a href="#multiple-choice-3">Multiple Choice</a></li>
<li><a href="#ciphers-1">Ciphers</a></li>
<li><a href="#as-patterns">As-patterns</a></li>
<li><a href="#language-exercises">Language exercises</a></li>
<li><a href="#phone-exercise">Phone exercise</a></li>
<li><a href="#huttons-razor">Hutton’s Razor</a></li>
</ul></li>
</ul></li>
<li><a href="#signaling-adversity">12 Signaling adversity</a><ul>
<li><a href="#chapter-exercises-10">12.5 Chapter Exercises</a><ul>
<li><a href="#determine-the-kinds">Determine the kinds</a></li>
<li><a href="#string-processing">String processing</a></li>
<li><a href="#validate-the-word">Validate the word</a></li>
<li><a href="#its-only-natural">It’s only Natural</a></li>
<li><a href="#small-library-for-maybe">Small library for Maybe</a></li>
<li><a href="#small-library-for-either">Small library for Either</a></li>
<li><a href="#write-your-own-iterate-and-unfoldr">Write your own iterate and unfoldr</a></li>
<li><a href="#finally-something-other-than-a-list">Finally something other than a list</a></li>
</ul></li>
</ul></li>
<li><a href="#building-projects">13 Building Projects</a><ul>
<li><a href="#more-on-importing-modules">13.6 More on importing modules</a></li>
<li><a href="#imtermission-check-your-understanding">Imtermission: Check your understanding</a></li>
<li><a href="#chapter-exercises-11">Chapter Exercises</a><ul>
<li><a href="#hangman-game-logic">Hangman game logic</a></li>
<li><a href="#modifying-code">Modifying code</a></li>
</ul></li>
<li><a href="#follow-up-resources-7">13.15 Follow-up resources</a></li>
</ul></li>
<li><a href="#testing">14 Testing</a><ul>
<li><a href="#intermission-short-exercise">Intermission: Short Exercise</a></li>
<li><a href="#chapter-exercises-12">14.7 Chapter Exercises</a><ul>
<li><a href="#validating-numbers-into-words">Validating numbers into words</a></li>
<li><a href="#using-quickcheck">Using QuickCheck</a></li>
<li><a href="#failure">Failure</a></li>
<li><a href="#idempotence">Idempotence</a></li>
<li><a href="#make-a-gen-random-generator-for-the-datatype">Make a Gen random generator for the datatype</a></li>
<li><a href="#hangman-testing">Hangman testing</a></li>
<li><a href="#validating-ciphers">Validating ciphers</a></li>
</ul></li>
<li><a href="#follow-up-resources-8">14.9 Follow-up resources</a></li>
</ul></li>
<li><a href="#monoid-semigroup">15 Monoid, Semigroup</a><ul>
<li><a href="#reusing-algebras-by-asking-for-algebras">15.10 Reusing algebras by asking for algebras</a><ul>
<li><a href="#exercise-optional-monoid">Exercise: Optional Monoid</a></li>
</ul></li>
<li><a href="#madness">15.11 Madness</a></li>
<li><a href="#better-living-through-quickcheck">15.12 Better living through QuickCheck</a><ul>
<li><a href="#testing-quickchecks-patience">Testing QuickCheck’s patience</a></li>
<li><a href="#exercise-maybe-another-monoid">Exercise: Maybe Another Monoid</a></li>
</ul></li>
<li><a href="#chapter-exercises-13">15.15 Chapter Exercises</a><ul>
<li><a href="#semigroup-exercises-monoid-exercises">Semigroup exercises &amp; Monoid exercises</a></li>
</ul></li>
<li><a href="#follow-up-resources-9">15.17 Follow-up resources</a></li>
</ul></li>
<li><a href="#functor">16 Functor</a><ul>
<li><a href="#lets-talk-about-4-baby">16.4 Let’s talk about 4, baby</a><ul>
<li><a href="#excercises-be-kind">Excercises: Be Kind</a></li>
</ul></li>
<li><a href="#commonly-used-functors">16.7 Commonly used functors</a><ul>
<li><a href="#exercises-heavy-lifting">Exercises: Heavy Lifting</a></li>
</ul></li>
<li><a href="#exercises-instances-of-func">16.10 Exercises: Instances of Func</a></li>
<li><a href="#ignoring-possibilities">16.11 Ignoring possibilities</a><ul>
<li><a href="#exercise-possibly">Exercise: Possibly</a></li>
<li><a href="#short-exercise">Short Exercise</a></li>
</ul></li>
<li><a href="#chapter-exercises-14">16.7 Chapter Exercises</a></li>
<li><a href="#follow-up-resources-10">16.19 Follow-up resources</a></li>
</ul></li>
<li><a href="#applicative">17 Applicative</a><ul>
<li><a href="#applicative-in-use">17.5 Applicative in use</a><ul>
<li><a href="#exercises-lookups">Exercises: Lookups</a></li>
</ul></li>
<li><a href="#exercises-identity-instance">Exercises: Identity Instance</a></li>
<li><a href="#exercise-fixer-upper">Exercise: Fixer Upper</a></li>
<li><a href="#list-applicative-exercise">List Applicative Exercise</a></li>
<li><a href="#ziplist-applicative-exercise">ZipList Applicative Exercise</a></li>
<li><a href="#exercise-variations-on-either">Exercise: Variations on Either</a></li>
<li><a href="#chapter-exercises-15">17.9 Chapter Exercises</a></li>
<li><a href="#follow-up-resources-11">17.11 Follow-up resources</a></li>
</ul></li>
<li><a href="#monad">18 Monad</a></li>
</ul>
<hr>
<p><strong>Work in progress</strong></p>
<h1 id="preliminaries">Preliminaries</h1>
<p>This page contains my notes and exercise solutions for the text “Haskell Programming From First Principles” by Chris Allen and Julie Moronuki.</p>
<p>Brief review: I love this book. I love Haskell. I worry this book has been so good at teaching me Haskell that I love other languages less by comparison. The book’s philosophy of “Let’s break complicated topics down into simple pieces, and then play with the pieces until they become obvious.” is so effective, that I’m going to just reflexively hold every other CS book to the same standard from now on. This is going to leave me very disappointed, considering that most other programming books don’t come anywhere near this fun.</p>
<p>Okay, maybe that’s a little hyperbolic. I don’t want to give the impression that HPFP is a text without flaws. In my notes on the rest of this page, I imagine I’ll be going into those flaws at some point. But before I do I want to make it perfectly clear that this book is spectacular and any criticism of mine is made with the greatest possible love and affection.</p>
<p>I deeply admire what Julie Moronuki and Chris Allen have accomplished here, and I encourage anyone interested in programming to buy a copy at <a href="www.haskellbook.com" class="uri">www.haskellbook.com</a>. I am also eagerly awaiting Julie’s upcoming book <a href="https://joyofhaskell.com/">The Joy of Haskell</a> and Chris’ <a href="https://lorepub.com/product/cookbook">Haskell Almanac</a>.</p>
<p>Before we get started, a little housekeeping: This page contains notes and solutions, but it is not a Haskell tutorial in its own right. My intended reader is someone who has already bought HPFP and maybe wants to check their own work against someone else’s.</p>
<p>Also, each chapter of HPFP has a list follow-up resources at the end. In my chapter notes, I’ll link to separate posts containing my notes on each of these resources.</p>
<p>Lastly, my GitHub repository containing my solutions for HPFP is <a href="https://github.com/johnchandlerburnham/haskellbook">here</a>. While this page is marked <strong>Work In Progress</strong>, I make no guarantees as to whether the code there matches the code here. But I do plan on bringing them into alignment ultimately.</p>
<p>Awesome, let’s get started.</p>
<hr />
<h1 id="all-you-need-is-lambda">1 All You Need is Lambda</h1>
<h2 id="what-is-a-function">1.3 What is a Function?</h2>
<p><strong>Function</strong>: A relation between an input set and output set such that each input has only one ouput. Personally, I think its more intuitive to imagine a function as a transformation that changes one type of thing (the input set) into another type of thing (the output set). I like to imagine a vegetable juicer: Put carrots in, get carrot juice out. Put spinach in, get spinach juice out. What is the <em>function</em> of a vegetable juicer? It transforms vegetables into vegetable juice. The set of things that can go into a vegetable juicer are its input set (or <em>domain</em>) and the set of things that can come out are its output set (or <em>codomain</em>).</p>
<p><strong>Computable functions</strong>: If a function is a transformation between two sets of things, and we can build machines which do transformations, then any function for which we can build a machine is called a <strong>computable</strong> function. Not all functions are computable.</p>
<p><strong>Turing Machines</strong>: A simple model of a computer based on manipulating symbols on a tape according to some rules and an internal state. Despite its simplicity, a Turing Machine can be built that executes any computable function.</p>
<p><strong>Lambda Calculus</strong>: A simple model of computation based on building, applying, and evaluating functions. A function built using the Lambda Calculus is called a lambda expression, and for any computable function, a lambda calculus can be constructed which evaluates that function.</p>
<p><strong>parameter</strong>: An input to a function.</p>
<p><strong>“functions are first-class”</strong>: Functions can be parameters.</p>
<p><strong>referential transparency</strong>: The property that the same function with the same parameters returns the same output. All functions are referentially transparent over all their parameters, but in some situations it can be difficult to tell what all a functions’ parameters are. Suppose you turn a dozen carrots into carrot juice with a vegetable juicer, don’t clean the juicer afterwards. You’ll drink your carrot juice, but the next person to use the juicer will have carrot flavored juice, even if they wanted celery and ginger. The juicer function has hidden paramters, i.e. the residue of previous inputs. Functions like this can be described as <em>stateful</em>, because they have some internal or hidden parameters whose state can affect the output of the whole function.</p>
<p><strong>purity</strong>: A synonym for referential transparency.</p>
<p><strong>Functional programming</strong>: Building machines (programs) that evaluate computable functions using the lambda calculus.</p>
<h2 id="the-structure-of-lambda-terms">1.4 The Structure of lambda terms</h2>
<p><strong>abstraction</strong>: A lamda expression that represents a function. It can be written down with the folowing notation: <span class="math inline">\(\lambda x.x\)</span>. Everything between the <span class="math inline">\(\lambda\)</span> and the <span class="math inline">\(.\)</span> is called the <strong>head</strong>, and the symbol in the head names the parameter of the function. After the <span class="math inline">\(.\)</span> is the <strong>body</strong>, and describes what to do with the parameter, when the abstraction is applied. Terms that occur in both the <strong>head</strong> and the <strong>body</strong> are called <em>bound variables</em>, and symbols that only appear in the body are called <em>unbound</em>, or <em>free variables</em>.</p>
<p><strong>currying</strong>: Properly speaking, all abstractions have only single parameters. Functions with multiple paramters are expressed as a nested strucure of single- parameter functions. For example <span class="math inline">\(\lambda xy.xy\)</span> is more properly written as <span class="math inline">\(\lambda x.(\lambda y.xy)\)</span>.</p>
<p><strong>application</strong>: A lambda expression can be applied to some input like so: <span class="math inline">\(((\lambda x.x) N)\)</span>. Following the reductions steps will evaluate the function described by <span class="math inline">\(\lambda x.x\)</span> with input parameter N.</p>
<h2 id="beta-reduction">1.5 Beta reduction</h2>
<p><strong>alpha equivalence</strong>: Within an abstraction, the specific symbols in the head may be replaced by other symbols as long as the replacement is consistent and total. For example, in the abstraction <span class="math inline">\(\lambda x.x\)</span> the term <span class="math inline">\(x\)</span> in the head may be replaced with <span class="math inline">\(y\)</span>, so long as all instance of <span class="math inline">\(x\)</span> in the body are also replaced with <span class="math inline">\(y\)</span>. Thus, <span class="math inline">\(\lambda x.x\)</span>, <span class="math inline">\(\lambda y.y\)</span>, and any other expression of the form <span class="math inline">\(\lambda n.n\)</span> (for some <span class="math inline">\(n\)</span>) are alpha equivalent.</p>
<p><strong>beta reduction</strong>: An abstraction is evaluated by replacing all its bound variables with the expression the abstraction is evaluated against (its input), and then removing the head of the abstraction. For example, <span class="math inline">\(((\lambda x.x) N)\)</span> would be evaluated by replacing all <span class="math inline">\(x\)</span>’s in the body with <span class="math inline">\(N\)</span> (yielding <span class="math inline">\(\lambda x.N\)</span>) and then removing the head for the final output of <span class="math inline">\(N\)</span>.</p>
<h3 id="intermission-equivalence-exercises-p.13">Intermission: Equivalence Exercises (p.13)</h3>
<ol style="list-style-type: decimal">
<li><code>\xy.xz</code> is equivalent to <code>\mn.mz</code>, by alpha equivalence of <code>x</code> with <code>m</code> and <code>y</code> with <code>n</code>.</li>
<li><code>\xy.xxy</code> is equivalent to <code>\a.(\b.aab)</code>, by currying and alpha equivalence.</li>
<li><code>\xyz.zx</code> is equivalent to <code>\tos.st</code>.</li>
</ol>
<h2 id="evaluation-is-simplification">1.7 Evaluation is simplification</h2>
<p><strong>beta normal form</strong>: When an expression cannot be further reduced through <em>beta reduction</em> (i.e. application of abstractions). This signals the end of the evaluation.</p>
<p><strong>combinator</strong>: A lambda term with no free variables. <span class="math inline">\(\lambda x.x\)</span> is a combinator, <span class="math inline">\(\lambda x.xy\)</span> is not.</p>
<p><strong>divergence</strong>: If an expression can never reach <em>beta normal form</em>, it is said to diverge. For example, <span class="math inline">\((\lambda x.xx)(\lambda x.xx)\)</span> diverges. This corresponds to non-terminating function (an infinite loop).</p>
<h2 id="chapter-exercises-p.17">1.11 Chapter Exercises (p.17)</h2>
<h3 id="combinators">Combinators</h3>
<ol style="list-style-type: decimal">
<li><code>\x.xxx</code> is a combinator.</li>
<li><code>\xy.zx</code> is not a combinator, <code>z</code> is free.</li>
<li><code>\xyz.xy(zx)</code> is a combinator.</li>
<li><code>\xyz.xy(zxy)</code> is a combinator</li>
<li><code>\xy.xy(zxy)</code> is not a combinator, <code>z</code> is free</li>
</ol>
<h3 id="normal-form-or-diverge">Normal form or diverge?</h3>
<ol style="list-style-type: decimal">
<li><code>\x.xxx</code> is Normal</li>
<li><code>(\z.zz)(\y.yy)</code> diverges</li>
<li><code>(\x.xxx)z</code> is Normal</li>
</ol>
<h3 id="beta-reduce">Beta Reduce</h3>
<ol style="list-style-type: decimal">
<li><p><code>(\abc.cba)zz(\wv.w)</code> reduction:</p>
<pre><code>(\abc.cba)zz(\wv.w) -&gt;
(\bc.cbz)z(\wv.w) -&gt;
(\c.czz)(\wv.w) -&gt;
(\wv.w)zz -&gt;
(\v.z)z -&gt;
z</code></pre></li>
<li><p><code>(\x.\y.xyy)(\a.a)b</code> reduction:</p>
<pre><code>(\x.\y.xyy)(\a.a)b -&gt;
(\y.(\a.a)yy)b -&gt;
(\a.a)bb -&gt;
bb</code></pre></li>
<li><p><code>(\y.y)(\x.xx)(\z.zq)</code> reduction:</p>
<pre><code>(\y.y)(\x.xx)(\z.zq) -&gt;
(\x.xx)(\z.zq) -&gt;
(\z.zq)(\z.zq) -&gt;
(\z.zq)q -&gt;
(\z.zq)q -&gt;
qq</code></pre></li>
<li><p><code>(\z.z)(\z.zz)(\z.zy)</code> reduction:</p>
<pre><code>(\z.z)(\z.zz)(\z.zy) -&gt;
(\z.zz)(\z.zy) -&gt;
(\z.zy)(\z.zy) -&gt;
(\z.zy)y -&gt;
yy</code></pre></li>
<li><p><code>(\x.\y.xyy)(\y.y)y</code> reduction:</p>
<pre><code>(\x.\y.xyy)(\y.y)y -&gt;
(\y.(\y.y)yy)y
(\y.y)yy
yy</code></pre></li>
<li><p><code>(\a.aa)(\b.ba)c</code> reduction:</p>
<pre><code>(\a.aa)(\b.ba)c -&gt;
(\b.ba)(\b.ba)c -&gt;
(\b.ba)ac -&gt;
aac</code></pre></li>
<li><p><code>(\xyz.xz(yz))(\x.z)(\x.a)</code> reduction:</p>
<pre><code>(\xyz.xz(yz))(\x.z)(\x.a) -&gt;
(\z.(\x.z1)z((\x.a)z))
(\z.z1a)</code></pre></li>
</ol>
<h2 id="follow-up-resources">1.14 Follow-up Resources</h2>
<ol style="list-style-type: decimal">
<li><p><a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">Raul Rojas. A Tutorial Introduction to the Lambda Calculus</a></p>
<p>My notes: <a href="posts/workthrough-lambda-calculus-rojas.html">Workthrough: A Tutorial Introduction to the Lambda Calculus (Rojas)</a></p></li>
<li><p><a href="http://www.cse.chalmers.se/research/group/logic/TypesSS05/%20Extra/geuvers.pdf">Henk Barendregt; Erik Barendsen. Introduction to Lambda Calculus</a></p>
<p>[TODO: Notes on this Resource]</p></li>
<li><p><a href="http://www.paultaylor.eu/stable/prot.pdf">Jean-Yves Girard; P. Taylor; Yves Lafon. Proofs and Types</a></p>
<p>[TODO: Notes on this Resource]</p></li>
</ol>
<hr />
<h1 id="hello-haskell">2 Hello Haskell!</h1>
<h2 id="hello-haskell-1">2.1 Hello, Haskell</h2>
<p><strong>GHC</strong>: The Glagow Haskell Compiler is a program (written in Haskell and C) turns Haskell code into x86 or ARM executables. There are <a href="https://wiki.haskell.org/Implementations">many other Haskell compilers</a>, but GHC is the de facto standard. Some Haskell compilers, such as Hugs, UHC and Yhc are no longer actively developed, but are notable for historic reasons, others, such as ghcjs and Frege (technically a separate dialect) are also important, since they target different platforms than GHC (Javascript and the JVM, respectively).</p>
<p><strong>GHCi</strong>: GHC’s interactive mode, or <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>. A REPL, or read-eval-print-loop, reads code that you type into a command line shell, evaluates it, prints the results, and then loops so you can type in more code.</p>
<p><strong>Cabal</strong>: Haskell’s Common Architecture for Building Applications and Libraries. When we write software, we often want to include external libraries, Cabal is a tool that enables us to easily include those libraries in our own software, as well as to publish libraries that can be used by others.</p>
<p><strong>Hackage</strong>: A central package archive which contains most of the Haskell libraries you’re ever going to want to use. Cabal installs packages from Hackage by default.</p>
<p><strong>Cabal hell</strong>: When we install external libraries using cabal, those libraries are installed globally on our machine by default. This means that if we want to build two different projects that depend upon the same external library, the naive way to do so is to install that library on our machine with cabal and then include it in our projects. This seems innocuous, but is actually very bad, because it creates a hidden interdependence between our two projects.</p>
<p>Suppose the library author added some new features in the library that we want to use in one of our projects. It seems obvious that we could just update the library and modify our project to use the new features, right? Except if we do that, we might break every other project on our machine that depends on that library, if the updated version wasn’t backwards compatible. And if the project that we’re currently working on itself depends on one of the other now-broken projects, we have to dive into a tangled web of hidden interdependencies to get anything working. This pattern, is called <strong>dependency hell</strong>, in general and is certainly not unique to cabal. There are a number of different ways to manage this problem, but the general approach is to use some other tool that allows you to install multiple copies of the same library on a per project basis so that changes in one project don’t propagate to other projects. Cabal itself provides a mechanism for doing this which allows you to install packages into self-contained “sandboxes,” but there are other tools, such as Stack (see below), which is what HPFP uses.</p>
<p>One extremely interesting way to solve the problem of dependency management that I should note is to use a system package manager like Nix or Guix that supports this type of package sandboxing and referentially transparent builds for anything you install on your machine, not just Haskell packages (which is all Cabal or Stack deals with). And you can even extend this to running an entire OS, like NixOs or GuixSD that manages the whole OS this way. That is, you can install the Nix package manager on e.g. macOS, but macOS packages or applications won’t be self-contained. In NixOs however, everything, including OS libraries have isolated dependencies, which makes it radically more difficult to break things when you, for example, update your operating system.</p>
<p><strong>Stack</strong>: A tool for building Haskell projects and manage dependencies. I like to think of Stack as a really nice user interface over a lot of common Haskell development functionality like installing packages with cabal, or managing different versions of GHC. Stack also installs packages from Stackage which is a mirror of Hackage that makes some guarantees about packages being compatible. Libraries on Hackage are more like nightly or unstable builds, up to date, but possibly brittle. Libraries on Stackage are farther behind, but stable.</p>
<p><strong>Installating Stack</strong>:</p>
<p>I started the book with <a href="archlinux.org">Arch Linux</a> as my operating system, but I switched to <a href="nixos.org">NixOS</a> part of the way through. Setting up Stack on Arch was really easy, but maintaining it proved fairly nontrivial. Apparently, just naively updating GHC and Stack with pacman (Arch’s package manager) can result in some epic dependency hell.</p>
<p>When I investigated, I found a post somewhere (which I can’t seem to find now) that proposed the following:</p>
<ol style="list-style-type: decimal">
<li>Install stack with pacman</li>
<li>Install stack again with stack.</li>
<li>Remove the system package of stack with pacman.</li>
<li>Use the stack that stack installed</li>
</ol>
<p>This was too silly for me to even try, but the fact that it seemed almost plausible told me that I should probably do my Haskell work on a different OS. So I added a NixOS partition on my machine on the theory that it’s better to have a system that’s difficult to learn and easy to debug than the other way round.</p>
<p>Accordingly, installing Stack on NixOs in a way that things seem to mostly behave was non-trivial. But it’s been pretty smooth sailing ever since (knock on wood). Here’s a rough outline of what I did:</p>
<p>[N.B. As I learn NixOS and Haskell better, I’ll edit this and add better instructions]</p>
<ol style="list-style-type: decimal">
<li>Installed Stack by adding stack to my system packages in my configuration.nix</li>
<li><p>Enabled Stack’s Nix integration by adding</p>
<pre><code>nix: 
  enable: true
  shell-file: shell.nix</code></pre>
to the stack.yaml of any project I’m using stack with.</li>
<li><p>Add the following shell.nix file to my project’s root directory</p>
<pre><code># shell.nix 

{ghc}:
with (import &lt;nixpkgs&gt; {}); 

haskell.lib.buildStackProject {
  inherit ghc;
  name = &quot;myEnv&quot;;
  buildInputs = [ zlib ];
  buildPhase = ''
    export LANG=en_US.UTF-8
  '';
}</code></pre></li>
</ol>
<p>There may be some other minor steps that I’ve missed, but these are the main ones I remember. This is a pretty boilerplatey solution, but considering this book really depends on Stack I thought it better to stick to the text rather going the <a href="https://github.com/NixOS/cabal2nix">cabal2nix</a> route and having a more idiosyncratic build process.</p>
<h2 id="understanding-expressions">2.5 Understanding expressions</h2>
<p>There’s a lot of inferential distance between the previous chapter and this one. I think it’s important to point out that even though Haskell is based on the lambda calculus, they are by no means the same thing. Lambda Calculus is the theoretical foundation of a lot of languages, Haskell being only one of them. But even if the foundations are the same, the structure of the languages might be very different, based on the decisions of its designers. Start with Lambda Calculus, build one kind of structure, and you get Haskell, but start over and build a different kind of structure and you get Lisp.</p>
<p>The book skips over a lot of those design decisions and rightly so. Better to get started playing with the language as soon as possible. But you should at least be aware that there is some hidden complexity here. And if you find yourself stuck on some concept, it’s probably because some implicit detail, which the author knows but you don’t, is blocking you.</p>
<p>This happens to everyone. Just remember that every big complicated concept in computer science is made up of little obvious steps. Computers can only do little obvious steps, but they do very many of them very very fast. Whenever you’re stuck, go back to the last step that was obvious to you, and try to figure out what the next obvious step is.</p>
<p>In this case, I highly recommend the follow-up resources in the previous chapter, which are a great place to start at trying to close the complexity gap between Haskell and the lambda calculus.</p>
<h3 id="exercises-comprehension-check">Exercises: Comprehension Check</h3>
<ol style="list-style-type: decimal">
<li><p><code>let half x = x /2</code> <code>let square x = x * x</code></p></li>
<li><code>let area x = 3.14 * (square x)</code></li>
<li><p><code>let area x = pi * (square x)</code></p></li>
</ol>
<h2 id="infix-operators">2.6 Infix Operators</h2>
<p>It may be helpful to point out that all infix operators are just syntacic sugar over functions.</p>
<p><strong>syntacitc sugar</strong>: Syntax within a programming language that is designed to make things easier to read or to express. It makes the language “sweeter” for human use: things can be expressed more clearly, more concisely, or in an alternative style that some may prefer. (from <a href="https://en.wikipedia.org/wiki/Syntactic_sugar">Wikipedia</a>)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> add <span class="fu">=</span> (<span class="fu">+</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> add <span class="dv">2</span> <span class="dv">2</span> 
<span class="dv">4</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> </code></pre></div>
<h3 id="exercises-parentheses-and-association">Exercises: Parentheses and Association</h3>
<p><strong>Precedence</strong>: Where the implicit parentheses are. Precedence of operators is only relevant if you leave out parentheses. If you can explicitly mark what operations you want evaluated in what order, precedence doesn’t matter. Or, in other words, parentheses have the highest precedence, just like in grade school (the P in PEMDAS stands for parentheses).</p>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><code>8 + 7 * 9</code></li>
<li><code>(8 + 7) * 9</code></li>
</ol>
<p>a and b are different, <code>(*)</code> has a higher precedence than <code>(+)</code></p></li>
<li><ol style="list-style-type: lower-alpha">
<li><code>perimeter x y = (x * 2) + (y * 2)</code></li>
<li><code>perimeter x y = x * 2 + y * 2</code></li>
</ol>
<p>a and b are the same, <code>(*)</code> has a higher precedence than <code>(+)</code></p></li>
<li><ol style="list-style-type: lower-alpha">
<li><code>f x = x / 2 + 9</code></li>
<li><code>f x = x / (2 + 9)</code></li>
</ol>
<p>a and b are different <code>(/)</code> has a higher precedence than <code>(+)</code></p></li>
</ol>
<h2 id="declaring-values">2.7 Declaring values</h2>
<p>Look at the following sequence of expressions in GHCi:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">3</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> y <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> y
<span class="dv">4</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">7</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> x
<span class="dv">7</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> y
<span class="dv">4</span></code></pre></div>
<p>You may have been expecting that last <code>y</code> to be <code>8</code> instead of <code>4</code>, which is how it would work in an imperative language like C or Python.</p>
<p>What’s curious about Haskell though is why the above sequence works at all. Look what happens if we try to replicate similar looking expressions in a source file:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--- SevenIsNotThree.hs</span>

<span class="kw">module</span> <span class="dt">SevenIsNotThree</span> <span class="kw">where</span>
                                                                                
x <span class="fu">=</span> <span class="dv">3</span>                                                                           
y <span class="fu">=</span> x <span class="fu">+</span> <span class="dv">1</span>                                                                       
x <span class="fu">=</span> <span class="dv">7</span>    </code></pre></div>
<p>If you try loading this into GHCi:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>l SevenIsNotThree.hs 
[<span class="dv">1</span> <span class="kw">of</span> <span class="dv">1</span>] <span class="dt">Compiling</span> <span class="dt">SevenIsNotThree</span>  ( SevenIsNotThree.hs, interpreted )

SevenIsNotThree.hs<span class="fu">:</span><span class="dv">7</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span>
    <span class="dt">Multiple</span> declarations <span class="kw">of</span> ‘x’
    <span class="dt">Declared</span> at<span class="fu">:</span> SevenIsNotThree.hs<span class="fu">:</span><span class="dv">5</span><span class="fu">:</span><span class="dv">1</span>
                 SevenIsNotThree.hs<span class="fu">:</span><span class="dv">7</span><span class="fu">:</span><span class="dv">1</span>
<span class="dt">Failed</span>, modules loaded<span class="fu">:</span> none<span class="fu">.</span></code></pre></div>
<p>Haskell’s error messages take a little getting used to, so I’ll translate:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Dear</span> <span class="dt">Sir</span> or <span class="dt">Madam</span>,

<span class="dt">While</span> the <span class="dt">Prelude</span> <span class="kw">module</span> was loaded, you, the <span class="dt">Programmer</span>, instructed
us to load the <span class="kw">module</span> found <span class="kw">in</span> the file SevenIsNotThree.hs<span class="fu">.</span>

<span class="dt">We</span> located the aforementioned file, SevenIsNotThree.hs and attempted to load
the <span class="kw">module</span> <span class="dt">SevenIsNotThree</span> we found therein<span class="fu">.</span>

<span class="dt">At</span> line <span class="dv">7</span>, column <span class="dv">1</span>, <span class="kw">in</span> file SevenIsNotThree.hs, we encountered an error<span class="fu">:</span>
  <span class="dt">You</span> tried to declare the expression <span class="ch">'x'</span> mulitple times<span class="fu">.</span>
  <span class="dt">You</span> declared <span class="ch">'x'</span> at  line <span class="dv">5</span>, column <span class="dv">1</span> <span class="kw">of</span> file SevenIsNotThree.hs
  <span class="dt">You</span> declared <span class="ch">'x'</span> at  line <span class="dv">7</span>, column <span class="dv">1</span> <span class="kw">of</span> file SevenIsNotThree.hs

<span class="dt">Declaring</span> an expression multiple times is forbidden<span class="fu">.</span> 
  <span class="dt">Either</span> the declarations are the same
    and thus redundant,
  <span class="dt">Or</span> the declarations are different
    and thus contradictory<span class="fu">.</span>

<span class="dt">We</span> have no desire to load redundant and contradictory code<span class="fu">.</span> <span class="dt">Therefore</span>, your
request is denied and no modules were loaded<span class="fu">.</span>

<span class="dt">Sincerely</span>,
<span class="dt">The</span> <span class="dt">Glorious</span> <span class="dt">Glasgow</span> <span class="dt">Haskell</span> <span class="dt">Compiler</span> (interactive mode)<span class="fu">.</span></code></pre></div>
<p>Don’t worry, GHC isn’t scolding you (much). You shouldn’t want to run redundant or contradictory code either. Much better to find out that your code is broken in a message from the compiler than, for example, when your Mars Lander crashes into the surface because your code had a type error and mixed up feet and meters (this actually <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure">happened</a>).</p>
<p>As for why GHC is perfectly happy to accept contradictory declarations in GHCi let expressions but not in a source file, this is because everything in GHCi happens inside the <code>IO ()</code> type (IO meaning input/output). <code>IO</code> let expressions have different scope than declarations in a source file.</p>
<p>This seems mysterious, but will make sense in later chapters.</p>
<h3 id="exercises-heal-the-sick">Exercises: Heal the Sick</h3>
<ol style="list-style-type: decimal">
<li><code>let area x = 3.14 * (x * x)</code></li>
<li><p><code>let double x = x * 2</code></p></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Levels.hs</span>
<span class="kw">module</span> <span class="dt">Levels</span> <span class="kw">where</span>

x <span class="fu">=</span> <span class="dv">7</span>
y <span class="fu">=</span> <span class="dv">10</span>
f <span class="fu">=</span> x <span class="fu">+</span> y</code></pre></div></li>
</ol>
<h2 id="arithmetic-functions-in-haskell">2.8 Arithmetic functions in Haskell</h2>
<p>Oh, gosh. Modular arithmetic.</p>
<p>My recommendation is to read the chapter and read this Wikipedia page on the <a href="https://en.wikipedia.org/wiki/Modulo_operation">Modulo operation</a>. You’ll see there that pretty much every programming language has its own idiosyncratic way of doing the modulo operation, and there isn’t a lot of consistency between them.</p>
<p>By the way, <code>divMod</code> and <code>quotRem</code> are two useful functions which return pairs of <code>div</code> and <code>mod</code>, and <code>quot</code> and <code>rem</code>, respectively, applied to the same arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">divMod x y <span class="fu">=</span> (div x y, mod x y)
quotRem x y <span class="fu">=</span> (quot x y, rem x y)</code></pre></div>
<p>In my opinion I wouldn’t stress too much about all the detail here. In practice, <code>div</code> and <code>mod</code> are almost always what you need, and that the distinction between <code>divMod</code> and <code>quotRem</code> only appears when you’re dealing with negative integers. Really the difference is just what “round down” means.</p>
<p>Let’s look at a few examples of how <code>divMod</code> and <code>quotRem</code> differ:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> divMod <span class="dv">13</span> <span class="dv">4</span>
(<span class="dv">3</span>,<span class="dv">1</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> quotRem <span class="dv">13</span> <span class="dv">4</span>
(<span class="dv">3</span>,<span class="dv">1</span>)</code></pre></div>
<p>Both arguments are positive, so there is no difference. <code>13</code> divided by <code>4</code> the ordinary way is three and a fourth, <code>3.25</code>. But since this is integer division we round down to <code>3</code>. Since <code>3 * 4</code> is <code>12</code> the remainder is one (<code>13 - 12 = 1</code>).</p>
<p>But what if we do <code>(-13)</code> divided by <code>4</code>. If we were doing ordinary division we would get negative <code>(-3.25)</code>.</p>
<p>Now this is the question: What does it mean to “round down” <code>(-3.25)</code>?</p>
<p>The two possible options are <code>(-3)</code> and <code>(-4)</code>.</p>
<p>If we say that <code>(-3.25)</code> rounded down is <code>(-3)</code>, then we run into the difficulty that <code>(-3)</code> is actually greater than <code>(-3.25)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> (<span class="fu">-</span><span class="dv">3</span>) <span class="fu">&gt;</span> (<span class="fu">-</span><span class="fl">3.25</span>)
<span class="dt">True</span></code></pre></div>
<p>On the other hand, if we say that <code>(-3.25)</code> rounded down is <code>(-4)</code> then it’s the absolute value which is greater:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> abs (<span class="fu">-</span><span class="dv">4</span>) <span class="fu">&gt;</span> abs (<span class="fu">-</span><span class="fl">3.25</span>)
<span class="dt">True</span></code></pre></div>
<p>So we have a choice to make. We want integer division to “round down”, but when one of the arguments is negative, “down” can mean two different things. We have to decide if we want “down” to be toward <code>0</code>, in which case we’ll choose <code>(-3)</code> in the above example, or towards <span class="math inline">\(-\infty\)</span>, negative infinity, in which case we choose <code>(-4)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> divMod (<span class="fu">-</span><span class="dv">13</span>) <span class="dv">4</span>
(<span class="fu">-</span><span class="dv">4</span>,<span class="dv">3</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> quotRem (<span class="fu">-</span><span class="dv">13</span>) <span class="dv">4</span>
(<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p>As we can see, <code>divMod</code> sets down as <span class="math inline">\(-\infty\)</span> and <code>quotRem</code> sets down as <code>0</code>.</p>
<p>The values for <code>mod</code> and <code>rem</code>, are just consequences of that choice, since:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mod (<span class="fu">-</span><span class="dv">13</span>) <span class="dv">4</span> <span class="fu">=</span> (<span class="fu">-</span><span class="dv">13</span>) <span class="fu">-</span> <span class="dv">4</span> <span class="fu">*</span> (div <span class="dv">13</span> <span class="dv">4</span>) <span class="fu">=</span> (<span class="fu">-</span><span class="dv">13</span>) <span class="fu">-</span> <span class="dv">4</span> <span class="fu">*</span> (<span class="fu">-</span><span class="dv">4</span>) <span class="fu">=</span>
<span class="fu">-</span><span class="dv">13</span> <span class="fu">+</span> <span class="dv">16</span> <span class="fu">=</span> <span class="dv">3</span>

rem (<span class="fu">-</span><span class="dv">13</span>) <span class="dv">4</span> <span class="fu">=</span> (<span class="fu">-</span><span class="dv">13</span>) <span class="fu">-</span> <span class="dv">4</span> <span class="fu">*</span> (quot <span class="dv">13</span> <span class="dv">4</span>) <span class="fu">=</span> (<span class="fu">-</span><span class="dv">13</span>) <span class="fu">-</span> <span class="dv">4</span> <span class="fu">*</span> (<span class="fu">-</span><span class="dv">3</span>) <span class="fu">=</span>
<span class="fu">-</span><span class="dv">13</span> <span class="fu">+</span> <span class="dv">12</span> <span class="fu">=</span> <span class="fu">-</span><span class="dv">1</span></code></pre></div>
<p>Everything is just a consequence of what we want “down” to mean.</p>
<p>If we flip the signs of the arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> divMod <span class="dv">13</span> (<span class="fu">-</span><span class="dv">4</span>)
(<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">3</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> quotRem <span class="dv">13</span> (<span class="fu">-</span><span class="dv">4</span>)
(<span class="fu">-</span><span class="dv">3</span>,<span class="dv">1</span>)</code></pre></div>
<p><code>div</code> and <code>quot</code> are the same, because <code>13</code> divided by <code>(-4)</code> is still <code>(-3.25)</code> and the decision about “down” is the same.</p>
<p><code>mod</code> and <code>rem</code> are different though, because:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">mod <span class="dv">13</span> (<span class="fu">-</span><span class="dv">4</span>) <span class="fu">=</span> <span class="dv">13</span> <span class="fu">-</span> (<span class="fu">-</span><span class="dv">4</span>) <span class="fu">*</span> (div <span class="dv">13</span> <span class="dv">4</span>) <span class="fu">=</span> <span class="dv">13</span> <span class="fu">+</span> <span class="dv">4</span> <span class="fu">*</span> (<span class="fu">-</span><span class="dv">4</span>) <span class="fu">=</span>
<span class="dv">13</span> <span class="fu">-</span> <span class="dv">16</span> <span class="fu">=</span> <span class="fu">-</span><span class="dv">3</span>

rem <span class="dv">13</span> (<span class="fu">-</span><span class="dv">4</span>) <span class="fu">=</span> <span class="dv">13</span> <span class="fu">-</span> (<span class="fu">-</span><span class="dv">4</span>) <span class="fu">*</span> (quot <span class="dv">13</span> <span class="dv">4</span>) <span class="fu">=</span> <span class="dv">13</span> <span class="fu">+</span> <span class="dv">4</span> <span class="fu">*</span> (<span class="fu">-</span><span class="dv">3</span>) <span class="fu">=</span>
<span class="dv">13</span> <span class="fu">-</span> <span class="dv">12</span> <span class="fu">=</span> <span class="dv">1</span></code></pre></div>
<p>Lastly, if we set the signs of both arguments negative:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">`(-13)`</span> <span class="fu">/</span> <span class="ot">`(-4)`</span> <span class="fu">=</span> <span class="dv">13</span> <span class="fu">/</span> <span class="dv">4</span> <span class="fu">=</span> <span class="fl">3.25</span></code></pre></div>
<p>and we’re back to “down” being unambiguous, so <code>divMod</code> and <code>quotRem</code> are the same again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> divMod (<span class="fu">-</span><span class="dv">13</span>) (<span class="fu">-</span><span class="dv">4</span>)
(<span class="dv">3</span>,<span class="fu">-</span><span class="dv">1</span>)
<span class="dt">Prelude</span><span class="fu">&gt;</span> quotRem (<span class="fu">-</span><span class="dv">13</span>) (<span class="fu">-</span><span class="dv">4</span>)
(<span class="dv">3</span>,<span class="fu">-</span><span class="dv">1</span>)</code></pre></div>
<p>But really. Just use <code>divMod</code>. You almost always want “down” to be towards negative infinity.</p>
<p>I would almost rather manually recreate <code>quot</code> out of <code>div</code> wherever I needed it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">quot x y <span class="fu">=</span> (sign x) <span class="fu">*</span> (sign y) <span class="fu">*</span> (div (abs x) (abs y)) <span class="kw">where</span>
  sign x <span class="fu">=</span> div (abs x) x</code></pre></div>
<p>Just so that it’s perfectly clear that I’m really interested in rounding absolute values.</p>
<h2 id="parenthesization">2.9 Parenthesization</h2>
<p><code>$</code>, or “apply”, is a great help in making Haskell code legible.</p>
<p>Look at the difference between</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">fun x <span class="fu">=</span> (foo (bar (baz x)))

fun' x <span class="fu">=</span> foo <span class="fu">$</span> bar <span class="fu">$</span> baz x</code></pre></div>
<p>I think the latter is a lot nicer. But the difference gets even starker when you have a more complicated syntax structure:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lessFun x <span class="fu">=</span> (qux (baz (bar x)) (foo (bar x)) (baz (quux (foo (bar x)) (foo x))))</code></pre></div>
<p>My eyes glaze over after the first bar.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">moreFun x <span class="fu">=</span> qux (baz <span class="fu">$</span> bar x) (foo <span class="fu">$</span> bar x) (baz <span class="fu">$</span> quux (foo <span class="fu">$</span> bar x) (foo x))</code></pre></div>
<p>Now it’s a lot easier to tell that qux takes three arguments.</p>
<p>We could also do:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">moreFun x <span class="fu">=</span> qux (baz <span class="fu">$</span> bar x) (foo <span class="fu">$</span> bar x) <span class="fu">$</span> baz <span class="fu">$</span> quux (foo <span class="fu">$</span> bar x) <span class="fu">$</span> foo x</code></pre></div>
<p>But I think this is less clear. In general I like to use parentheses and <code>$</code> to better illuminate the structure of whatever the expression is, which depending, on the specific expression that might require slightly different styles. <code>let</code> and <code>where</code> expressions can also be a great help.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">moreFun' x <span class="fu">=</span> qux (baz <span class="fu">$</span> bar x) fbx (baz <span class="fu">$</span> quux fbx <span class="fu">$</span> foo x) <span class="kw">where</span>
  fbx <span class="fu">=</span> foo <span class="fu">$</span> bar x</code></pre></div>
<h3 id="exercises-a-head-code">Exercises: A Head Code</h3>
<ol style="list-style-type: decimal">
<li><p><code>let x = 5 in x</code></p>
<p>returns 5</p></li>
<li><p><code>let x = 5 in x * x</code></p>
<p>returns 25</p></li>
<li><p><code>let x = 5; y = 6 in x * y</code></p>
<p>returns 30</p></li>
<li><p><code>let x = 3; y = 1000 in x + 3</code></p>
<p>returns 6</p></li>
</ol>
<p><strong>Rewrite with where clauses</strong>:</p>
<ol style="list-style-type: decimal">
<li><code>x * 3 + y where x = 3; y = 1000</code></li>
<li><code>x * 5 where y = 10; x = 10 * 5 + y</code></li>
<li><code>z / x + y where x = 7; y = negate x; z = y * 10</code></li>
</ol>
<h2 id="chapter-exercises">2.11 Chapter Exercises</h2>
<h3 id="parenthesization-1">Parenthesization</h3>
<ol style="list-style-type: decimal">
<li><code>2 + (2 * 3) - 1</code></li>
<li><code>(^) 10 $ (1 + 1)</code></li>
<li><code>(2^2) * (4^5) + 1</code></li>
</ol>
<h3 id="equivalent-expressions">Equivalent expressions</h3>
<ol style="list-style-type: decimal">
<li><p><code>1 + 1</code> returns the same as <code>2</code></p></li>
<li><p><code>10^2</code> returns the same as <code>10+9*10</code></p></li>
<li><p><code>400 - 37</code> is not the same as <code>(-) 37 400</code>, different argument order.</p></li>
<li><p><code>100 `div` 3</code> is not the same as <code>100 / 3</code>, former is integer division vs fractional division for the latter.</p></li>
<li><p><code>2 * 5 + 18</code> is not the same as <code>2 * (5 + 18)</code>, operator precedence</p></li>
</ol>
<h3 id="more-fun-with-functions">More fun with functions</h3>
<ol style="list-style-type: decimal">
<li><p><code>10 + waxOn</code> will return 1135</p>
<p><code>(+10) waxOn</code> will return 1135</p>
<p><code>(-) 15 waxOn</code> will return -1110</p>
<p><code>(-) waxOn 15</code> will return 1110</p></li>
<li><p>Nothing to do for this exercise</p></li>
<li><p>3375</p></li>
<li><p>see morefun.hs</p></li>
<li><p>see morefun.hs</p></li>
<li><p>see morefun.hs</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- morefun.hs</span>

waxOn <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">5</span> <span class="kw">where</span> x <span class="fu">=</span> y <span class="fu">^</span><span class="dv">2</span>; y <span class="fu">=</span> z <span class="fu">+</span> <span class="dv">8</span>; z <span class="fu">=</span> <span class="dv">7</span>
triple x <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">3</span>
waxOff x <span class="fu">=</span> triple x</code></pre></div></li>
<li><p><code>waxOff 10</code> returns <code>30</code></p>
<p><code>waxOff (-50)</code> returns <code>(-150)</code></p></li>
</ol>
<h2 id="follow-up-resources-1">2.13 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p><a href="https://wiki.haskell.org/Let_vs._Where">Haskell wiki article on Let vs Where</a></p>
<p>[TODO: Notes on this resource]</p></li>
<li><p><a href="https://github.com/johnchandlerburnham/hpffp-resources/blob/master/Chapter%202/How%20to%20desugar%20Haskell%20code.pdf">How to desugar Haskell code; Gabriel Gonzalez</a></p>
<p>[TODO: Notes on this resource]</p></li>
</ol>
<hr />
<h1 id="strings">3 Strings</h1>
<p><strong>string</strong>: a sequence of characters, usually representing text. The words you are reading now are strings.</p>
<p><strong>Haskell’s <code>String</code> type</strong>: A particular way of representing strings as lists of <code>Char</code> types. It is very important to notice that even though the name of this type is <code>String</code>, it is not the only, or even the best way to represent sequences of characters and text. (see <a href="https://hackage.haskell.org/package/text-1.2.2.2/docs/Data-Text.html">Data.Text</a> and <a href="https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html">Data.ByteString</a></p>
<p>The main advantage of <code>String</code> is that it is conceptually very simple: a <code>String</code> is a <code>List</code> of <code>Char</code>.</p>
<h3 id="lists">Lists</h3>
<p>A list (with a lowercase l) is some ordered collection of information. The order may not be important, but if there is no order, it’s not a list, it’s a set (“unordered list” is a bit of a misnomer).</p>
<p>Suppose you buy groceries for your family every week. You want to know what everyone else wants from the store without having to talk to them each individually, so you put a piece of paper on the fridge and tell everyone to write down what they want you to get. This is an everyday example of a list: A grocery list.</p>
<pre><code>Grocery List
------------
- Milk
- Eggs
- Flour
- Chicken Noodle Soup 
- Mushrooms
- Beef tenderloin
- Puff pastry</code></pre>
<p>A grocery list is an everyday example of a list. The order of your grocery list probably isn’t important but there definitely is an order: The groceries aren’t written randomly all over the page, but in parallel lines starting from the top of the page downward.</p>
<p>The order of the list could indicate the chronological order in which people added their requests. That’s probably not important information most of the time, but occasionally it might be.</p>
<p>In the above example, notice that the first item on the list is <code>Milk</code>. If the list is chronological, it means that <code>Milk</code> was the first thing added since you went to the store last week. If you know you bought a half-gallon of <code>Milk</code> last week, that probably means your family drank all the <code>Milk</code> right after you bought it. And that might make you decide to buy a whole gallon this time.</p>
<p>Another interesting thing you can see in the ordering of a grocery list is that items that are next to each other are likely to be connected to each other conceptually. The last three items: <code>mushrooms, Beef tenderloin, Puff pastry</code> are all ingredients for a Beef Wellington recipe. If the store happens to be all out of puff pastry, it might make sense to skip the mushrooms and the beef, since you can’t make the recipe.</p>
<p>Okay, so a grocery list has an ordering that’s sometimes relevant.</p>
<p>Here’s a slightly philosophical question: Was the grocery list a list before someone added the first item (<code>Milk</code>) to it?</p>
<p>In common language, we probaby wouldn’t call a blank piece of paper a list. But we could perhaps call a piece of paper with the title <code>Grocery List</code> at the top a “blank grocery list”, or an “empty grocery list”, although that might sound strange.</p>
<p>In Haskell-land (and CS-country in general), an empty list is definitely a list. <code>List</code> in Haskell is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>
<p><code>Nil</code> is the empty list. We build lists by connecting the items in the list to each other and ultimately to the empty list. So the above definition says roughly: “A list of <code>a</code> is either an empty list, or is the connection of an <code>a</code> to a <code>List</code> of <code>a</code>.</p>
<p>Since <code>a</code> is just a stand-in for some type of thing, a list of groceries in Haskell would be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> <span class="dt">Grocery</span> <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> <span class="dt">Grocery</span> (<span class="dt">List</span> <span class="dt">Grocery</span>)</code></pre></div>
<p>“A list of groceries is either an empty list, or is the connection of a grocery item to a list of groceries.”</p>
<p>If <code>Milk</code>, <code>Eggs</code> and <code>Flour</code> are all of the type <code>Grocery</code>, then we can make the following Grocery list:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">aGroceryList <span class="fu">=</span> <span class="dt">Cons</span> <span class="dt">Milk</span> (<span class="dt">Cons</span> <span class="dt">Eggs</span> (<span class="dt">Cons</span> <span class="dt">Flour</span> <span class="dt">Nil</span>))</code></pre></div>
<p>This looks a litlle complicated though, so in Haskell, <code>Cons</code> represented as the <code>:</code> operator and <code>Nil</code> is <code>[]</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">aNicerGroceryList <span class="fu">=</span> <span class="dt">Milk</span><span class="fu">:</span><span class="dt">Eggs</span><span class="fu">:</span><span class="dt">Flour</span><span class="fu">:</span>[]</code></pre></div>
<p>But the syntactic sugar goes even a step further.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">theNicestGroceryList <span class="fu">=</span> [<span class="dt">Milk</span>, <span class="dt">Eggs</span>, <span class="dt">Flour</span>]</code></pre></div>
<p>At the REPL:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Grocery</span> <span class="fu">=</span> <span class="dt">Milk</span> <span class="fu">|</span> <span class="dt">Eggs</span> <span class="fu">|</span> <span class="dt">Flour</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Milk</span><span class="fu">:</span><span class="dt">Eggs</span><span class="fu">:</span><span class="dt">Flour</span><span class="fu">:</span>[]
[<span class="dt">Milk</span>,<span class="dt">Eggs</span>,<span class="dt">Flour</span>]
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> [<span class="dt">Milk</span>,<span class="dt">Eggs</span>,<span class="dt">Flour</span>]
[<span class="dt">Milk</span>,<span class="dt">Eggs</span>,<span class="dt">Flour</span>]<span class="ot"> ::</span> [<span class="dt">Grocery</span>]</code></pre></div>
<p>That last line means that the type of <code>[Milk,Eggs,Flour]</code> is a <code>[Grocery]</code>, which means the same as <code>List Grocery</code>.</p>
<p><code>[]</code> is the list constructor in Haskell, which we can see at the REPL</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>info []
<span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a] 	<span class="co">-- Defined in ‘GHC.Types’</span></code></pre></div>
<p>There’s some overloading of <code>[]</code> here, since <code>[]</code> is representing both <code>List</code> and <code>Nil</code>, but in practice this is nice since you build a list of <code>a</code>, <code>[a]</code>, by consing <code>a</code> to <code>nil</code>, <code>a:[]</code>.</p>
<h3 id="char">Char</h3>
<p>A <code>Char</code> is an ASCII character (<a href="https://en.wikipedia.org/wiki/ASCII">American Standard Code for Information Interchange</a>).</p>
<p>[NB. <code>Char</code> actually represents Unicode characters in general, but I don’t want to bring in Unicode as a conceptual dependency here]</p>
<p>Ascii is a way to represent text characters as numbers. Here’s a table of all 128 ascii characters:</p>
<pre><code>Dec  Char                           Dec  Char     Dec  Char     Dec  Char
---------                           ---------     ---------     ----------
  0  NUL (null)                      32  SPACE     64  @         96  `
  1  SOH (start of heading)          33  !         65  A         97  a
  2  STX (start of text)             34  &quot;         66  B         98  b
  3  ETX (end of text)               35  #         67  C         99  c
  4  EOT (end of transmission)       36  $         68  D        100  d
  5  ENQ (enquiry)                   37  %         69  E        101  e
  6  ACK (acknowledge)               38  &amp;         70  F        102  f
  7  BEL (bell)                      39  '         71  G        103  g
  8  BS  (backspace)                 40  (         72  H        104  h
  9  TAB (horizontal tab)            41  )         73  I        105  i
 10  LF  (NL line feed, new line)    42  *         74  J        106  j
 11  VT  (vertical tab)              43  +         75  K        107  k
 12  FF  (NP form feed, new page)    44  ,         76  L        108  l
 13  CR  (carriage return)           45  -         77  M        109  m
 14  SO  (shift out)                 46  .         78  N        110  n
 15  SI  (shift in)                  47  /         79  O        111  o
 16  DLE (data link escape)          48  0         80  P        112  p
 17  DC1 (device control 1)          49  1         81  Q        113  q
 18  DC2 (device control 2)          50  2         82  R        114  r
 19  DC3 (device control 3)          51  3         83  S        115  s
 20  DC4 (device control 4)          52  4         84  T        116  t
 21  NAK (negative acknowledge)      53  5         85  U        117  u
 22  SYN (synchronous idle)          54  6         86  V        118  v
 23  ETB (end of trans. block)       55  7         87  W        119  w
 24  CAN (cancel)                    56  8         88  X        120  x
 25  EM  (end of medium)             57  9         89  Y        121  y
 26  SUB (substitute)                58  :         90  Z        122  z
 27  ESC (escape)                    59  ;         91  [        123  {
 28  FS  (file separator)            60  &lt;         92  \        124  |
 29  GS  (group separator)           61  =         93  ]        125  }
 30  RS  (record separator)          62  &gt;         94  ^        126  ~
 31  US  (unit separator)            63  ?         95  _        127  DEL</code></pre>
<p>Most of the first 32 are control characters intended for use by teletype machines and magnetic tape readers, so you don’t have to worry about them. A few are still used though, <code>\n</code> in Haskell means newline and is the same as Ascii 10 <code>\LF</code>.</p>
<p>We can see the correspondence at the REPL:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">import </span><span class="dt">Data.Char</span>
<span class="dt">Prelude</span> <span class="dt">Data.Char</span><span class="fu">&gt;</span> ord <span class="ch">'a'</span>
<span class="dv">97</span>
<span class="dt">Prelude</span> <span class="dt">Data.Char</span><span class="fu">&gt;</span> chr <span class="dv">97</span>
<span class="ch">'a'</span>
<span class="dt">Prelude</span> <span class="dt">Data.Char</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> ord
ord<span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="dt">Prelude</span> <span class="dt">Data.Char</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> chr
chr<span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
<span class="dt">Prelude</span> <span class="dt">Data.Char</span><span class="fu">&gt;</span> map ord <span class="st">&quot;foobar&quot;</span>
[<span class="dv">102</span>,<span class="dv">111</span>,<span class="dv">111</span>,<span class="dv">98</span>,<span class="dv">97</span>,<span class="dv">114</span>]
<span class="dt">Prelude</span> <span class="dt">Data.Char</span><span class="fu">&gt;</span> map chr [<span class="dv">102</span>,<span class="dv">111</span>,<span class="dv">111</span>,<span class="dv">98</span>,<span class="dv">97</span>,<span class="dv">114</span>]
<span class="st">&quot;foobar&quot;</span></code></pre></div>
<h3 id="strings-ii">Strings II</h3>
<p>A String is just a list of <code>Char</code>, or <code>[Char]</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">String</span> <span class="fu">=</span> [<span class="dt">Char</span>] 	<span class="co">-- Defined in ‘GHC.Base’</span></code></pre></div>
<p>The double quotes in “foobar” are just syntactic sugar for:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> [<span class="ch">'f'</span>,<span class="ch">'o'</span>,<span class="ch">'o'</span>,<span class="ch">'b'</span>,<span class="ch">'a'</span>,<span class="ch">'r'</span>]
<span class="st">&quot;foobar&quot;</span></code></pre></div>
<h2 id="top-level-versus-local-definitions">3.4 Top-level versus local definitions</h2>
<h3 id="exercises-scope">Exercises: Scope</h3>
<ol style="list-style-type: decimal">
<li><code>y</code> is in scope for <code>z</code></li>
<li><code>h</code> is not in scope for <code>g</code></li>
<li><code>pi</code> is in scope, since it’s in Prelude, but <code>d</code> is not in scope for the definition of <code>r</code>. <code>d</code> is an argument in <code>area</code> but <code>r</code> can’t see into <code>area</code>’s definition.</li>
<li>This fixes what was wrong in the previous question. The <code>where</code> clause means that <code>r</code> can access <code>area</code>’s arguments. However, <code>r</code> is now locally defined to <code>area</code>, so another top level function wouldn’t be able to see it.</li>
</ol>
<h2 id="types-of-concatenation-functions">3.5 Types of concatenation functions</h2>
<h3 id="exercises-syntax-errors">Exercises: Syntax Errors</h3>
<ol style="list-style-type: decimal">
<li>Need <code>(++)</code> not <code>++</code></li>
<li>Single quotes are type <code>Char</code> not type <code>String</code></li>
<li>This one works.</li>
</ol>
<h2 id="chapter-exercises-1">Chapter Exercises</h2>
<h3 id="reading-syntax">Reading syntax:</h3>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li>correct</li>
<li>not correct, need <code>(++)</code> not <code>++</code></li>
<li>correct</li>
<li>incorrect, string not closed</li>
<li>incorrect, wrong arg order</li>
<li>correct</li>
<li>incorrect, no integer argument</li>
<li>correct</li>
</ol></li>
<li><ol style="list-style-type: lower-alpha">
<li>d</li>
<li>c</li>
<li>e</li>
<li>a</li>
<li>b</li>
</ol></li>
</ol>
<h3 id="building-functions">Building Functions:</h3>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><code>(++ &quot;!&quot;)</code></li>
<li><code>(!! 4)</code></li>
<li><code>(drop 6)</code></li>
</ol></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Exercise2</span> <span class="kw">where</span>
a <span class="fu">=</span> (<span class="fu">++</span> <span class="st">&quot;!&quot;</span>)
b <span class="fu">=</span> (<span class="fu">!!</span> <span class="dv">4</span>)
c <span class="fu">=</span> (drop <span class="dv">6</span>)</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Exercise3</span> <span class="kw">where</span>

<span class="ot">thirdLetter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
thirdLetter x <span class="fu">=</span> x <span class="fu">!!</span> <span class="dv">2</span></code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Exercise4</span> <span class="kw">where</span>

<span class="ot">letterIndex ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
letterIndex x <span class="fu">=</span> <span class="st">&quot;Curry is awesome&quot;</span> <span class="fu">!!</span> x</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Reverse</span> <span class="kw">where</span>
<span class="ot">rvrs ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
rvrs x <span class="fu">=</span> third <span class="fu">++</span> second <span class="fu">++</span> first <span class="kw">where</span>
         third <span class="fu">=</span> drop <span class="dv">9</span> x
         second <span class="fu">=</span> take <span class="dv">4</span> <span class="fu">$</span> drop <span class="dv">5</span> x
         first <span class="fu">=</span> take <span class="dv">5</span> x

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> rvrs <span class="st">&quot;Curry is awesome&quot;</span></code></pre></div></li>
<li>see exercise 5.</li>
</ol>
<hr />
<h1 id="basic-datatypes">4 Basic Datatypes</h1>
<h2 id="what-are-types">4.2 What are types?</h2>
<p><strong>Types</strong>: Haskell has expressions. Type the number <code>1</code> into the repl. That’s an expression. Type <code>addOne = (+) 1</code>. The function <code>addOne</code> is also an expression. Try to imagine all the possible expressions we could type into GHCi. This is hard to do because the number of possibile expressions is infinite. But if we try to imagine lots of different expressions, we should start to notice patterns. <code>1</code> is an expression, so is <code>2</code>, so is <code>3</code>, and so on. All positive integers are expressions. <code>-1</code> is an expression, so <code>-2</code> and <code>-3</code>. Negative integers, and therefore all integers are expressions. The pair <code>(1,1)</code> is an expression, so is <code>(1,2)</code>, so is <code>(23,58982)</code>. All pairs of integers are expressions. We can keep going like this forever, finding new patterns of ways to group expressions together. Every time we find a new expression-pattern, if we can precisely describe the structure of that pattern, we have a type.</p>
<p>When we played with the <code>String</code> type in the preceeding chapter, we were, in effect, saying “Let’s for the moment think about only those expressions that have the <code>String</code> pattern, which looks like this:</p>
<p>`<code>haskell data String = [Char] data [] a = [] | a : [a]</code></p>
<p>Haskell mandates that expressions have types, and the compiler will not let us run code where the types do not match up.</p>
<p>Try running:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> not <span class="st">&quot;foo&quot;</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">4</span><span class="fu">:</span><span class="dv">5</span><span class="fu">:</span> error<span class="fu">:</span>
    • <span class="dt">Couldn't</span> match expected <span class="kw">type</span> ‘<span class="dt">Bool</span>’ with actual <span class="kw">type</span> ‘[<span class="dt">Char</span>]’
    • <span class="dt">In</span> the first argument <span class="kw">of</span> ‘not’, namely ‘<span class="st">&quot;foo&quot;</span>’
      <span class="dt">In</span> the expression<span class="fu">:</span> not <span class="st">&quot;foo&quot;</span>
      <span class="dt">In</span> an equation for ‘it’<span class="fu">:</span> it <span class="fu">=</span> not <span class="st">&quot;foo&quot;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> not
not<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre></div>
<p><code>not</code> is a function which takes a <code>Bool</code> and returns a <code>Bool</code>. If we try to call <code>not</code> with a <code>String</code> we get a type error. Our expression was not “well-typed.”</p>
<p>We can also define new patterns, like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Grocery</span> <span class="fu">=</span> <span class="dt">Milk</span> <span class="fu">|</span> <span class="dt">Eggs</span> <span class="fu">|</span> <span class="dt">Flour</span></code></pre></div>
<p>So the type system is a tool for defining new patterns in the space of possible expressions, and then checking that in the code we want to run, all the types fit together perfectly.</p>
<p>If you have ever played with Legos, you already have an intuition for how this ought to work.</p>
<p align="center">
<img src="https://upload.wikimedia.org/wikipedia/commons/3/32/Lego_Color_Bricks.jpg" width="400px" alt="Legos">
</p>
<p>There are a lot of different ways to fit Lego’ together. Two standard two by four Lego bricks of the same color can be combined 24 ways (ignoring symmetries). But there are also a lot of ways that you can’t fit pieces together. You can’t, for example, place a brick on top of two adjacent bricks at different heights. No amount of force will get the pieces to bend (Lego’s are very tough) that way. You can’t “coerce” Lego’s into doing whatever you want. The shapes are what they are, and it’s up to you the builder to figure out some interesting way to fit them together.</p>
<p>Haskell expressions are like Lego pieces. And types are like their shapes. But unlike with Lego’s, you get to design entirely new pieces, as well as put them together.</p>
<h2 id="anatomy-of-a-data-declaration">4.3 Anatomy of a data declaration</h2>
<p>In the data declaration:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span></code></pre></div>
<p>It’s important to keep in mind that everything to left of the <code>=</code> are types, and everything to the right are expressions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span> <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">False</span>
<span class="dt">False</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Bool</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">6</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> <span class="dt">Data</span> constructor not <span class="kw">in</span> scope<span class="fu">:</span> <span class="dt">Bool</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span><span class="kw">type</span> <span class="dt">False</span>
<span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>info <span class="dt">Bool</span>
<span class="kw">data</span> <span class="dt">Bool</span> <span class="fu">=</span> <span class="dt">False</span> <span class="fu">|</span> <span class="dt">True</span> 	<span class="co">-- Defined at &lt;interactive&gt;:4:1</span>
<span class="kw">instance</span> [safe] <span class="dt">Show</span> <span class="dt">Bool</span> <span class="co">-- Defined at &lt;interactive&gt;:4:35</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span></code></pre></div>
<p><code>Bool</code> and <code>False</code> live in two different spaces. <code>Bool</code> lives in type-space and <code>False</code> lives in data-space. This is a really important distinction! Typespace disappears after code gets compiled, so you can’t interact with them in running code (or “runtime”).</p>
<p><strong>compile-time</strong>: When code gets compiled. Types are used in compiletime, but not in runtime. Compiler errors happen at compile-time.</p>
<p><strong>run-time</strong>: When code gets run. Haskell types vanish at run-time. A run-time error might be an exception like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</code></pre></div>
<p>Another thing to remember is that since typespace and dataspace are distinct, the same name can live in both spaces:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">Thing</span> a <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Thing</span> <span class="dv">1</span>
<span class="dt">Thing</span> <span class="dv">1</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Thing</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Thing</span> <span class="dt">Integer</span>
<span class="dt">Thing</span> <span class="dv">1</span></code></pre></div>
<p><code>Thing</code> the data constructor lives in dataspace:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Thing</span>
<span class="dt">Thing</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Thing</span> a</code></pre></div>
<p>And <code>Thing</code> the type constructor lives in typespace:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Thing</span>
<span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">Thing</span> a 	<span class="co">-- Defined at &lt;interactive&gt;:24:1</span>
<span class="kw">instance</span> [safe] <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Thing</span> a)
  <span class="co">-- Defined at &lt;interactive&gt;:24:33</span></code></pre></div>
<p>But this is just two names that happen to be the same. We could equivalently say:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">MakeThing</span> a <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>and everything behaves the same:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">MakeThing</span> a <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">Thing</span> <span class="dv">1</span>

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">5</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span>
    <span class="dt">Data</span> constructor not <span class="kw">in</span> scope<span class="fu">:</span> <span class="dt">Thing</span><span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> t
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="dt">MakeThing</span> <span class="dv">1</span>
<span class="dt">MakeThing</span> <span class="dv">1</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">Thing</span> 

<span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> <span class="dt">Data</span> constructor not <span class="kw">in</span> scope<span class="fu">:</span> <span class="dt">Thing</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">MakeThing</span> 
<span class="dt">MakeThing</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Thing</span> a
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Thing</span>
<span class="kw">data</span> <span class="dt">Thing</span> a <span class="fu">=</span> <span class="dt">MakeThing</span> a 	<span class="co">-- Defined at &lt;interactive&gt;:4:1</span>
<span class="kw">instance</span> [safe] <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Thing</span> a)
  <span class="co">-- Defined at &lt;interactive&gt;:4:37</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> </code></pre></div>
<h3 id="exercises-mood-swing">Exercises: Mood Swing</h3>
<ol style="list-style-type: decimal">
<li><code>Mood</code></li>
<li><code>Blah</code> or <code>Woot</code></li>
<li>Woot is a value whose type is Mood, should be <code>changeMood :: Mood -&gt; Mood</code></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Mood.hs</span>
<span class="kw">module</span> <span class="dt">Mood</span> <span class="kw">where</span>
<span class="kw">data</span> <span class="dt">Mood</span> <span class="fu">=</span> <span class="dt">Woot</span> <span class="fu">|</span> <span class="dt">Blah</span> <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">changeMood ::</span> <span class="dt">Mood</span> <span class="ot">-&gt;</span> <span class="dt">Mood</span>
changeMood <span class="dt">Blah</span> <span class="fu">=</span> <span class="dt">Woot</span>
changeMood <span class="dt">Woot</span> <span class="fu">=</span> <span class="dt">Blah</span></code></pre></div></li>
<li>see 4.</li>
</ol>
<h2 id="numeric-types">4.4 Numeric types</h2>
<p>Numeric types will not completely make sense without typeclasses.</p>
<p><strong>Typeclass</strong>: A collection of types that share common properties. For example, the typeclass <code>Show</code> is defined as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i <span class="dt">Show</span>
<span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span>
<span class="ot">  showsPrec ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
<span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">  showList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ShowS</span>
  <span class="ot">{-# MINIMAL showsPrec | show #-}</span>
  	<span class="co">-- Defined in ‘GHC.Show’</span></code></pre></div>
<p>Which is for our purposes equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Show</span> a <span class="kw">where</span>
<span class="ot">  show ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p>So any type that is an instance of <code>Show</code> has a function called <code>show</code> that lets you turn a value of that type into a <code>String</code>.</p>
<p>Let’s try it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Something</span> <span class="fu">=</span> <span class="dt">Something</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Something</span> <span class="kw">where</span> show <span class="dt">Something</span> <span class="fu">=</span> <span class="st">&quot;Something&quot;</span>
<span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dt">Something</span>
<span class="st">&quot;Something&quot;</span></code></pre></div>
<p>Of course, this is tedious, so Haskell gives us a <code>deriving</code> mechanism that does effectively this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="kw">data</span> <span class="dt">Something</span> <span class="fu">=</span> <span class="dt">Something</span> <span class="kw">deriving</span> show
<span class="dt">Prelude</span><span class="fu">&gt;</span> show <span class="dt">Something</span>
<span class="st">&quot;Something&quot;</span></code></pre></div>
<p>The reason this is relevant is that <code>Num</code>, <code>Fractional</code> and <code>Integral</code> are all typeclasses, not types:</p>
<pre><code>Prelude&gt; :i Num
class Num a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: Integer -&gt; a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
Prelude&gt; :i Fractional
class Num a =&gt; Fractional a where
  (/) :: a -&gt; a -&gt; a
  recip :: a -&gt; a
  fromRational :: Rational -&gt; a
  {-# MINIMAL fromRational, (recip | (/)) #-}
  	-- Defined in ‘GHC.Real’
Prelude&gt; :i Integral
class (Real a, Enum a) =&gt; Integral a where
  quot :: a -&gt; a -&gt; a
  rem :: a -&gt; a -&gt; a
  div :: a -&gt; a -&gt; a
  mod :: a -&gt; a -&gt; a
  quotRem :: a -&gt; a -&gt; (a, a)
  divMod :: a -&gt; a -&gt; (a, a)
  toInteger :: a -&gt; Integer
  {-# MINIMAL quotRem, toInteger #-}
  	-- Defined in ‘GHC.Real’</code></pre>
<p>But this is getting pretty deep into the “typeclass zoo.” Better leave this for chapters 5 and 6.</p>
<h2 id="go-on-and-bool-me">4.6 Go on and Bool me</h2>
<h3 id="exercises-find-the-mistakes">Exercises: Find the Mistakes</h3>
<ol style="list-style-type: decimal">
<li><code>not True &amp;&amp; True</code></li>
<li><code>not (x == 6) where x = 5</code></li>
<li><code>(1 * 2) &gt; 5</code></li>
<li><code>[&quot;Merry&quot;] &gt; [&quot;Happy&quot;]</code></li>
<li><code>[&quot;1, 2, 3&quot;] ++ &quot;look at me!&quot;</code></li>
</ol>
<h2 id="chapter-exercises-2">4.9 Chapter Exercises</h2>
<ol style="list-style-type: decimal">
<li><p><code>length :: [a] -&gt; Int</code></p></li>
<li><ol style="list-style-type: lower-alpha">
<li>5</li>
<li>3</li>
<li>2</li>
<li>5</li>
</ol></li>
<li><code>Int</code> is not a <code>Fractional</code></li>
<li>Use infix `<code>div`</code> instead</li>
<li><code>Bool</code>, returns <code>True</code></li>
<li><code>Bool</code>, returns <code>False</code></li>
<li><ol style="list-style-type: lower-alpha">
<li>Works, <code>False</code></li>
<li>Error, no instance <code>(Num Char)</code></li>
<li>Works, returns <code>8</code></li>
<li>Works returns <code>False</code></li>
<li>No instance <code>(Num Bool)</code></li>
</ol></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isPalindrome ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isPalindrome x <span class="fu">=</span> reverse x <span class="fu">==</span> x</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myAbs ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
myAbs <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> (<span class="fu">-</span>x) <span class="kw">else</span> x</code></pre></div></li>
<li><p>```haskell – Exercise10.hs module Exercise10 where</p>
<p>f :: (a, b) -&gt; (c, d) -&gt; ((b, d), (a, c)) f x y = ((snd x, snd y), (fst x, fst y)) ```</p></li>
</ol>
<h3 id="correcting-syntax">Correcting syntax</h3>
<ol style="list-style-type: decimal">
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- CorrectingSyntax1.hs</span>
<span class="kw">module</span> <span class="dt">CorrectingSyntax1</span> <span class="kw">where</span>

f xs <span class="fu">=</span> length xs <span class="fu">+</span> <span class="dv">1</span></code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- CorrectingSyntax2.hs</span>
<span class="kw">module</span> <span class="dt">CorrectingSyntax2</span> <span class="kw">where</span>

f <span class="fu">=</span> (\x <span class="ot">-&gt;</span> x)</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- CorrectingSyntax3.hs</span>
<span class="kw">module</span> <span class="dt">CorrectingSyntax3</span> <span class="kw">where</span>

f (a, b) <span class="fu">=</span> a</code></pre></div></li>
</ol>
<h3 id="match-the-function-names-to-their-types">Match the function names to their types</h3>
<ol style="list-style-type: decimal">
<li>c</li>
<li>b</li>
<li>a</li>
<li>d</li>
</ol>
<hr />
<h2 id="types">5 Types</h2>
<p>I want to acknowledge how apt and lovely the quote at the beginning of this chapter is. It is an excerpt from the Wallace Stevens poem: <a href="https://www.poetryfoundation.org/poems/43431/the-idea-of-order-at-key-west">The Idea of Order at Key West</a></p>
<h2 id="how-to-read-type-signatures">5.3 How to read type signatures</h2>
<p>The type constructor for function <code>(-&gt;)</code> isn’t magic. It’s exactly like any other type constructor. Recall how previously with lists the type constructor was <code>[]</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i []
<span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a] 	<span class="co">-- Defined in ‘GHC.Types’</span></code></pre></div>
<p>There isn’t any reason other than cleaner syntax that <code>[] a</code> or <code>[a]</code> couldn’t be <code>List a</code>.</p>
<p>Well the function type is almost exactly the same. There isn’t any reason why <code>a -&gt; b</code>, which is <code>(-&gt;) a b</code>, couldn’t be <code>Fun a b</code>. It’s just more syntactic sugar (Haskell is a very sugary language. That’s why it’s so sweet!)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i (<span class="ot">-&gt;</span>)
<span class="kw">data</span> (<span class="ot">-&gt;</span>) t1 t2 	<span class="co">-- Defined in ‘GHC.Prim’</span>
<span class="kw">infixr</span> <span class="dv">0</span> <span class="ot">`(-&gt;)`</span></code></pre></div>
<p>There isn’t any definiiton for the function type though because it’s a primitive (hence the <code>GHC.Prim</code>).</p>
<h3 id="exercises-type-matching">Exercises: Type Matching</h3>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><code>not :: Bool -&gt; Bool</code></li>
<li><code>length :: [a] -&gt; Int</code></li>
<li><code>concat :: [[a]] -&gt; [a]</code></li>
<li><code>head :: [a] -&gt; a</code></li>
<li><code>(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool</code></li>
</ol></li>
</ol>
<h2 id="currying">5.4 Currying</h2>
<p>All these types for <code>f</code> are equivalent:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Fun</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>)
<span class="ot">f ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">f ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a)
<span class="ot">f ::</span> (<span class="ot">-&gt;</span>) a ((<span class="ot">-&gt;</span>) a a)
<span class="ot">f ::</span> <span class="dt">Fun</span> a (<span class="dt">Fun</span> a a)</code></pre></div>
<p>Functions in Haskell return one and only one thing. Partial application is kind of a silly term. What’s partial about applying a <code>Fun a (Fun a a)</code> to an <code>a</code>? You give it an <code>a</code>, it gives you a function. Nothing partial about that. Maybe we wanted a function.</p>
<p>It’s only partial if you think of functions of somehow not being final values. Which is how they are in imperative-land. But we’re not in imperative-land anymore. Here functions are first-class, so they actually are values like anything else.</p>
<p>In fact, if you remember any of Chapter 1, there’s a good argument to be made that functions are more real than any other value. Lambda calculus builds the whole universe out of functions. Sure literals exist, but they’re a convenience (a huge convenience) not a strict necessity.</p>
<p>The <code>curry</code> and <code>uncurry</code> functions in the text are useful to understand conceptually.</p>
<p>Sectioning is basically bad practice. It’s a great way to confuse yourself and others. Do yourself a favor and throw an abstraction on top of it:</p>
<p>Not</p>
<pre><code>y = (2^)
z = (^2)</code></pre>
<p>But rather,</p>
<pre><code>y = \x -&gt; 2^x
z = \x -&gt; x^2</code></pre>
<p>You see how much nicer that is? Don’t abuse infix operators please. They’re there to make text more legible, not more terse and inscrutable. There are definitely cases where a clever sectioning of an infix operator can make things clearer. These cases are exceptions.</p>
<h3 id="exercises-type-arguments">Exercises: Type Arguments</h3>
<ol style="list-style-type: decimal">
<li>a</li>
<li>d</li>
<li>d</li>
<li>c</li>
<li>a</li>
<li>e</li>
<li>e</li>
<li>e</li>
<li>c</li>
</ol>
<h2 id="polymorphism">5.5 Polymorphism</h2>
<p>Greek words abound in Haskell jargon. If we lived in an age that believed in proper education you would already know them. We do not live in such an age.</p>
<p>Important words:</p>
<pre><code>hyle: matter
morphe: form

polys: - many
monos: - one

autos: self
endon: in
ectos: out
isos: equal

ana: up
kata: down
epi:  upon
meta: beyond, with
para: beside
meter: measure</code></pre>
<p>So when you read “parameteric polymorphism”, fear not, you are really reading “beside-measure many-form-thing.” The latter doesn’t sound nearly as clever at cocktail parties, but that’s actually what the words mean, and knowing the meanings of the words you use helps you remember the concepts they describe.</p>
<p>A parameter is quite literally a “side measure.” When we measure a thing by looking at it next to something else, we’re using a parameter. Ever ask whether something was bigger than a breadbox? That’s measuring size in terms of breadboxes. It’s a side measures. It’s a parameter.</p>
<h2 id="exercises-parametricity">Exercises: Parametricity</h2>
<ol style="list-style-type: decimal">
<li>This is impossible because id has to work for a type that only one member. If a type only has one member, then the only thing a function with signature a -&gt; a can do if passed a value of that type is return the same value (or bottom, which is in every type) without breaking the type signature.</li>
<li><code>f x y = x</code> or <code>f x y = y</code></li>
<li><code>a -&gt; b -&gt; b</code> is the same as <code>a -&gt; (b -&gt; b)</code> and the only thing with type <code>(b -&gt; b)</code> is the id function. So this function is a kind of constant function that takes two arguments and returns the second, as opposed to <code>const :: a -&gt; b -&gt; a</code> which takes two arguments and returns the first. One implementation would be <code>const id</code>, but I am unsure whether <code>flip const</code> counts as a separate implementation.</li>
</ol>
<h2 id="type-inference">5.6 Type Inference</h2>
<p>Type inference is a cool tool for helping us build better programs. But it works best when you give it annotations to infer from. A lot of Haskell programming involves defining the types of the top-level expressions in your program before you actually start constructing anything, so this isn’t exactly any extra work.</p>
<p>And if you want to see real type system magic at work: <a href="https://aphyr.com/posts/342-typing-the-technical-interview">Typing the technical interview</a></p>
<h3 id="exercises-apply-yourself">Exercises: Apply Yourself</h3>
<ol style="list-style-type: decimal">
<li><code>[Char] -&gt; [Char]</code></li>
<li><code>Fractional a =&gt; a -&gt; a</code></li>
<li><code>Int -&gt; [Char]</code></li>
<li><code>Int -&gt; Bool</code></li>
<li><code>Char -&gt; Bool</code></li>
</ol>
<h2 id="chapter-exercises-3">5.8 Chapter Exercises</h2>
<h3 id="multiple-choice">Multiple Choice</h3>
<ol style="list-style-type: decimal">
<li>c</li>
<li>a</li>
<li>b</li>
<li>c</li>
</ol>
<h3 id="determine-the-type">Determine the type:</h3>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><code>Num a =&gt; a</code></li>
<li><code>Num a =&gt; (a, [Char])</code></li>
<li><code>(Integer, [Char])</code></li>
<li><code>Bool</code></li>
<li><code>Int</code></li>
<li><code>Bool</code></li>
</ol></li>
<li><code>Num a =&gt; a</code></li>
<li><code>Num a =&gt; a -&gt; a</code></li>
<li><code>Fractional a =&gt; a</code></li>
<li><code>[Char]</code></li>
</ol>
<h3 id="does-it-compile">Does it compile?:</h3>
<ol style="list-style-type: decimal">
<li><code>bignum $ 10</code> doesn’t make sense <code>5^10</code> is a number not a function</li>
<li>This should work.</li>
<li>c and d need a function.</li>
<li>c not in scope.</li>
</ol>
<h3 id="type-variable-or-specific-type-constructor">Type variable or specific type constructor?</h3>
<ol style="list-style-type: decimal">
<li></li>
</ol>
<ul>
<li>0: constrained polymorphic type var</li>
<li>1: fully polymorphic type var</li>
<li>2: concrete</li>
<li>3: concrete</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li></li>
</ol>
<ul>
<li>0: fully polymorphic</li>
<li>1: concrete</li>
<li>2: concrete</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li></li>
</ol>
<ul>
<li>0: fully polymorphic</li>
<li>1: constrained polymorphic</li>
<li>2: concrete</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li></li>
</ol>
<ul>
<li>0: fully polymorphic</li>
<li>1: fully polymorphic</li>
<li>2: concrete</li>
</ul>
<h3 id="write-a-type-signature">Write a type signature:</h3>
<ol style="list-style-type: decimal">
<li><code>[a] -&gt; a</code></li>
<li><code>(Ord a, Ord b) =&gt; a -&gt; b -&gt; Bool</code></li>
<li><code>(a, b) -&gt; b</code></li>
</ol>
<h3 id="given-a-type-write-the-function">Given a type, write the function:</h3>
<ol style="list-style-type: decimal">
<li><code>i = id</code></li>
<li><code>c x y = x</code></li>
<li><code>yes</code></li>
<li><code>c' x y = y</code></li>
<li><code>r = tail</code></li>
<li><code>co x y z = x $ y z</code></li>
<li><code>a x y = fst(y, x y)</code></li>
<li><code>a' x y = x y</code></li>
</ol>
<h3 id="fix-it">Fix it</h3>
<ol style="list-style-type: decimal">
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Sing</span> <span class="kw">where</span>

<span class="ot">fstString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
fstString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; in the rain&quot;</span>

<span class="ot">sndString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
sndString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; over the rainbow&quot;</span>

sing <span class="fu">=</span> <span class="kw">if</span> (x <span class="fu">&gt;</span> y) <span class="kw">then</span> fstString x <span class="kw">else</span> sndString y <span class="kw">where</span> 
       x <span class="fu">=</span> <span class="st">&quot;Singin&quot;</span>
       y <span class="fu">=</span> <span class="st">&quot;Somewhere&quot;</span></code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Sing</span> <span class="kw">where</span>

<span class="ot">fstString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
fstString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; in the rain&quot;</span>

<span class="ot">sndString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
sndString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; over the rainbow&quot;</span>

sing <span class="fu">=</span> <span class="kw">if</span> (x <span class="fu">&lt;</span> y) <span class="kw">then</span> fstString x <span class="kw">else</span> sndString y <span class="kw">where</span> 
       x <span class="fu">=</span> <span class="st">&quot;Singin&quot;</span>
       y <span class="fu">=</span> <span class="st">&quot;Somewhere&quot;</span></code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Arith3Broken</span> <span class="kw">where</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>
  print <span class="dv">10</span> 
  print <span class="fu">$</span> negate (<span class="fu">-</span><span class="dv">1</span>)
  print <span class="fu">$</span> <span class="dv">0</span> <span class="fu">+</span> blah
  <span class="kw">where</span> blah <span class="fu">=</span> negate <span class="dv">1</span></code></pre></div></li>
</ol>
<h3 id="type-kwon-do">Type-Kwon-Do</h3>
<ol style="list-style-type: decimal">
<li><code>h x = g $ f x</code></li>
<li><code>e x = w $ q x</code></li>
<li><code>xform (x, y) = (xz x, yz y)</code></li>
<li><code>munge f g x = fst $ g $ f x</code></li>
</ol>
<h2 id="follow-up-resources-2">5.10 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p>Luis Damas; Robin Milner. Principal type-schemes for func- tional programs</p></li>
<li><p>Christopher Strachey. Fundamental Concepts in Programming Languages Popular origin of the parametric/ad-hoc polymorphism dis- tinction.</p></li>
</ol>
<hr />
<h1 id="typeclasses">6 Typeclasses</h1>
<h2 id="what-are-typeclasses">6.2 What are typeclasses?</h2>
<p>“Typeclasses and types in Haskell are, in a sense, opposites”.</p>
<p>Sentences like these frustrate me. You can say nearly anything is the case “in a sense:”</p>
<p>“In a sense, the Moon really is made of cheese.” In the sense of poetic whimsy.</p>
<p>“In a sense, Johnny is at the top of his class.” In unexcused absences and missed assignments.</p>
<p>This is just some plain old fashioned jesuitical casuistry. Annoying.</p>
<p>“In a sense, typeclasses and types are the same.” In the sense that they both specify and constrain the properties of expressions.</p>
<p>If an expression’s type is an instance of <code>Eq</code> it means there’s a way to define to define and equals function <code>(==)</code> to check if two expressions of that type are equal:</p>
<pre><code>Prelude&gt; :info Eq
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
  	-- Defined in ‘GHC.Classes’</code></pre>
<p>But there are types that it is impossible to define <code>(==)</code> for! The function constructor <code>(-&gt;)</code>, for example, cannot be an instance of <code>Eq</code>. Why? The Halting Problem! If there’s no general way to test whether a function will halt on a given input, there’s certainly no general way to determine whether two functions will do the same thing (run forever or return the same value) for a given input.</p>
<p>So typeclasses constrains the potential things types can be by specifying what they can do.</p>
<p>Some typeclasses and their relationships:</p>
<p align="center">
<img src="https://wiki.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png" width="600px" alt="Typeclassopedia">
</p>
<h2 id="exercises-eq-instances">Exercises: Eq Instances</h2>
<ol style="list-style-type: decimal">
<li><pre><code>instance Eq TisAnInteger where (==) TisAn x TisAn y = (==) x y</code></pre></li>
<li><pre><code>instance Eq TwoIntegers where Two x y == Two p q = (x, y) == (p, q)</code></pre></li>
<li><p>String or Int:</p>
<pre><code>instance Eq StringOrInt where 
TisAnInt x == TisAnInt y = x == y
TisAString x == TisAString y = x == y
_ == _ = False</code></pre></li>
<li><pre><code>instance Eq Pair where Pair a b == Pair x y = (a, b) == (x, y)</code></pre></li>
<li><pre><code>instance Eq Tuple where Tuple a b == Tuple x y = (a, b) == (x, y)</code></pre></li>
<li><p>Which</p>
<pre><code>instance Eq a =&gt; Eq (Which a) where 
ThisOne x == ThisOne y = x == y
ThatOne x == ThatOne y = x == y
_ == _ = False</code></pre></li>
<li><p>EitherOr</p>
<pre><code>instance (Eq a, Eq b) =&gt; Eq (EitherOr a b) where 
Hello x == Hello y = x == y
Goodbye x == Goodbye y = x == y 
_ == _ = False</code></pre></li>
</ol>
<h2 id="exercises-tuple-experiment">Exercises: Tuple Experiment</h2>
<p><code>quotRem</code> and <code>divMod</code> return a tuple with the values from <code>quot</code> and <code>rem</code> or <code>div</code> and <code>mod</code> respectively.</p>
<h2 id="exercises-will-they-work">Exercises: Will They Work?</h2>
<ol style="list-style-type: decimal">
<li><code>5</code></li>
<li><code>LT</code></li>
<li>error, a string and a bool are not comparable</li>
<li><code>False</code></li>
</ol>
<h2 id="chapter-exercises-4">Chapter Exercises</h2>
<h3 id="multiple-choice-1">Multiple choice</h3>
<ol style="list-style-type: decimal">
<li>c</li>
<li>b</li>
<li>a</li>
<li>c</li>
<li>a</li>
</ol>
<h3 id="does-it-typecheck">Does it typecheck?:</h3>
<ol style="list-style-type: decimal">
<li>ch6/ex1.hs</li>
<li><p>ch6/ex2.hs</p></li>
<li><ol style="list-style-type: lower-alpha">
<li>any <code>Mood</code>, i.e. <code>Blah</code> or <code>Woot</code></li>
<li>type error, <code>9</code> is not a <code>Mood</code></li>
<li><code>Mood</code> does not derive <code>Ord</code></li>
</ol></li>
<li><p>ch6/ex4.hs</p></li>
</ol>
<h3 id="given-a-datatype-declaration-what-can-we-do">Given a datatype declaration, what can we do?</h3>
<p>exdatatype.hs</p>
<ol style="list-style-type: decimal">
<li><code>&quot;chases&quot;</code> and <code>True</code> are a <code>String</code> and a <code>Bool</code>, not a <code>Rocks</code> and a <code>Yeah</code></li>
<li>works</li>
<li>works</li>
<li><code>Papu</code> isn’t an instance of <code>Ord</code></li>
</ol>
<h3 id="match-the-types">Match the types:</h3>
<p>exmatch1.hs and exmatch2.hs</p>
<ol style="list-style-type: decimal">
<li>Since <code>i = 1</code>, <code>i</code> has to be a <code>Num</code>, it can’t be a type that <code>1</code> isn’t, like e.g. a <code>String</code>. We can’t cast <code>i</code> upwards.</li>
<li><code>1.0</code> is not just any instance of <code>Num</code>, the syntax implies <code>Fractional</code>.</li>
<li>works</li>
<li>works</li>
<li>works, we can always cast downwards</li>
<li>works</li>
<li>Doesn’t work, <code>sigmund</code> returns <code>myX</code> which is an <code>Int</code></li>
<li>Doesn’t work, <code>sigmund'</code> returns an <code>Int</code> not any instance of <code>Num</code></li>
<li>Works, restricts <code>jung</code> to a list of <code>Ints</code> rather than any list</li>
<li>Works, restricts input to <code>String</code></li>
<li>Doesn’t work, <code>mySort</code> only sorts <code>Strings</code>, not any instance of <code>Ord</code></li>
</ol>
<h3 id="type-kwon-do-electric-typealoo">Type-Kwon-Do: Electric Typealoo</h3>
<ol style="list-style-type: decimal">
<li><code>chk f a b = f a == b</code></li>
<li><code>arith f n a = (+ fromIntegral n) (f a)</code></li>
</ol>
<h2 id="follow-up-resources-3">6.17 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p>[P. Wadler and S. Blott. How to make ad-hoc polymorphism less ad hoc.] (http://www.cse.iitk.ac.in/users/karkare/courses/2010/cs653/Papers/ ad-hoc-polymorphism.pdf)</p></li>
<li><p>[Cordelia V. Hall, Kevin Hammond, Simon L. Peyton Jones, and Philip L. Wadler. Typeclasses in Haskell.] (http://ropas.snu.ac.kr/lib/dock/HaHaJoWa1996.pdf)</p></li>
</ol>
<hr />
<h1 id="more-functional-patterns">7 More functional patterns</h1>
<h2 id="arguments-and-parameters">7.2 Arguments and parameters</h2>
<p>This section is best understood in the context of the lambda calculus. I recommend reading at least <a href="../posts/workthrough-lambda-calculus-rojas.html#definition">chapter 1 of my notes on Rojas’ Introduction to the Lambda Calculus</a>.</p>
<h2 id="anonymous-functions">7.3 Anonymous functions</h2>
<h3 id="exercises-grab-bag">Exercises: Grab bag</h3>
<ol style="list-style-type: decimal">
<li>They are all equivalent</li>
<li>d</li>
<li><ol style="list-style-type: lower-alpha">
<li><code>f = \x -&gt; x + 1</code></li>
<li><code>addFive = \x -&gt; \y -&gt; (min x y) + 5</code></li>
<li><code>mflip f x y = f y x</code></li>
</ol></li>
</ol>
<h2 id="pattern-matching">7.4 Pattern matching</h2>
<p>From <a href="https://github.com/johnchandlerburnham/hpffp-resources/blob/master/Chapter-02/How%20to%20desugar%20Haskell%20code.pdf">Gonzalez’s “How to Desugar Haskell Code”</a></p>
<blockquote>
<p>Pattern matching on constructors desugars to case statements:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (<span class="dt">Left</span>  l) <span class="fu">=</span> eL
f (<span class="dt">Right</span> r) <span class="fu">=</span> eR

<span class="co">-- ... desugars to:</span>

f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span>
    <span class="dt">Left</span>  l <span class="ot">-&gt;</span> eL
    <span class="dt">Right</span> r <span class="ot">-&gt;</span> eR</code></pre></div>
<p>Pattern matching on numeric or string literals desugars to equality tests:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="dv">0</span> <span class="fu">=</span> e0
f _ <span class="fu">=</span> e1

<span class="co">-- ... desugars to:</span>
f x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> e0 <span class="kw">else</span> e1

<span class="co">-- ... desugars to:</span>
f x <span class="fu">=</span> <span class="kw">case</span> x <span class="fu">==</span> <span class="dv">0</span> <span class="kw">of</span>
    <span class="dt">True</span>  <span class="ot">-&gt;</span> e0
    <span class="dt">False</span> <span class="ot">-&gt;</span> e1</code></pre></div>
</blockquote>
<h3 id="exercises-variety-pack">Exercises: Variety Pack</h3>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><code>k :: (a, b) -&gt; a</code></li>
<li><code>k2</code> is a <code>String</code>, not the same as <code>k1</code> or <code>k3</code></li>
<li><code>k1</code> and <code>k3</code></li>
</ol></li>
<li><code>f (a, b, c) (d, e, f) = ((a, d), (c, f))</code></li>
</ol>
<h2 id="case-expressions">7.5 Case expressions</h2>
<h3 id="exercises-case-practice">Exercises: Case Practice</h3>
<ol style="list-style-type: decimal">
<li><pre><code>functionC x y = case (x &gt; y) of
  True -&gt; x 
  False -&gt; y </code></pre></li>
<li><pre><code>ifEvenAdd2 n = 
  case even n
    True -&gt; (n + 2)
    False -&gt; n</code></pre></li>
<li><pre><code>nums x = 
  case compare x 0 of
    LT -&gt; -1
    GT -&gt; 1
    EQ -&gt; 0</code></pre></li>
</ol>
<h2 id="higher-order-functions">7.6 Higher-order functions</h2>
<h3 id="exercises-artful-dodgy">Exercises: Artful Dodgy</h3>
<ol start="2" style="list-style-type: decimal">
<li><code>11</code></li>
<li><code>22</code></li>
<li><code>21</code></li>
<li><code>12</code></li>
<li><code>11</code></li>
<li><code>21</code></li>
<li><code>21</code></li>
<li><code>22</code></li>
<li><code>31</code></li>
<li><code>23</code></li>
</ol>
<h2 id="guards">7.7 Guards</h2>
<h3 id="exercises-guard-duty">Exercises: Guard Duty</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--07/AvgGrade.hs</span>
<span class="kw">module</span> <span class="dt">AvgGrade</span> <span class="kw">where</span>

<span class="ot">avgGrade ::</span> (<span class="dt">Fractional</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span>
avgGrade x
  <span class="fu">|</span> y <span class="fu">&gt;=</span> <span class="fl">0.7</span> <span class="fu">=</span> <span class="ch">'C'</span>
  <span class="fu">|</span> y <span class="fu">&gt;=</span> <span class="fl">0.9</span> <span class="fu">=</span> <span class="ch">'A'</span>
  <span class="fu">|</span> y <span class="fu">&gt;=</span> <span class="fl">0.8</span> <span class="fu">=</span> <span class="ch">'B'</span>
  <span class="fu">|</span> y <span class="fu">&gt;=</span> <span class="fl">0.59</span> <span class="fu">=</span> <span class="ch">'D'</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="ch">'F'</span>
  <span class="kw">where</span> 
    y <span class="fu">=</span> x <span class="fu">/</span> <span class="dv">100</span>  </code></pre></div>
<ol style="list-style-type: decimal">
<li>Can’t do otherwise if theres no wise to other.</li>
<li>No, because the conditions are not exclusive.</li>
<li>b</li>
<li>anything reversible, so lists</li>
<li><code>[a] -&gt; Bool</code></li>
<li>c</li>
<li><code>(Ord a, Num a) =&gt; a</code></li>
<li><code>(Ord a, Num a) =&gt; a -&gt; Bool</code></li>
</ol>
<h2 id="chapter-exercises-5">7.11 Chapter Exercises</h2>
<h3 id="multiple-choice-2">Multiple Choice</h3>
<ol style="list-style-type: decimal">
<li>d</li>
<li>b</li>
<li>a</li>
<li>b</li>
<li>a</li>
</ol>
<h3 id="lets-write-code">Let’s write code</h3>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><p><code>tensDigit x = (flip mod) 10 $ fst $ divMod x 10</code></p>
<p>Seems silly to use <code>divMod</code>, when</p>
<p><code>tensDigit' x = (flip mod) 10 $ div x 10</code></p>
<p>works perfectly well.</p></li>
<li><p>Yup.</p></li>
<li><p>Well let’s do this properly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 07/Digit.hs</span>

<span class="ot">baseDigit ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
baseDigit base digit x
  <span class="fu">|</span> base <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  <span class="fu">|</span> digit <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> (flip mod) base <span class="fu">$</span> div x (base <span class="fu">^</span> digit)</code></pre></div>
<p>So that</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> baseDigit <span class="dv">10</span> <span class="dv">2</span> <span class="dv">1234</span>
<span class="dt">Just</span> <span class="dv">2</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> baseDigit <span class="dv">10</span> <span class="dv">2</span> <span class="dv">123456</span>
<span class="dt">Just</span> <span class="dv">4</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> baseDigit <span class="dv">10</span> <span class="dv">2</span> <span class="dv">9876543210</span>
<span class="dt">Just</span> <span class="dv">2</span>
<span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> </code></pre></div></li>
</ol></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 07/FoldBool.hs</span>

<span class="ot">foldBool ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a
foldBool x y b <span class="fu">=</span> <span class="kw">case</span> b <span class="kw">of</span>
   <span class="dt">True</span> <span class="ot">-&gt;</span> x
   <span class="dt">False</span> <span class="ot">-&gt;</span> y

<span class="ot">foldBool2 ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a
foldBool2 x y b
 <span class="fu">|</span> b <span class="fu">==</span> <span class="dt">True</span> <span class="fu">=</span> x
 <span class="fu">|</span> b <span class="fu">==</span> <span class="dt">False</span> <span class="fu">=</span> y</code></pre></div></li>
<li><p><code>g f (a, b) = (f a, b)</code></p></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 07/arith4.hs</span>

<span class="ot">roundTrip ::</span> (<span class="dt">Show</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
roundTrip a <span class="fu">=</span> read (show a)

<span class="ot">roundTripPF ::</span> (<span class="dt">Show</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
roundTripPF <span class="fu">=</span> (read <span class="fu">.</span> show)

<span class="ot">roundTrip2 ::</span> (<span class="dt">Show</span> a, <span class="dt">Read</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b
roundTrip2 a <span class="fu">=</span> read (show a)

main <span class="fu">=</span> <span class="kw">do</span>
  print (roundTrip2 (<span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Int</span>))
  print (id <span class="dv">4</span>)</code></pre></div></li>
</ol>
<h2 id="follow-up-resources-4">7.13 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p><a href="https://www.haskell.org/tutorial/patterns.html">Paul Hudak; John Peterson; Joseph Fasel. A Gentle Introduction to Haskell, chapter on case expressions and pattern matching.</a></p></li>
<li><p><a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm">Simon Peyton Jones. The Implementation of Functional Pro- gramming Languages, pages 53-103.</a></p></li>
<li><a href="http://www.cs.cmu.edu/~crary/819-f09/Strachey67.pdf">Christopher Strachey. Fundamental Concepts in Programming Languages, page 11 for explanation of currying.</a></li>
<li><a href="http://www.di.uminho.pt/~jno/ps/iscalc_1.ps.gz">J.N. Oliveira. An introduction to pointfree programming.</a></li>
<li><p><a href="http://www4.di.uminho.pt/~mac/Publications/phd.pdf">Manuel Alcino Pereira da Cunha. Point-free Program Calculation.</a></p></li>
</ol>
<hr />
<h1 id="recursion">8 Recursion</h1>
<h2 id="factorial">8.2 Factorial</h2>
<h2 id="intermission-exercise">Intermission: Exercise</h2>
<pre><code>applyTimes 5 (+1) 5</code></pre>
<p>turns into</p>
<pre><code>((+1) . (+1) . (+1) . (+1) . (+1)) 5</code></pre>
<h2 id="chapter-exercises-6">8.6 Chapter Exercises</h2>
<h3 id="review-of-types">Review of types</h3>
<ol style="list-style-type: decimal">
<li>d</li>
<li>b</li>
<li>d</li>
<li>b</li>
</ol>
<h3 id="reviewing-currying">Reviewing currying</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">flippy ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">appedCatty ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">frappe ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<ol style="list-style-type: decimal">
<li><code>&quot;woops mrow woohoo&quot;</code></li>
<li><code>&quot;1 mrow haha&quot;</code></li>
<li><code>&quot;woops mrow 2 mrow haha&quot;</code></li>
<li><code>&quot;woops mrow blue mrow haha&quot;</code></li>
<li><code>&quot;pink mrow haha mrow green mrow woops mrow blue&quot;</code></li>
<li><code>&quot;are mrow Pugs mrow awesome&quot;</code></li>
</ol>
<h3 id="recursion-1">Recursion</h3>
<ol style="list-style-type: decimal">
<li><pre><code>dividedBy 15 2 -&gt; 
go 15 2 0 -&gt; 
go 13 2 1 -&gt; 
go 11 2 2 -&gt; 
go 9 2 3 -&gt;
go 7 2 4 -&gt; 
go 5 2 5 -&gt; 
go 3 2 6 -&gt; 
go 1 2 7 -&gt; 
(7, 1)</code></pre></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 08/rsum.hs</span>
<span class="ot">rsum ::</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
rsum n <span class="fu">=</span> go n <span class="dv">0</span>
  <span class="kw">where</span> 
    go n c
     <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> c
     <span class="fu">|</span> otherwise <span class="fu">=</span> go (n <span class="fu">-</span> <span class="dv">1</span>) (c <span class="fu">+</span> n)</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 08/rmult.hs</span>
<span class="ot">rmult ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
rmult a b <span class="fu">=</span> go a b <span class="dv">0</span>
  <span class="kw">where</span> 
    go a b c
     <span class="fu">|</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> c
     <span class="fu">|</span> otherwise <span class="fu">=</span> go a (b <span class="fu">-</span> <span class="dv">1</span>) (c <span class="fu">+</span> a)</code></pre></div></li>
</ol>
<h3 id="fixing-dividedby">Fixing dividedBy:</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 08/DividedBy.hs</span>
<span class="kw">module</span> <span class="dt">DividedBy</span> <span class="kw">where</span>

<span class="ot">unsafeDividedBy ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)
unsafeDividedBy num denom <span class="fu">=</span> go num denom <span class="dv">0</span>
  <span class="kw">where</span> 
    go n d count
      <span class="fu">|</span> n <span class="fu">&lt;</span> d <span class="fu">=</span> (count, n)
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (n <span class="fu">-</span> d) d (count <span class="fu">+</span> <span class="dv">1</span>)

<span class="co">-- div throws an exception on zero</span>
<span class="ot">partialDividedBy ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)
partialDividedBy num denom <span class="fu">=</span> go num denom <span class="dv">0</span>
  <span class="kw">where</span> 
    go n d count
      <span class="fu">|</span> n <span class="fu">&lt;</span> d <span class="fu">=</span> (count, n)
      <span class="fu">|</span> d <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> go n (negate d) count
      <span class="fu">|</span> d <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> error <span class="fu">$</span> <span class="st">&quot;can't div by zero&quot;</span>
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (n <span class="fu">-</span> d) d (count <span class="fu">+</span> <span class="dv">1</span>)


<span class="kw">data</span> <span class="dt">DividedResult</span> <span class="fu">=</span> <span class="dt">Result</span> <span class="dt">Integer</span> <span class="fu">|</span> <span class="dt">DividedByZero</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="co">-- equivalent to Maybe Integer</span>

<span class="ot">dividedBy ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a<span class="ot">-&gt;</span> <span class="dt">DividedResult</span>
dividedBy num denom <span class="fu">=</span> go num denom <span class="dv">0</span>
  <span class="kw">where</span> 
    resNeg (<span class="dt">Result</span> x) <span class="fu">=</span> <span class="dt">Result</span> (negate x)
    go n d count
      <span class="fu">|</span> d <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">DividedByZero</span>
      <span class="fu">|</span> d <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> resNeg <span class="fu">$</span> go n (negate d) count 
      <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> resNeg <span class="fu">$</span> go (negate n) d count 
      <span class="fu">|</span> n <span class="fu">&lt;</span> d <span class="fu">=</span> <span class="dt">Result</span> count
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (n <span class="fu">-</span> d) d (count <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<h3 id="mccarthy-91-function">McCarthy 91 function:</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 08/mccarthy91.hs</span>
<span class="ot">mc91 ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
mc91 n
  <span class="fu">|</span> n <span class="fu">&gt;</span> <span class="dv">100</span> <span class="fu">=</span> n <span class="fu">-</span> <span class="dv">10</span> 
  <span class="fu">|</span> otherwise <span class="fu">=</span> (mc91 <span class="fu">.</span> mc91) (n <span class="fu">+</span> <span class="dv">11</span>)</code></pre></div>
<h3 id="numbers-into-words">Numbers into Words:</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 08/WordNumber.hs</span>
<span class="kw">module</span> <span class="dt">WordNumber</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.List</span> (intersperse)

<span class="ot">digitToWord ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
digitToWord x <span class="fu">=</span> 
  <span class="kw">case</span> x <span class="kw">of</span> 
    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="st">&quot;one&quot;</span>
    <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="st">&quot;two&quot;</span>
    <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="st">&quot;three&quot;</span>
    <span class="dv">4</span> <span class="ot">-&gt;</span> <span class="st">&quot;four&quot;</span>
    <span class="dv">5</span> <span class="ot">-&gt;</span> <span class="st">&quot;five&quot;</span>
    <span class="dv">6</span> <span class="ot">-&gt;</span> <span class="st">&quot;six&quot;</span>
    <span class="dv">7</span> <span class="ot">-&gt;</span> <span class="st">&quot;seven&quot;</span>
    <span class="dv">8</span> <span class="ot">-&gt;</span> <span class="st">&quot;eight&quot;</span>
    <span class="dv">9</span> <span class="ot">-&gt;</span> <span class="st">&quot;nine&quot;</span>
    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="st">&quot;zero&quot;</span>
    _ <span class="ot">-&gt;</span> <span class="st">&quot;NaD&quot;</span>

<span class="ot">digits ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
digits n <span class="fu">=</span> go n []
  <span class="kw">where</span> go n d
          <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">10</span> <span class="fu">=</span> n<span class="fu">:</span>d
          <span class="fu">|</span> n <span class="fu">&gt;=</span> <span class="dv">10</span> <span class="fu">=</span> go (n <span class="ot">`div`</span> <span class="dv">10</span>) <span class="fu">$</span> (n <span class="ot">`mod`</span> <span class="dv">10</span>)<span class="fu">:</span>d
          
<span class="ot">wordNumber ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
wordNumber n <span class="fu">=</span> concat <span class="fu">$</span> intersperse <span class="st">&quot;-&quot;</span> <span class="fu">$</span> map digitToWord <span class="fu">$</span> digits n</code></pre></div>
<hr />
<h1 id="lists-1">9 Lists</h1>
<h2 id="using-ranges-to-construct-lists">9.5 Using ranges to construct lists</h2>
<h3 id="exercise-enumfromto">Exercise: EnumFromTo</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--09/EnumFromTo.hs</span>

<span class="kw">module</span> <span class="dt">EnumFromTo</span> <span class="kw">where</span>

<span class="co">-- the exercises for specific types</span>

<span class="ot">eftBool::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [<span class="dt">Bool</span>]
eftBool x y <span class="fu">=</span> go x y []
  <span class="kw">where</span> 
    go a b c
      <span class="fu">|</span> a <span class="fu">&gt;</span> b <span class="fu">=</span> c
      <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> reverse (a <span class="fu">:</span> c)
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (succ a) b (a <span class="fu">:</span> c)

<span class="ot">eftInt::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
eftInt x y <span class="fu">=</span> go x y []
  <span class="kw">where</span> 
    go a b c
      <span class="fu">|</span> a <span class="fu">&gt;</span> b <span class="fu">=</span> c
      <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> reverse (a <span class="fu">:</span> c)
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (succ a) b (a <span class="fu">:</span> c)

<span class="ot">eftOrd::</span> <span class="dt">Ordering</span> <span class="ot">-&gt;</span> <span class="dt">Ordering</span> <span class="ot">-&gt;</span> [<span class="dt">Ordering</span>]
eftOrd x y <span class="fu">=</span> go x y []
  <span class="kw">where</span> 
    go a b c
      <span class="fu">|</span> a <span class="fu">&gt;</span> b <span class="fu">=</span> c
      <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> reverse (a <span class="fu">:</span> c)
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (succ a) b (a <span class="fu">:</span> c)

<span class="ot">eftChar::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> [<span class="dt">Char</span>]
eftChar x y <span class="fu">=</span> go x y []
  <span class="kw">where</span> 
    go a b c
      <span class="fu">|</span> a <span class="fu">&gt;</span> b <span class="fu">=</span> c
      <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> reverse (a <span class="fu">:</span> c)
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (succ a) b (a <span class="fu">:</span> c)

<span class="co">-- these all look basically the same, so let's generalize:</span>

<span class="ot">eft ::</span> (<span class="dt">Ord</span> a, <span class="dt">Enum</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
eft x y <span class="fu">=</span> go x y []
  <span class="kw">where</span> 
    go a b c
      <span class="fu">|</span> a <span class="fu">&gt;</span> b <span class="fu">=</span> c
      <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> reverse (a <span class="fu">:</span> c)
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (succ a) b (a <span class="fu">:</span> c)

<span class="co">-- that reverse is clunky though, let's see if we can get rid of it</span>

<span class="ot">eft2 ::</span> (<span class="dt">Ord</span> a, <span class="dt">Enum</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
eft2 x y <span class="fu">=</span> go x y []
  <span class="kw">where</span> 
    go a b c
      <span class="fu">|</span> a <span class="fu">&gt;</span> b <span class="fu">=</span> c
      <span class="fu">|</span> a <span class="fu">==</span> b <span class="fu">=</span> c <span class="fu">++</span> a<span class="fu">:</span>[]
      <span class="fu">|</span> otherwise <span class="fu">=</span> go (succ a) b (c <span class="fu">++</span> a<span class="fu">:</span>[])

<span class="co">-- using string concatenation is just as slow though, let's use recursion</span>

<span class="ot">eft3 ::</span> (<span class="dt">Ord</span> a, <span class="dt">Enum</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
eft3 x y
  <span class="fu">|</span> x <span class="fu">&gt;</span> y <span class="fu">=</span> []
  <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> [x]
  <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> eft3 (succ x) y

<span class="co">-- We can get rid of the Ord constraint by leveraging the mapping between</span>
<span class="co">-- an Enum and Int</span>

<span class="ot">eft4 ::</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
eft4 x y
  <span class="fu">|</span> fromEnum x <span class="fu">&gt;</span> fromEnum y <span class="fu">=</span> []
  <span class="fu">|</span> fromEnum x <span class="fu">==</span> fromEnum y <span class="fu">=</span> [x]
  <span class="fu">|</span> otherwise <span class="fu">=</span> x <span class="fu">:</span> eft4 (succ x) y</code></pre></div>
<h2 id="extracting-portions-of-lists">9.6 Extracting portions of lists</h2>
<h3 id="exercises-thy-fearful-symmetry">Exercises: Thy Fearful Symmetry</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--09/FearfulSymmetry.hs</span>
<span class="kw">module</span> <span class="dt">FearfulSymmetry</span> <span class="kw">where</span>

<span class="ot">split ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
split [] <span class="fu">=</span> []
split  x <span class="fu">=</span> word <span class="fu">:</span> split rest
  <span class="kw">where</span> 
    word <span class="fu">=</span> takeWhile (<span class="fu">/=</span> <span class="ch">' '</span>) x
    rest <span class="fu">=</span> (drop <span class="dv">1</span>) <span class="fu">$</span> dropWhile (<span class="fu">/=</span> <span class="ch">' '</span>) x

<span class="ot">splitOn ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
splitOn _ [] <span class="fu">=</span> []
splitOn  c str <span class="fu">=</span> part <span class="fu">:</span> (splitOn c rest)
  <span class="kw">where</span> 
    part <span class="fu">=</span> takeWhile (<span class="fu">/=</span> c) str
    rest <span class="fu">=</span> (drop <span class="dv">1</span>) <span class="fu">$</span> dropWhile (<span class="fu">/=</span> c) str

firstSen <span class="fu">=</span> <span class="st">&quot;Tyger Tyger, burning bright\n&quot;</span>
secondSen <span class="fu">=</span> <span class="st">&quot;In the forests of the night\n&quot;</span>
thirdSen <span class="fu">=</span> <span class="st">&quot;What immortal hand or eye\n&quot;</span>
fourthSen <span class="fu">=</span> <span class="st">&quot;Could frame thy fearful symmetry?&quot;</span>
sentences <span class="fu">=</span> firstSen <span class="fu">++</span> secondSen <span class="fu">++</span> thirdSen <span class="fu">++</span> fourthSen

<span class="ot">myLines ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
myLines x <span class="fu">=</span> splitOn <span class="ch">'\n'</span> x

shouldEqual <span class="fu">=</span> 
  [ <span class="st">&quot;Tyger Tyger, burning bright&quot;</span>
  , <span class="st">&quot;In the forests of the night&quot;</span>
  , <span class="st">&quot;What immortal hand or eye&quot;</span>
  , <span class="st">&quot;Could frame thy fearful symmetry?&quot;</span>
  ]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> print <span class="fu">$</span> <span class="st">&quot;Are they equal? &quot;</span> <span class="fu">++</span> show (myLines sentences <span class="fu">==</span> shouldEqual)</code></pre></div>
<h2 id="list-comprehensions">9.7 List Comprehensions</h2>
<h3 id="exercises-comprehend-thy-lists">Exercises: Comprehend Thy Lists</h3>
<ol style="list-style-type: decimal">
<li><code>[4, 16]</code></li>
<li><code>[]</code></li>
<li><code>[]</code>, unless <code>mySqr</code> is from <code>[1..10]</code></li>
</ol>
<h3 id="exercises-square-cube">Exercises: Square Cube</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--09/SquareCube.hs</span>
<span class="kw">module</span> <span class="dt">SquareCube</span> <span class="kw">where</span>

mySqr <span class="fu">=</span> [x<span class="fu">^</span><span class="dv">2</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]]
myCube <span class="fu">=</span> [x<span class="fu">^</span><span class="dv">3</span> <span class="fu">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]]

exercise1 <span class="fu">=</span> [(x, y) <span class="fu">|</span> x <span class="ot">&lt;-</span> mySqr, y <span class="ot">&lt;-</span> myCube]
exercise2 <span class="fu">=</span> [(x, y) <span class="fu">|</span> x <span class="ot">&lt;-</span> mySqr, y <span class="ot">&lt;-</span> myCube, x <span class="fu">&lt;</span> <span class="dv">50</span>, y <span class="fu">&lt;</span> <span class="dv">50</span>]
exercise3 <span class="fu">=</span> length exercise2</code></pre></div>
<h2 id="spines-and-nonstrict-evaluation">9.8 Spines and nonstrict evaluation</h2>
<h3 id="exercises-bottom-madness">Exercises: Bottom Madness</h3>
<ol style="list-style-type: decimal">
<li>no</li>
<li>yes</li>
<li>no</li>
<li>yes</li>
<li>no</li>
<li>yes</li>
<li>no</li>
<li>yes</li>
<li>yes</li>
<li>no</li>
</ol>
<h3 id="intermission-is-it-in-normal-form">Intermission: Is it in normal form?</h3>
<ol style="list-style-type: decimal">
<li>WHNF &amp; NF</li>
<li>WHNF</li>
<li>neither</li>
<li>neither</li>
<li>neither</li>
<li>neither</li>
<li>WHNF</li>
</ol>
<h2 id="transforming-lists">9.9 Transforming lists</h2>
<h3 id="exercises-more-bottoms">Exercises: More Bottoms</h3>
<ol style="list-style-type: decimal">
<li>bottom</li>
<li>yes</li>
<li>bottom</li>
<li>Is this character a vowel? <code>itIsMystery :: Char -&gt; Bool</code></li>
<li><ol style="list-style-type: lower-alpha">
<li>the first 10 square numbers</li>
<li><code>[1, 10, 20]</code></li>
<li><code>[15, 15, 15]</code></li>
</ol></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--09/foldbool.hs</span>
foldBool <span class="fu">=</span> map (\x <span class="ot">-&gt;</span> (Data.Bool.bool x (<span class="fu">-</span>x) (x <span class="fu">==</span> <span class="dv">3</span>)))</code></pre></div></li>
</ol>
<h2 id="filtering-lists-of-values">9.10 Filtering lists of values</h2>
<h3 id="exercises-filtering">Exercises: Filtering</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 09/Filtering.hs</span>
<span class="kw">module</span> <span class="dt">Filtering</span> <span class="kw">where</span>

<span class="ot">filterThreeMult ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
filterThreeMult <span class="fu">=</span> filter (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">/=</span> <span class="dv">0</span>)

<span class="ot">howManyThreeMults ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
howManyThreeMults x <span class="fu">=</span> length x <span class="fu">-</span> (length <span class="fu">.</span> filterThreeMult) x

<span class="ot">howManyThreeMults' ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
howManyThreeMults' <span class="fu">=</span> length <span class="fu">.</span> filter (\x <span class="ot">-&gt;</span> x <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span>)

<span class="ot">removeArticle ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
removeArticle <span class="fu">=</span> filter (not <span class="fu">.</span> isArticle) <span class="fu">.</span> words  
  <span class="kw">where</span> isArticle x <span class="fu">=</span> elem x [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;an&quot;</span>, <span class="st">&quot;the&quot;</span>] </code></pre></div>
<h3 id="zipping-exercises">Zipping exercises</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 09/ZippingExercises.hs</span>
<span class="kw">module</span> <span class="dt">ZippingExercises</span> <span class="kw">where</span>

<span class="ot">myZip ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]
myZip (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (x, y) <span class="fu">:</span> myZip xs ys
myZip _ _ <span class="fu">=</span> []

<span class="ot">myZipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]
myZipWith f (x<span class="fu">:</span>xs) (y<span class="fu">:</span>ys) <span class="fu">=</span> (f x y) <span class="fu">:</span> (myZipWith f xs ys)
myZipWith _ _ _ <span class="fu">=</span> []</code></pre></div>
<h2 id="chapter-exercises-7">9.12 Chapter Exercises</h2>
<h3 id="data.char">Data.Char</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--09/CharExercises.hs</span>
<span class="kw">module</span> <span class="dt">CharExercises</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="co">--1</span>
<span class="co">-- isUpper :: Char -&gt; Bool</span>
<span class="co">-- toUpper :: Char -&gt; Char</span>

<span class="co">-- 2 </span>
filterUpper <span class="fu">=</span> filter isUpper

<span class="co">-- 3 </span>
<span class="ot">capFirst ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
capFirst (x<span class="fu">:</span>xs) <span class="fu">=</span> (toUpper x)<span class="fu">:</span>xs
capFirst _ <span class="fu">=</span> <span class="st">&quot;&quot;</span> 

<span class="co">-- 4</span>
<span class="ot">strToUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
strToUpper (x<span class="fu">:</span>xs) <span class="fu">=</span> (toUpper x)<span class="fu">:</span>(strToUpper xs)
strToUpper _ <span class="fu">=</span> <span class="st">&quot;&quot;</span> 

<span class="co">-- 5 </span>
<span class="ot">headToUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
headToUpper <span class="fu">=</span> toUpper <span class="fu">.</span> head

<span class="co">-- 6, wrote it pointfree the first time...</span></code></pre></div>
<h3 id="ciphers">Ciphers</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--09/Cipher.hs</span>
<span class="kw">module</span> <span class="dt">Cipher</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="ot">caesar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
caesar key string <span class="fu">=</span> go key <span class="fu">$</span> (map toLower <span class="fu">.</span> filter isAlpha) string
  <span class="kw">where</span> go _ <span class="st">&quot;&quot;</span> <span class="fu">=</span> <span class="st">&quot;&quot;</span>
        go n (c<span class="fu">:</span>cs) <span class="fu">=</span> chr ((ord c <span class="fu">+</span> n <span class="fu">-</span> ord <span class="ch">'a'</span>) <span class="ot">`mod`</span> <span class="dv">26</span> <span class="fu">+</span> ord <span class="ch">'a'</span>) <span class="fu">:</span> go n cs

<span class="ot">unCaesar ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
unCaesar key string <span class="fu">=</span> caesar (negate key) string 

<span class="ot">test ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
test n s <span class="fu">=</span> (map toLower <span class="fu">.</span> filter isAlpha) s <span class="fu">==</span> (unCaesar n <span class="fu">.</span> caesar n) s </code></pre></div>
<h3 id="writing-your-own-standard-functions">Writing your own standard functions</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--09/StdFunc.hs</span>
<span class="kw">module</span> <span class="dt">StdFunc</span> <span class="kw">where</span>

<span class="co">-- 1</span>
<span class="ot">myOr ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myOr [] <span class="fu">=</span> <span class="dt">False</span>
myOr (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> <span class="dt">True</span> <span class="kw">then</span> <span class="dt">True</span> <span class="kw">else</span> myOr xs

<span class="co">-- 2</span>
<span class="ot">myAny ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myAny f xs <span class="fu">=</span> (myOr <span class="fu">.</span> map f) xs

<span class="co">-- 3</span>
<span class="ot">myElem ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myElem x xs <span class="fu">=</span> myAny ((<span class="fu">==</span>) x) xs

<span class="co">-- 4</span>
<span class="ot">myReverse ::</span> [a] <span class="ot">-&gt;</span> [a]
myReverse xs <span class="fu">=</span> go xs []
  <span class="kw">where</span> go [] n <span class="fu">=</span> n
        go (n<span class="fu">:</span>ns) a <span class="fu">=</span> go ns (n<span class="fu">:</span>a)

<span class="co">-- 5</span>
<span class="ot">squish ::</span> [[a]] <span class="ot">-&gt;</span> [a]
squish [] <span class="fu">=</span> []
squish ((n<span class="fu">:</span>[])<span class="fu">:</span>nss) <span class="fu">=</span> n <span class="fu">:</span> squish (nss)
squish ((n<span class="fu">:</span>ns)<span class="fu">:</span>nss) <span class="fu">=</span> n <span class="fu">:</span> squish (ns<span class="fu">:</span>nss)

<span class="co">-- 6 </span>
<span class="ot">squishMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
squishMap f xs <span class="fu">=</span> go f xs []
  <span class="kw">where</span> go _ [] [] <span class="fu">=</span> []
        go f (x<span class="fu">:</span>xs) [] <span class="fu">=</span> go f xs (f x)
        go f xs (a<span class="fu">:</span>as) <span class="fu">=</span> a <span class="fu">:</span> (go f xs as)

<span class="co">-- 7</span>
<span class="ot">squishAgain ::</span> [[a]] <span class="ot">-&gt;</span> [a]
squishAgain <span class="fu">=</span> squishMap id

<span class="co">-- 8 </span>
<span class="ot">myMaximumBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
myMaximumBy cmp (x<span class="fu">:</span>xs) <span class="fu">=</span> go cmp xs x
  <span class="kw">where</span> go _ [] a <span class="fu">=</span> a
        go cmp (x<span class="fu">:</span>xs) a <span class="fu">=</span> go cmp xs (<span class="kw">if</span> (cmp x a) <span class="fu">==</span> <span class="dt">GT</span> <span class="kw">then</span> x <span class="kw">else</span> a)

<span class="co">-- 9</span>
<span class="ot">myMinimumBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
myMinimumBy cmp (x<span class="fu">:</span>xs) <span class="fu">=</span> go cmp xs x
  <span class="kw">where</span> go _ [] a <span class="fu">=</span> a
        go cmp (x<span class="fu">:</span>xs) a <span class="fu">=</span> go cmp xs (<span class="kw">if</span> (cmp x a) <span class="fu">==</span> <span class="dt">LT</span> <span class="kw">then</span> x <span class="kw">else</span> a)


<span class="ot">myMaximum ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
myMaximum <span class="fu">=</span> myMaximumBy compare

<span class="ot">myMinimum ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
myMinimum <span class="fu">=</span> myMinimumBy compare</code></pre></div>
<h2 id="follow-up-resources-5">9.14 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p><a href="http://hackage.haskell.org/package/base/docs/Data-List.html">Data.List documentation for the base library.</a></p></li>
<li><p><a href="https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems">Ninety-nine Haskell problems.</a></p></li>
</ol>
<hr />
<h1 id="folding-lists">10 Folding lists</h1>
<p>Okay, so here’s the thing about the term “catamorphism”:</p>
<p>“Kata” in Greek means “down”. The opposite of “kata” is “ana” which means “up”.</p>
<p>So we have “catamorphisms” and “anamorphisms”. Remember that “morph” means “form”, so a “catamorphism” is a “down-form thing” and an “anamorphism” is an “up-form thing”.</p>
<p>But what the heck do “up” and “down” have to do with “forms”. There’s a metaphor that recurs (heh) again and again in functional programming between height and complexity: Things that have more structure or are more complex are upwards and things that are simpler are downwards.</p>
<p>So an <code>Integer</code> is pretty simple, and is downwards of <code>[Integer]</code> or <code>Maybe Integer</code> or <code>Map String Integer</code>.</p>
<p>Functions that go “upwards” in this complexity-space, like from <code>Integer -&gt; [Integer]</code> are, roughly speaking, anamorphisms. Functions that go “downwards” are catamorphisms.</p>
<h2 id="fold-right">10.4 Fold right</h2>
<h3 id="exercises-understanding-folds">Exercises: Understanding folds</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Folds</span> <span class="kw">where</span>

<span class="co">-- 1: </span>
one <span class="fu">=</span> (<span class="fu">==</span>) (foldr (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]) (foldl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>])

<span class="co">-- 2</span>
two <span class="fu">=</span> scanl (flip (<span class="fu">*</span>)) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>]

<span class="co">--3: c</span>

<span class="co">--4: reduce structure</span>

<span class="co">--5</span>
fiveA <span class="fu">=</span> foldr (<span class="fu">++</span>) <span class="st">&quot;&quot;</span> [<span class="st">&quot;woot&quot;</span>, <span class="st">&quot;WOOT&quot;</span>, <span class="st">&quot;woot&quot;</span>]
fiveB <span class="fu">=</span> foldr max <span class="ch">'a'</span> <span class="st">&quot;fear is the little death&quot;</span>
fiveC <span class="fu">=</span> foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> [<span class="dt">False</span>, <span class="dt">True</span>]
fiveD <span class="fu">=</span> foldr (<span class="fu">||</span>) <span class="dt">True</span> [<span class="dt">False</span>, <span class="dt">True</span>]
fiveE <span class="fu">=</span> foldr ((<span class="fu">++</span>) <span class="fu">.</span> show) <span class="st">&quot;&quot;</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]
fiveF <span class="fu">=</span> foldl const <span class="ch">'a'</span>  [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]
fiveG <span class="fu">=</span> foldl const <span class="dv">0</span> <span class="st">&quot;tacos&quot;</span>
fiveH <span class="fu">=</span> foldr (flip const) <span class="dv">0</span> <span class="st">&quot;burritos&quot;</span>
fiveI <span class="fu">=</span> foldr (flip const) <span class="ch">'z'</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]</code></pre></div>
<h3 id="exercises-database-processing">Exercises: Database Processing</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">DatabaseProcessing</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Time</span>

<span class="kw">data</span> <span class="dt">DatabaseItem</span> <span class="fu">=</span> <span class="dt">DbString</span> <span class="dt">String</span>
                  <span class="fu">|</span> <span class="dt">DbNumber</span> <span class="dt">Integer</span>
                  <span class="fu">|</span> <span class="dt">DbDate</span>   <span class="dt">UTCTime</span>
                  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)

<span class="ot">theDatabase ::</span> [<span class="dt">DatabaseItem</span>]
theDatabase <span class="fu">=</span> 
  [ <span class="dt">DbDate</span> (<span class="dt">UTCTime</span>
            (fromGregorian <span class="dv">1911</span> <span class="dv">5</span> <span class="dv">1</span>)
            (secondsToDiffTime <span class="dv">34123</span>))
  , <span class="dt">DbNumber</span> <span class="dv">9001</span>
  , <span class="dt">DbString</span> <span class="st">&quot;Hello, World!&quot;</span>
  , <span class="dt">DbDate</span> (<span class="dt">UTCTime</span>
            (fromGregorian <span class="dv">1921</span> <span class="dv">5</span> <span class="dv">1</span>)
            (secondsToDiffTime <span class="dv">34123</span>))
  ]

<span class="co">-- 1 </span>
<span class="ot">filterDbDate ::</span> [<span class="dt">DatabaseItem</span>] <span class="ot">-&gt;</span> [<span class="dt">UTCTime</span>]
filterDbDate <span class="fu">=</span> map unpack <span class="fu">.</span> filter isADbDate <span class="kw">where</span>
  isADbDate (<span class="dt">DbDate</span> _) <span class="fu">=</span> <span class="dt">True</span>
  isADbDate _ <span class="fu">=</span> <span class="dt">False</span>
  unpack (<span class="dt">DbDate</span> utc) <span class="fu">=</span> utc

<span class="ot">filterDbDate2 ::</span> [<span class="dt">DatabaseItem</span>] <span class="ot">-&gt;</span> [<span class="dt">UTCTime</span>]
filterDbDate2 <span class="fu">=</span> foldr unpackDate [] <span class="kw">where</span>
  unpackDate (<span class="dt">DbDate</span> utc) acc <span class="fu">=</span> utc <span class="fu">:</span> acc
  unpackDate _ acc <span class="fu">=</span> acc

<span class="co">-- 2</span>
<span class="ot">filterDbNumber ::</span> [<span class="dt">DatabaseItem</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
filterDbNumber <span class="fu">=</span> foldr unpackNum [] <span class="kw">where</span>
  unpackNum (<span class="dt">DbNumber</span> num) acc <span class="fu">=</span> num <span class="fu">:</span> acc
  unpackNum _ acc <span class="fu">=</span> acc

<span class="co">-- 3 </span>
<span class="ot">mostRecent ::</span> [<span class="dt">DatabaseItem</span>] <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>
mostRecent db <span class="fu">=</span> foldr compareDate base db <span class="kw">where</span>
  compareDate (<span class="dt">DbDate</span> utc) acc <span class="fu">=</span> max utc acc  
  compareDate _ acc <span class="fu">=</span> acc
  base <span class="fu">=</span> (filterDbDate2 db) <span class="fu">!!</span> <span class="dv">0</span>

<span class="co">-- 4 </span>
<span class="ot">sumDb ::</span> [<span class="dt">DatabaseItem</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span>
sumDb <span class="fu">=</span> foldr addNum <span class="dv">0</span> <span class="kw">where</span>
  addNum (<span class="dt">DbNumber</span> int) acc <span class="fu">=</span> int <span class="fu">+</span> acc
  addNum _ acc <span class="fu">=</span> acc

<span class="co">-- 5</span>
<span class="ot">avgDb ::</span> [<span class="dt">DatabaseItem</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span> 
avgDb db <span class="fu">=</span> (fromIntegral <span class="fu">$</span> fst tup) <span class="fu">/</span> (fromIntegral <span class="fu">$</span> snd tup) <span class="kw">where</span>
  tup <span class="fu">=</span> foldr addNum (<span class="dv">0</span>,<span class="dv">0</span>) db
  addNum (<span class="dt">DbNumber</span> int) (num,den) <span class="fu">=</span> (int <span class="fu">+</span> num, den <span class="fu">+</span> <span class="dv">1</span>)
  addNum _ acc <span class="fu">=</span> acc

<span class="ot">avgDb2 ::</span> [<span class="dt">DatabaseItem</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span>
avgDb2 db <span class="fu">=</span> n <span class="fu">/</span> d <span class="kw">where</span>
  n <span class="fu">=</span> (fromIntegral <span class="fu">$</span> sumDb db) 
  d <span class="fu">=</span> (fromIntegral <span class="fu">$</span> length <span class="fu">$</span> filterDbNumber db)</code></pre></div>
<h2 id="scans">10.9 Scans</h2>
<h3 id="scans-exercises">Scans Exercises</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Scans</span> <span class="kw">where</span>

fibs <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> scanl (<span class="fu">+</span>) <span class="dv">1</span> fibs
fibsN x <span class="fu">=</span> fibs <span class="fu">!!</span> x

<span class="co">--1</span>
fibsToN n <span class="fu">=</span> take n <span class="fu">$</span> fibs

<span class="co">--2</span>
fibsLessThan n <span class="fu">=</span> takeWhile (<span class="fu">&lt;</span> n) fibs

<span class="co">--3</span>
factorials <span class="fu">=</span> <span class="dv">1</span> <span class="fu">:</span> scanl ratio <span class="dv">1</span> factorials
  <span class="kw">where</span> ratio m n <span class="fu">=</span> (m <span class="ot">`div`</span> n <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">*</span> m

factorials2 <span class="fu">=</span> scanl (<span class="fu">*</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]
lazyCaterers <span class="fu">=</span> scanl (<span class="fu">+</span>) <span class="dv">1</span> [<span class="dv">1</span><span class="fu">..</span>]</code></pre></div>
<h2 id="chapter-exercises-8">10.10 Chapter Exercises</h2>
<h3 id="warm-up-and-reveiw">Warm-up and reveiw</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--10/WarmUp.hs</span>
<span class="kw">module</span> <span class="dt">WarmUp</span> <span class="kw">where</span>

<span class="co">-- 1</span>
stops <span class="fu">=</span> <span class="st">&quot;pbtdkg&quot;</span>
vowels <span class="fu">=</span> <span class="st">&quot;aeiou&quot;</span>

<span class="co">-- 1a</span>
stopVowelStop <span class="fu">=</span> [(a, b, c) <span class="fu">|</span> a <span class="ot">&lt;-</span> stops, b <span class="ot">&lt;-</span> vowels, c <span class="ot">&lt;-</span> stops]

<span class="co">-- 1b</span>
pVowelStop <span class="fu">=</span> [(<span class="ch">'p'</span>, b, c) <span class="fu">|</span> b <span class="ot">&lt;-</span> vowels, c <span class="ot">&lt;-</span> stops]

<span class="co">-- 1c</span>
nouns <span class="fu">=</span> [<span class="st">&quot;cat&quot;</span>, <span class="st">&quot;dog&quot;</span>, <span class="st">&quot;ball&quot;</span>, <span class="st">&quot;box&quot;</span>]
verbs <span class="fu">=</span> [<span class="st">&quot;throws&quot;</span>, <span class="st">&quot;catches&quot;</span>, <span class="st">&quot;jumps&quot;</span>, <span class="st">&quot;fetches&quot;</span>]

nounVerbNoun <span class="fu">=</span>   [(a, b, c) <span class="fu">|</span> a <span class="ot">&lt;-</span> nouns, b <span class="ot">&lt;-</span> verbs, c <span class="ot">&lt;-</span> nouns]

<span class="co">-- 2</span>
seekritFunc x <span class="fu">=</span> div (sum (map length (words x))) (length (words x))

<span class="co">-- function is average word length</span>
<span class="ot">avgWordLength ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
avgWordLength x <span class="fu">=</span> div totalWordLengths numberOfWords 
  <span class="kw">where</span>
    wordList <span class="fu">=</span> words x
    numberOfWords <span class="fu">=</span> length wordList 
    wordLengths <span class="fu">=</span> map length wordList
    totalWordLengths <span class="fu">=</span> sum wordLengths

<span class="co">-- 3</span>
<span class="ot">preciseAvgWordLength ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
preciseAvgWordLength x <span class="fu">=</span> totalWordLength <span class="fu">/</span> numberOfWords
  <span class="kw">where</span> 
    totalWordLength <span class="fu">=</span> fromIntegral <span class="fu">$</span> sum <span class="fu">$</span> map length <span class="fu">$</span> words x
    numberOfWords   <span class="fu">=</span> fromIntegral <span class="fu">$</span> length <span class="fu">$</span> words x</code></pre></div>
<h3 id="rewriting-functions-using-folds">Rewriting functions using folds</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--10/FunctionsUsingFolds.hs</span>
<span class="kw">module</span> <span class="dt">FunctionsUsingFolds</span> <span class="kw">where</span>

<span class="ot">myAnd ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myAnd <span class="fu">=</span> foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span>

<span class="co">-- 1 </span>
<span class="ot">myOr ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myOr <span class="fu">=</span> foldr (<span class="fu">||</span>) <span class="dt">False</span>

<span class="co">-- 2</span>
<span class="ot">myAny ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myAny f x <span class="fu">=</span> foldl check <span class="dt">False</span> x <span class="kw">where</span>
  check x y <span class="fu">=</span> x <span class="fu">||</span> f y 

<span class="co">-- 3 </span>

<span class="ot">myElem ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
myElem x xs <span class="fu">=</span> myAny ((<span class="fu">==</span>) x) xs

<span class="co">-- 4</span>
<span class="ot">myReverse ::</span> [a] <span class="ot">-&gt;</span> [a]
myReverse <span class="fu">=</span> foldl (flip (<span class="fu">:</span>)) []

<span class="co">-- 5</span>
<span class="ot">myMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
myMap f xs <span class="fu">=</span> foldr ((<span class="fu">:</span>) <span class="fu">.</span> f) [] xs

<span class="co">-- 6 </span>
<span class="ot">myFilter ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
myFilter f xs <span class="fu">=</span>  foldr g [] xs <span class="kw">where</span>
  g x y <span class="fu">=</span> <span class="kw">if</span> (f x) <span class="kw">then</span> (x <span class="fu">:</span> y) <span class="kw">else</span> y

<span class="co">-- 7 </span>
<span class="ot">squish ::</span> [[a]] <span class="ot">-&gt;</span> [a] 
squish <span class="fu">=</span> foldr (<span class="fu">++</span>) []

<span class="co">-- 8</span>
<span class="ot">squishMap ::</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
squishMap f <span class="fu">=</span> foldr ((<span class="fu">++</span>) <span class="fu">.</span> f) []

<span class="co">-- 9</span>
<span class="ot">squishAgain ::</span> [[a]] <span class="ot">-&gt;</span> [a]
squishAgain <span class="fu">=</span> squishMap id 

<span class="co">-- 10</span>
<span class="ot">myMaximumBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
myMaximumBy ord xs <span class="fu">=</span> foldr1 g xs
  <span class="kw">where</span> g x y <span class="fu">=</span> <span class="kw">if</span> (ord x y) <span class="fu">==</span> <span class="dt">GT</span> <span class="kw">then</span> x <span class="kw">else</span> y

<span class="co">-- 11</span>
<span class="ot">myMinimumBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
myMinimumBy ord xs <span class="fu">=</span> foldr1 g xs
  <span class="kw">where</span> g x y <span class="fu">=</span> <span class="kw">if</span> (ord x y) <span class="fu">==</span> <span class="dt">LT</span> <span class="kw">then</span> x <span class="kw">else</span> y</code></pre></div>
<h2 id="follow-up-resources-6">10.12 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p><a href="https://wiki.haskell.org/Fold">Haskell Wiki. Fold.</a></p></li>
<li><p><a href="Programming%20using%20Haskell%20(1998).">Richard Bird. Sections 4.5 and 4.6 of Introduction to Functional</a></p></li>
<li><p>Antoni Diller. Introduction to Haskell.</p></li>
<li><p><a href="http://www.cs.nott.ac.uk/~gmh/fold.pdf">Graham Hutton. A tutorial on the universality and expressive- ness of fold.</a></p></li>
</ol>
<hr />
<h1 id="algebraic-datatypes">11 Algebraic Datatypes</h1>
<h2 id="data-constructors-and-values">11.5 Data constructors and values</h2>
<h3 id="exercises-dog-types">Exercises: Dog Types</h3>
<ol style="list-style-type: decimal">
<li>type constructor</li>
<li><code>* -&gt; *</code></li>
<li><code>*</code></li>
<li><code>Num a =&gt; Doggies a</code></li>
<li><code>Doggies Integer</code></li>
<li><code>Doggies String</code></li>
<li><code>data constructor (both?)</code></li>
<li><code>a -&gt; DogueDeBordeaux a</code></li>
<li><code>DogueDeBordeaux String</code></li>
</ol>
<h2 id="whats-a-type-and-whats-data">11.6 What’s a type and what’s data?</h2>
<h3 id="exercises-vehicles">Exercises: Vehicles</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/Vehicles.hs</span>
<span class="kw">module</span> <span class="dt">Vehicles</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">Price</span> <span class="fu">=</span> <span class="dt">Price</span> <span class="dt">Integer</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">Manufacturer</span> <span class="fu">=</span> <span class="dt">Mini</span> <span class="fu">|</span> <span class="dt">Mazda</span> <span class="fu">|</span> <span class="dt">Tata</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">Size</span> <span class="fu">=</span> <span class="dt">Small</span> <span class="fu">|</span> <span class="dt">Medium</span> <span class="fu">|</span> <span class="dt">Large</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">Airline</span> <span class="fu">=</span> <span class="dt">PapuAir</span> 
             <span class="fu">|</span> <span class="dt">CatapultsR'Us</span> 
             <span class="fu">|</span> <span class="dt">TakeYourChancesUnited</span> 
             <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Vehicle</span> <span class="fu">=</span> <span class="dt">Car</span> <span class="dt">Manufacturer</span> <span class="dt">Price</span> 
             <span class="fu">|</span> <span class="dt">Plane</span> <span class="dt">Airline</span> <span class="dt">Size</span>
             <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

myCar <span class="fu">=</span> <span class="dt">Car</span> <span class="dt">Mini</span> (<span class="dt">Price</span> <span class="dv">14000</span>)
urCar <span class="fu">=</span> <span class="dt">Car</span> <span class="dt">Mazda</span> (<span class="dt">Price</span> <span class="dv">20000</span>)
clownCar <span class="fu">=</span> <span class="dt">Car</span> <span class="dt">Tata</span> (<span class="dt">Price</span> <span class="dv">7000</span>)
doge <span class="fu">=</span> <span class="dt">Plane</span> <span class="dt">PapuAir</span> <span class="dt">Small</span>

<span class="co">-- 1. Vehicle</span>

<span class="co">-- 2</span>
<span class="ot">isCar ::</span> <span class="dt">Vehicle</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isCar (<span class="dt">Car</span> _ _) <span class="fu">=</span> <span class="dt">True</span>
isCar _ <span class="fu">=</span> <span class="dt">False</span>

<span class="ot">isPlane ::</span> <span class="dt">Vehicle</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isPlane (<span class="dt">Plane</span> _ _) <span class="fu">=</span> <span class="dt">True</span>
isPlane _ <span class="fu">=</span> <span class="dt">False</span>

<span class="ot">areCars ::</span> [<span class="dt">Vehicle</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
areCars <span class="fu">=</span> any isCar 

<span class="co">-- 3</span>

<span class="ot">getManu ::</span> <span class="dt">Vehicle</span> <span class="ot">-&gt;</span> <span class="dt">Manufacturer</span>
getManu (<span class="dt">Car</span> manu _) <span class="fu">=</span> manu

<span class="co">-- 4: non-exhaustive patterns</span>

<span class="co">-- 5 see above</span></code></pre></div>
<h2 id="what-makes-these-datatypes-algebraic">11.8 What makes these datatypes algebraic?</h2>
<h3 id="exercises-cardinality">Exercises: Cardinality</h3>
<ol style="list-style-type: decimal">
<li>cardinality is 1</li>
<li><code>3</code></li>
<li><code>2^16 = 65536</code></li>
<li><code>2^64</code></li>
<li><code>Int8</code> is an 8 bit integer. <code>2^8</code> is 256.</li>
</ol>
<h3 id="exercises-for-example">Exercises: For Example</h3>
<ol style="list-style-type: decimal">
<li><code>MakeExample</code>’s type is <code>Example</code>, <code>Example</code> does not have a type, it is a type</li>
<li><code>Example</code> has data constructor <code>MakeExample</code> with an instance of typeclass <code>Show</code></li>
<li><code>MakeExample</code> is a function from <code>Int</code> to <code>Example</code></li>
</ol>
<h2 id="newtype">11.9 newtype</h2>
<h3 id="exercises-logic-goats">Exercises: Logic Goats</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving, FlexibleInstances #-}</span>

<span class="co">--10/LogicGoats.hs</span>
<span class="kw">module</span> <span class="dt">LogicGoats</span> <span class="kw">where</span>

<span class="kw">class</span> <span class="dt">TooMany</span> a <span class="kw">where</span>
<span class="ot">  tooMany ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">instance</span> <span class="dt">TooMany</span> <span class="dt">Int</span> <span class="kw">where</span>
  tooMany n <span class="fu">=</span> n <span class="fu">&gt;</span> <span class="dv">42</span>

<span class="kw">instance</span> <span class="dt">TooMany</span> (<span class="dt">Int</span>, <span class="dt">String</span>) <span class="kw">where</span>
  tooMany (n, str) <span class="fu">=</span> n <span class="fu">&gt;</span> <span class="dv">42</span> <span class="fu">||</span> (length str) <span class="fu">&gt;</span> <span class="dv">42</span>

<span class="co">-- instance TooMany (Int, Int) where</span>
<span class="co">-- tooMany (n, m) = n + m &gt; 42</span>

<span class="kw">instance</span> (<span class="dt">Num</span> a, <span class="dt">TooMany</span> a) <span class="ot">=&gt;</span> <span class="dt">TooMany</span> (a, a) <span class="kw">where</span>
  tooMany (n, m) <span class="fu">=</span> tooMany (n <span class="fu">+</span> m)

<span class="kw">newtype</span> <span class="dt">Goats</span> <span class="fu">=</span> <span class="dt">Goats</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">TooMany</span>)</code></pre></div>
<h2 id="sum-types">11.10 Sum types</h2>
<h3 id="exercises-pity-the-bool">Exercises: Pity the Bool</h3>
<ol style="list-style-type: decimal">
<li>4, <code>Bool</code> has cardinality 2 and there are 2 <code>Bools</code> in the sum type, so <code>2 + 2 = 4</code></li>
<li>258, the type can either be <code>BoolyBool True</code>, <code>BoolyBool False</code> or a <code>Numba</code>. If you go over the Int8 bounds, you get a compiler warning <code>-Woverflowedliterals</code></li>
</ol>
<h2 id="normal-form">11.12 Normal Form</h2>
<h2 id="exercises-how-does-your-garden-grow">Exercises: How Does Your Garden Grow?</h2>
<ol style="list-style-type: decimal">
<li><pre><code>data Garden = Gardenia String 
            | Daisy String 
            | Rose String
            | Lilac String
            deriving Show</code></pre></li>
</ol>
<h2 id="constructing-and-deconstructing-values">11.13 Constructing and deconstructing values</h2>
<h3 id="exercises-programmers">Exercises: Programmers</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/Programmers.hs</span>
<span class="kw">module</span> <span class="dt">Programmers</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">OperatingSystem</span> <span class="fu">=</span> <span class="dt">GnuPlusLinux</span> <span class="fu">|</span> <span class="dt">OpenBSDPlus</span> <span class="fu">|</span> <span class="dt">Mac</span> <span class="fu">|</span> <span class="dt">Windows</span>  
                        <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">ProgrammingLanguage</span> <span class="fu">=</span> <span class="dt">Haskell</span> <span class="fu">|</span> <span class="dt">Agda</span> <span class="fu">|</span> <span class="dt">Idris</span> <span class="fu">|</span> <span class="dt">PureScript</span>
                           <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Programmer</span> <span class="fu">=</span> <span class="dt">Programmer</span> {<span class="ot"> os   ::</span> <span class="dt">OperatingSystem</span>
                             ,<span class="ot"> lang ::</span> <span class="dt">ProgrammingLanguage</span> }
                  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="co">-- exercise</span>

<span class="ot">allOperatingSystems ::</span> [<span class="dt">OperatingSystem</span>]
allOperatingSystems <span class="fu">=</span> [ <span class="dt">GnuPlusLinux</span>
                      , <span class="dt">OpenBSDPlus</span>
                      , <span class="dt">Mac</span>
                      , <span class="dt">Windows</span>
                      ]

<span class="ot">allLanguages ::</span> [<span class="dt">ProgrammingLanguage</span>]
allLanguages <span class="fu">=</span> [<span class="dt">Haskell</span>, <span class="dt">Agda</span>, <span class="dt">Idris</span>, <span class="dt">PureScript</span>]

<span class="ot">allProgrammers ::</span> [<span class="dt">Programmer</span>]
allProgrammers <span class="fu">=</span> [(<span class="dt">Programmer</span> os lang) <span class="fu">|</span> os   <span class="ot">&lt;-</span> allOperatingSystems
                                       , lang <span class="ot">&lt;-</span> allLanguages ]</code></pre></div>
<h2 id="function-type-is-exponential">11.14 Function type is exponential</h2>
<p>Here’s how I visualize why the function type is exponential:</p>
<p>The set theory defintion is, roughly, that a function is a set of pairs of elements some input set <code>A</code> and elements of some ouput set <code>B</code>, such that there for each element <code>a</code> in <code>A</code>, there is one and only one pair <code>(a, _)</code> in <code>f</code> (assuming the function is total).</p>
<p>Suppose we’re considering functions from <code>Bool</code> to <code>Bool</code>. As haskell code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f1 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
f1 <span class="dt">True</span> <span class="fu">=</span> <span class="dt">True</span>
f1 <span class="dt">False</span> <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>But written as a set, <code>f1</code> looks like:</p>
<pre><code>{ {T, T},  {F, T} }</code></pre>
<p>Another function <code>f2</code> might be:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f2 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
f2 <span class="dt">True</span> <span class="fu">=</span> <span class="dt">True</span>
f2 <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<pre><code>{ {T, T},  {F, F} }</code></pre>
<p>So now let’s ask ourselves: How many distinct functions from <code>Bool</code> to <code>Bool</code> are there?</p>
<p>Well, <code>Bool</code> is small so we can just list them out:</p>
<pre><code>{ {T, T},  {F, T} }
{ {T, T},  {F, F} }
{ {T, F},  {F, T} }
{ {T, F},  {F, F} }</code></pre>
<p>So there are four, which from the book makes sense because <code>Bool</code> has a cardinality of 2 and function types as exponentials implies that the cardinality of <code>Bool -&gt; Bool</code> is <code>2^2 = 4</code>.</p>
<p>But, why is this the case? Here’s something interesting, in the listing of possible functions as sets:</p>
<pre><code>{ {T, T},  {F, T} }
{ {T, T},  {F, F} }
{ {T, F},  {F, T} }
{ {T, F},  {F, F} }</code></pre>
<p>We’re actually repeating a lot of information in each line. See how all the <code>T</code>’s and <code>F</code>’s line up? We already know that in each function from <code>Bool</code> there’s going to be a pair with <code>True</code> and a pair with <code>False</code> in the first position. What makes the function unique is really the outputs, not the inputs.</p>
<p>Let’s rewrite the function listing, by picking an order for elements of <code>Bool</code>: True, False.</p>
<p>Then we can rewrite:</p>
<pre><code>{ {T, T},  {F, T} } = TT 
{ {T, T},  {F, F} } = TF
{ {T, F},  {F, T} } = FT
{ {T, F},  {F, F} } = FF</code></pre>
<p>As long as we know the ordering <code>True, False</code>, we can figure out that the first symbol in the pair <code>TF</code>, for example, refers to to the output from <code>True</code> and the second symbol refers to the output from <code>False</code>.</p>
<p>In other words, when we look at a function, we can look up the function’s output for a given input by looking at what symbol appears the input’s position in the ordering.</p>
<p>For example, what does the function <code>FT</code> return for the input <code>True</code>? <code>FT</code> has an <code>F</code> for <code>False</code> in the <code>True</code> position, so it returns <code>False</code>.</p>
<p>The function <code>FT</code> and <code>FF</code> are the same in the <code>True</code> position, and differ in the `False position.</p>
<p>This may remind you of how digits work in numbers, except instead of the ones position, tens postion etc, the places represent inputs.</p>
<p>Watch what happens if we map the symbol <code>T</code> to <code>1</code> and the symbol <code>F</code> to <code>0</code>:</p>
<pre><code>TT = 11
TF = 10
FT = 01
FF = 00</code></pre>
<p>These are all the 2 digit binary numbers. There are four of them, because each digit can be either <code>1</code> or <code>0</code>, and there are two digits, so <code>2 symbols ^ 2 digits = 4</code></p>
<p>If there were three digits, there would be <code>2^3 = 8</code> possibile numbers. If there were three digits in base ten there would be <code>10^3 = 1000</code> possible numbers.</p>
<p>The elements of a function’s input set can be mapped to “digit” positions, and the elements of the output set can be mapped to “digit” symbols. Then you can write down a unique representation of the function by writing the ouput symbols in the input positions. Because the number of possible unique representations is the same as the number of possible functions, and because the number of representations is the number of base symbols raised to the number of digits (base ^ digitnumber = uniques), the number of possible unique functions from one set to another is the number elements in the output set raised to the number of element in the input set.</p>
<h2 id="exercises-the-quad">Exercises: The Quad</h2>
<ol style="list-style-type: decimal">
<li>8</li>
<li>16</li>
<li>4^4 = 256</li>
<li>2<em>2</em>2 = 8</li>
<li>2<sup>2</sup>2 = 16</li>
<li>(4<sup>4)</sup>2 = 65536</li>
</ol>
<h2 id="binary-tree">11.17 Binary Tree</h2>
<h3 id="binarytree">BinaryTree</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/BinaryTree.hs</span>
<span class="kw">module</span> <span class="dt">BinaryTree</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)
                    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)
<span class="co">-- insert</span>
<span class="ot">insert' ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a
insert' b <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Node</span> <span class="dt">Leaf</span> b <span class="dt">Leaf</span>
insert' b (<span class="dt">Node</span> left a right)
  <span class="fu">|</span> b <span class="fu">==</span> a <span class="fu">=</span> <span class="dt">Node</span> left a right
  <span class="fu">|</span> b <span class="fu">&lt;</span> a  <span class="fu">=</span> <span class="dt">Node</span> (insert' b left) a right
  <span class="fu">|</span> b <span class="fu">&gt;</span> a  <span class="fu">=</span> <span class="dt">Node</span> left a (insert' b right)

<span class="co">-- map</span>
<span class="ot">mapTree ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> b
mapTree _ <span class="dt">Leaf</span> <span class="fu">=</span> <span class="dt">Leaf</span>
mapTree f (<span class="dt">Node</span> left a right) <span class="fu">=</span> (<span class="dt">Node</span> (mapTree f left) (f a) (mapTree f right))

<span class="ot">testTree' ::</span> <span class="dt">BinaryTree</span> <span class="dt">Integer</span>
testTree' <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">3</span> <span class="dt">Leaf</span>) <span class="dv">1</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">4</span> <span class="dt">Leaf</span>)

mapExpected <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">4</span> <span class="dt">Leaf</span>) <span class="dv">2</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">5</span> <span class="dt">Leaf</span>)

mapOkay <span class="fu">=</span> mapTree (<span class="fu">+</span><span class="dv">1</span>) testTree' <span class="fu">==</span> mapExpected

<span class="co">-- list</span>
<span class="ot">preorder ::</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> [a]
preorder <span class="dt">Leaf</span> <span class="fu">=</span> []
preorder (<span class="dt">Node</span> left a right) <span class="fu">=</span> [a] <span class="fu">++</span> (preorder left) <span class="fu">++</span> (preorder right)

<span class="ot">inorder ::</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> [a]
inorder <span class="dt">Leaf</span> <span class="fu">=</span> []
inorder (<span class="dt">Node</span> left a right) <span class="fu">=</span> (inorder left) <span class="fu">++</span> [a] <span class="fu">++</span>  (inorder right)

<span class="ot">postorder ::</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> [a]
postorder <span class="dt">Leaf</span> <span class="fu">=</span> []
postorder (<span class="dt">Node</span> left a right) <span class="fu">=</span> (postorder left) <span class="fu">++</span> (postorder right) <span class="fu">++</span> [a]

<span class="ot">testTree ::</span> <span class="dt">BinaryTree</span> <span class="dt">Integer</span>
testTree <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">1</span> <span class="dt">Leaf</span>) <span class="dv">2</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">3</span> <span class="dt">Leaf</span>)

testPreorder <span class="fu">=</span> preorder testTree <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]

testInorder <span class="fu">=</span> inorder testTree <span class="fu">==</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]

testPostorder <span class="fu">=</span> postorder testTree <span class="fu">==</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>]

<span class="ot">foldTree ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> b
foldTree f ac <span class="dt">Leaf</span> <span class="fu">=</span> ac
foldTree f ac (<span class="dt">Node</span> left v right) <span class="fu">=</span> foldTree f (foldTree f (f v ac) left) right

<span class="ot">foldTree' ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> b
foldTree' f ac bt <span class="fu">=</span> foldr f ac (inorder bt)

<span class="ot">mapTree' ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> b
mapTree' f bt <span class="fu">=</span> foldTree g <span class="dt">Leaf</span> bt
  <span class="kw">where</span> g v acc <span class="fu">=</span> <span class="dt">Node</span> acc (f v) <span class="dt">Leaf</span>

<span class="ot">mapTree2 ::</span> <span class="dt">Ord</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> b
mapTree2 f bt <span class="fu">=</span> foldTree g <span class="dt">Leaf</span> bt
  <span class="kw">where</span> g v acc <span class="fu">=</span> insert' (f v) acc

testTree2 <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Node</span> (<span class="dt">Leaf</span>) <span class="dv">2</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">5</span> <span class="dt">Leaf</span>)) <span class="dv">1</span>
                 (<span class="dt">Node</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">6</span> <span class="dt">Leaf</span>) <span class="dv">3</span> (<span class="dt">Node</span> <span class="dt">Leaf</span> <span class="dv">7</span> <span class="dt">Leaf</span>))

 
<span class="ot">foldTree1 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> b
foldTree1 f a <span class="dt">Leaf</span> <span class="fu">=</span> a
foldTree1 f a (<span class="dt">Node</span> left v right) <span class="fu">=</span> 
  f v (foldTree1 f a left) (foldTree1 f a right)

<span class="ot">mapTree1 ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> b
mapTree1 f bt <span class="fu">=</span> foldTree1 g <span class="dt">Leaf</span> bt <span class="kw">where</span>
  g a left right <span class="fu">=</span> <span class="dt">Node</span> left (f a) right</code></pre></div>
<h2 id="chapter-exercises-9">11.18 Chapter Exercises</h2>
<h3 id="multiple-choice-3">Multiple Choice</h3>
<ol style="list-style-type: decimal">
<li>a</li>
<li>c</li>
<li>b</li>
<li>c</li>
</ol>
<h3 id="ciphers-1">Ciphers</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/Vignere.hs</span>
<span class="kw">module</span> <span class="dt">Vignere</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="ot">vignere ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
vignere key cleartext <span class="fu">=</span> map caeserHelper <span class="fu">$</span> zip key' clr' <span class="kw">where</span>
    pre <span class="fu">=</span> (map toLower <span class="fu">.</span> filter isAlpha)
    clr' <span class="fu">=</span> (pre cleartext)
    key' <span class="fu">=</span> take (length clr') <span class="fu">$</span> cycle (pre key)
    caeserHelper (a, b) <span class="fu">=</span> chr ((ord a <span class="fu">+</span> ord b <span class="fu">-</span> <span class="dv">2</span><span class="fu">*</span>ord <span class="ch">'a'</span>) <span class="ot">`mod`</span> <span class="dv">26</span> <span class="fu">+</span> ord <span class="ch">'a'</span>)

<span class="ot">unVignere ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
unVignere key ciphertext <span class="fu">=</span> map caeserHelper <span class="fu">$</span> zip key' ciphertext <span class="kw">where</span>
    pre <span class="fu">=</span> (map toLower <span class="fu">.</span> filter isAlpha)
    key' <span class="fu">=</span> take (length ciphertext) <span class="fu">$</span> cycle (pre key)
    caeserHelper (a, b) <span class="fu">=</span> chr ((ord b <span class="fu">-</span> ord a) <span class="ot">`mod`</span> <span class="dv">26</span> <span class="fu">+</span> ord <span class="ch">'a'</span>)</code></pre></div>
<h3 id="as-patterns">As-patterns</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/AsPatterns.hs</span>
<span class="kw">module</span> <span class="dt">AsPatterns</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="ot">doubleUp ::</span> [a] <span class="ot">-&gt;</span> [a]
doubleUp [] <span class="fu">=</span> []
doubleUp xs<span class="fu">@</span>(x<span class="fu">:</span>_) <span class="fu">=</span> x <span class="fu">:</span> xs

<span class="co">-- 1</span>
<span class="ot">isSubsequenceOf ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isSubsequenceOf [] _ <span class="fu">=</span> <span class="dt">True</span>
isSubsequenceOf _ [] <span class="fu">=</span> <span class="dt">False</span>
isSubsequenceOf (x<span class="fu">:</span>xs) b <span class="fu">=</span> elem x b <span class="fu">&amp;&amp;</span> isSubsequenceOf xs b

<span class="co">-- 2</span>
<span class="ot">capWords ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">String</span>)]
capWords str <span class="fu">=</span> map cap <span class="fu">$</span> words str <span class="kw">where</span>
  cap a<span class="fu">@</span>(x<span class="fu">:</span>xs) <span class="fu">=</span> (,) a <span class="fu">$</span> (toUpper x)<span class="fu">:</span>xs</code></pre></div>
<h3 id="language-exercises">Language exercises</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/LanguageExercises.hs</span>
<span class="kw">module</span> <span class="dt">LanguageExercises</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="ot">capWord ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
capWord a<span class="fu">@</span>(x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&gt;=</span> <span class="ch">'a'</span> <span class="fu">&amp;&amp;</span> x <span class="fu">&lt;=</span> <span class="ch">'z'</span> 
                          <span class="kw">then</span> chr((ord x) <span class="fu">-</span> <span class="dv">32</span>)<span class="fu">:</span>xs 
                          <span class="kw">else</span> a

<span class="ot">capParagraph ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
capParagraph p <span class="fu">=</span> init <span class="fu">$</span> concat <span class="fu">$</span> map (<span class="fu">++</span> <span class="st">&quot; &quot;</span>) <span class="fu">$</span> capp <span class="fu">$</span> words p <span class="kw">where</span>
  capp  [] <span class="fu">=</span> []
  capp  (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> (last x) <span class="fu">==</span> <span class="ch">'.'</span> <span class="kw">then</span> x<span class="fu">:</span>(capp' xs) <span class="kw">else</span> x<span class="fu">:</span>(capp xs)
  capp' [] <span class="fu">=</span> []
  capp' (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> (last x) <span class="fu">==</span> <span class="ch">'.'</span> <span class="kw">then</span> (capWord x)<span class="fu">:</span>(capp' xs) <span class="kw">else</span> x<span class="fu">:</span>(capp xs)</code></pre></div>
<h3 id="phone-exercise">Phone exercise</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/Phone.hs</span>
<span class="kw">module</span> <span class="dt">Phone</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Data.Char</span>

<span class="kw">data</span> <span class="dt">Phone</span> <span class="fu">=</span> <span class="dt">Phone</span> {<span class="ot">buttons ::</span> [<span class="dt">Button</span>]} <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">data</span> <span class="dt">Mode</span> <span class="fu">=</span> <span class="dt">Shift</span> <span class="fu">|</span> <span class="dt">None</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">data</span> <span class="dt">Button</span> <span class="fu">=</span> <span class="dt">Button</span> {<span class="ot">key ::</span> <span class="dt">Key</span>,<span class="ot"> output ::</span> <span class="dt">String</span>} <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)
<span class="kw">type</span> <span class="dt">Key</span> <span class="fu">=</span> <span class="dt">Char</span> 
<span class="kw">type</span> <span class="dt">Press</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="ot">daPhone ::</span> <span class="dt">Phone</span>
daPhone <span class="fu">=</span> <span class="dt">Phone</span> 
          [ <span class="dt">Button</span> <span class="ch">'1'</span> <span class="st">&quot;1&quot;</span>    , <span class="dt">Button</span> <span class="ch">'2'</span> <span class="st">&quot;ABC2&quot;</span>, <span class="dt">Button</span> <span class="ch">'3'</span> <span class="st">&quot;DEF3&quot;</span>
          , <span class="dt">Button</span> <span class="ch">'4'</span> <span class="st">&quot;GHI4&quot;</span> , <span class="dt">Button</span> <span class="ch">'5'</span> <span class="st">&quot;JKL5&quot;</span>, <span class="dt">Button</span> <span class="ch">'6'</span> <span class="st">&quot;MNO6&quot;</span>
          , <span class="dt">Button</span> <span class="ch">'7'</span> <span class="st">&quot;PQRS7&quot;</span>, <span class="dt">Button</span> <span class="ch">'8'</span> <span class="st">&quot;TUV8&quot;</span>, <span class="dt">Button</span> <span class="ch">'9'</span> <span class="st">&quot;WXYZ9&quot;</span>
          , <span class="dt">Button</span> <span class="ch">'*'</span> <span class="st">&quot;^*&quot;</span>   , <span class="dt">Button</span> <span class="ch">'0'</span> <span class="st">&quot; 0&quot;</span>  , <span class="dt">Button</span> <span class="ch">'#'</span> <span class="st">&quot;.,#&quot;</span>
          ]

convo <span class="fu">=</span> [<span class="st">&quot;Wanna play 20 questions&quot;</span>, 
         <span class="st">&quot;Ya&quot;</span>,
         <span class="st">&quot;U 1st haha&quot;</span>,
         <span class="st">&quot;Lol ok. Have u ever tated alcohol lol&quot;</span>,
         <span class="st">&quot;Lol ya&quot;</span>,  
         <span class="st">&quot;Wow ur cool haha. Ur turn&quot;</span>,
         <span class="st">&quot;Ok. Do u think I am pretty lol&quot;</span>,
         <span class="st">&quot;lol ya&quot;</span>,
         <span class="st">&quot;Haha thanks just makin sure rofl ur turn&quot;</span>]

<span class="ot">keyMap ::</span> <span class="dt">Phone</span> <span class="ot">-&gt;</span> (<span class="dt">Key</span>, <span class="dt">Press</span>) <span class="ot">-&gt;</span> <span class="dt">Mode</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
keyMap phone (k, p) mode <span class="fu">=</span> 
  <span class="kw">if</span> mode <span class="fu">==</span> <span class="dt">Shift</span> <span class="kw">then</span> out <span class="kw">else</span> toLower out <span class="kw">where</span>
    out <span class="fu">=</span> outCycle <span class="fu">!!</span> ((p <span class="fu">-</span> <span class="dv">1</span>) <span class="ot">`mod`</span> (length outCycle))
    outCycle <span class="fu">=</span> unpack <span class="fu">$</span> lookup k <span class="fu">$</span> zip (map key pb) (map output pb)
    pb <span class="fu">=</span> (buttons phone)
    unpack (<span class="dt">Just</span> a) <span class="fu">=</span> a

<span class="ot">textOut ::</span> <span class="dt">Phone</span> <span class="ot">-&gt;</span> [(<span class="dt">Key</span>, <span class="dt">Press</span>)] <span class="ot">-&gt;</span> <span class="dt">String</span>
textOut phone kps <span class="fu">=</span> go phone kps <span class="dt">None</span> <span class="kw">where</span>
  go phone [] _ <span class="fu">=</span> [] 
  go phone ((<span class="ch">'*'</span>, <span class="dv">1</span>)<span class="fu">:</span>kps) <span class="dt">None</span> <span class="fu">=</span> go phone kps <span class="dt">Shift</span>
  go phone ((<span class="ch">'*'</span>, <span class="dv">1</span>)<span class="fu">:</span>kps) <span class="dt">Shift</span> <span class="fu">=</span> go phone kps <span class="dt">None</span>
  go phone (kp<span class="fu">:</span>kps) m <span class="fu">=</span>  ((keyMap phone) (shift kp) m) <span class="fu">:</span> go phone kps <span class="dt">None</span>
  shift (k, p) <span class="fu">=</span> <span class="kw">if</span> k <span class="fu">==</span> <span class="ch">'*'</span> <span class="kw">then</span> (k, p <span class="fu">-</span> <span class="dv">1</span>) <span class="kw">else</span> (k, p)

<span class="ot">invButton ::</span> <span class="dt">Button</span> <span class="ot">-&gt;</span> [(<span class="dt">Char</span>, (<span class="dt">Key</span>, <span class="dt">Press</span>))]
invButton b <span class="fu">=</span> go ((key b), (output b)) <span class="dv">1</span> <span class="kw">where</span>
  go (k, []) _ <span class="fu">=</span> []
  go (k, (c<span class="fu">:</span>cs)) n <span class="fu">=</span> (c, (k, n)) <span class="fu">:</span> go (k, cs) (n <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">invKeyMap ::</span> <span class="dt">Phone</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Key</span>, <span class="dt">Press</span>)
invKeyMap phone c <span class="fu">=</span> lookup c <span class="fu">$</span> concatMap invButton <span class="fu">$</span> buttons daPhone

<span class="ot">keyPressIn ::</span> <span class="dt">Phone</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Maybe</span> (<span class="dt">Key</span>, <span class="dt">Press</span>)]
keyPressIn phone [] <span class="fu">=</span> [] 
keyPressIn phone (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="kw">if</span> isUpper x <span class="kw">then</span> up <span class="kw">else</span> lo <span class="kw">where</span>
  up <span class="fu">=</span> (<span class="dt">Just</span> (<span class="ch">'*'</span>, <span class="dv">1</span>))<span class="fu">:</span>(invKeyMap phone x)<span class="fu">:</span>(keyPressIn phone xs)
  lo <span class="fu">=</span> (invKeyMap phone (toUpper x))<span class="fu">:</span>(keyPressIn phone xs)

<span class="ot">fingerTaps ::</span> [<span class="dt">Maybe</span> (<span class="dt">Key</span>, <span class="dt">Press</span>)] <span class="ot">-&gt;</span> <span class="dt">Press</span>
fingerTaps a <span class="fu">=</span> go a <span class="dv">0</span> <span class="kw">where</span>
  go [] n <span class="fu">=</span> n
  go ((<span class="dt">Nothing</span>)<span class="fu">:</span>xs) n <span class="fu">=</span> go xs n
  go ((<span class="dt">Just</span> (k, p))<span class="fu">:</span>xs) n <span class="fu">=</span> go xs (p <span class="fu">+</span> n)

<span class="ot">mostPopularLetter ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
mostPopularLetter str <span class="fu">=</span> head <span class="fu">$</span> maximumBy cmp <span class="fu">$</span> group str <span class="kw">where</span>
  cmp a b <span class="fu">=</span> compare (length a) (length b)

<span class="ot">costOfMostPopularLetter ::</span> <span class="dt">Phone</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Press</span>
costOfMostPopularLetter phone str <span class="fu">=</span> fingerTaps <span class="fu">$</span> keyPressIn phone [a] <span class="kw">where</span>
  a <span class="fu">=</span> mostPopularLetter str

<span class="ot">coolestLtr ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Char</span>
coolestLtr msgs <span class="fu">=</span> mostPopularLetter <span class="fu">$</span> map mostPopularLetter msgs

<span class="ot">coolestWord ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
coolestWord msgs <span class="fu">=</span> head <span class="fu">$</span> maximumBy cmp <span class="fu">$</span> group <span class="fu">$</span> concatMap words msgs <span class="kw">where</span> 
  cmp a b <span class="fu">=</span> compare (length a) (length b)</code></pre></div>
<p>[TODO: I’m looking back on this code several months after writing it. It’s awkward, but I’ll leave it as is for now, since it’s an okay example of solving the problem with only the tools covered in the book thus far. I think I should do an example of how this project gets a lot easier when you can use things like the State monad.]</p>
<h3 id="huttons-razor">Hutton’s Razor</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--11/Hutton.hs</span>
<span class="kw">module</span> <span class="dt">Hutton</span> <span class="kw">where</span>

<span class="co">--1</span>
<span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Lit</span> <span class="dt">Integer</span> <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span>

<span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
eval (<span class="dt">Lit</span> n) <span class="fu">=</span> n
eval (<span class="dt">Add</span> a b) <span class="fu">=</span> (<span class="fu">+</span>) (eval a) (eval b) 

<span class="co">-- 2</span>

<span class="ot">printExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
printExpr (<span class="dt">Lit</span> n) <span class="fu">=</span> show n
printExpr (<span class="dt">Add</span> a b) <span class="fu">=</span> (printExpr a) <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> (printExpr b)</code></pre></div>
<hr />
<h1 id="signaling-adversity">12 Signaling adversity</h1>
<h2 id="chapter-exercises-10">12.5 Chapter Exercises</h2>
<h3 id="determine-the-kinds">Determine the kinds</h3>
<ol style="list-style-type: decimal">
<li><code>*</code></li>
<li><code>a</code> is <code>*</code>, <code>f</code> is <code>* -&gt; *</code></li>
</ol>
<h3 id="string-processing">String processing</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--12/StringProcessing.hs</span>
<span class="kw">module</span> <span class="dt">StringProcessing</span> <span class="kw">where</span>

<span class="ot">notThe ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">String</span>
notThe str <span class="fu">=</span> <span class="kw">if</span> str <span class="fu">==</span> <span class="st">&quot;the&quot;</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> str

<span class="ot">wurdz ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
wurdz str <span class="fu">=</span> (fst a)<span class="fu">:</span>(<span class="kw">if</span> (snd a) <span class="fu">==</span> [] <span class="kw">then</span> [] <span class="kw">else</span> (wurdz <span class="fu">$</span> tail <span class="fu">$</span> snd a))
  <span class="kw">where</span> a <span class="fu">=</span> break ((<span class="fu">==</span>) <span class="ch">' '</span>) str

<span class="ot">wurdzMap ::</span>  (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
wurdzMap f str <span class="fu">=</span> (f (fst a)) <span class="fu">++</span> (<span class="kw">if</span> (snd a) <span class="fu">==</span> [] 
                                 <span class="kw">then</span> <span class="st">&quot;&quot;</span> 
                                 <span class="kw">else</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> (wurdzMap f <span class="fu">$</span> tail <span class="fu">$</span> snd a))
  <span class="kw">where</span> a <span class="fu">=</span> break ((<span class="fu">==</span>) <span class="ch">' '</span>) str

<span class="ot">replaceThe ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
replaceThe str <span class="fu">=</span> init <span class="fu">$</span> go (words str) <span class="kw">where</span>
  go [] <span class="fu">=</span> []
  go (x<span class="fu">:</span>xs) <span class="fu">=</span> (<span class="kw">if</span> notThe x <span class="fu">==</span> <span class="dt">Nothing</span> <span class="kw">then</span> <span class="st">&quot;a&quot;</span> <span class="kw">else</span> u <span class="fu">$</span> notThe x) 
                <span class="fu">++</span> <span class="st">&quot; &quot;</span> <span class="fu">++</span> (go xs)
  u (<span class="dt">Just</span> a) <span class="fu">=</span> a

<span class="ot">replaceThe' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
replaceThe' str <span class="fu">=</span> init <span class="fu">$</span> concatMap (g <span class="fu">.</span> f) <span class="fu">$</span> wurdz str <span class="kw">where</span>
  g x <span class="fu">=</span> ((<span class="fu">++</span>) x <span class="st">&quot; &quot;</span>)
  f x <span class="fu">=</span> (<span class="kw">if</span> notThe x <span class="fu">==</span> <span class="dt">Nothing</span> <span class="kw">then</span> <span class="st">&quot;a&quot;</span> <span class="kw">else</span> u <span class="fu">$</span> notThe x)
  u (<span class="dt">Just</span> a) <span class="fu">=</span> a

<span class="ot">replaceThe2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
replaceThe2 str <span class="fu">=</span> wurdzMap (f <span class="fu">.</span>notThe) str <span class="kw">where</span>
  f (<span class="dt">Nothing</span>) <span class="fu">=</span> <span class="st">&quot;a&quot;</span>
  f (<span class="dt">Just</span> a) <span class="fu">=</span> a

<span class="co">-- 2</span>

<span class="ot">isVowel ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isVowel c <span class="fu">=</span> (elem c <span class="st">&quot;aeiouAEIOU&quot;</span>)

<span class="ot">countTheBeforeVowel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
countTheBeforeVowel str <span class="fu">=</span> go (words str) <span class="dv">0</span> <span class="kw">where</span>
  go [] n <span class="fu">=</span> n
  go [x] n <span class="fu">=</span> n
  go (x<span class="fu">:</span>(c<span class="fu">:</span>cs)<span class="fu">:</span>xss) n <span class="fu">=</span> <span class="kw">if</span> (x <span class="fu">==</span> <span class="st">&quot;the&quot;</span> <span class="fu">&amp;&amp;</span> (isVowel c)) 
                       <span class="kw">then</span> go xss (n <span class="fu">+</span> <span class="dv">1</span>) 
                       <span class="kw">else</span> go xss n

<span class="ot">countVowels ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
countVowels str <span class="fu">=</span> foldr f <span class="dv">0</span> str <span class="kw">where</span> 
  f x y <span class="fu">=</span> <span class="kw">if</span> isVowel x <span class="kw">then</span> y <span class="fu">+</span> <span class="dv">1</span> <span class="kw">else</span> y

<span class="ot">countConsonants ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
countConsonants str <span class="fu">=</span> foldr f <span class="dv">0</span> str <span class="kw">where</span> 
  f x y <span class="fu">=</span> <span class="kw">if</span> not <span class="fu">$</span> isVowel x <span class="kw">then</span> y <span class="fu">+</span> <span class="dv">1</span> <span class="kw">else</span> y

<span class="co">-- Validate the word</span>

<span class="kw">newtype</span> <span class="dt">Word'</span> <span class="fu">=</span> <span class="dt">Word'</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

vowels <span class="fu">=</span> <span class="st">&quot;aeiou&quot;</span>

<span class="ot">mkWord ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Word'</span>
mkWord str <span class="fu">=</span> <span class="kw">if</span> countConsonants str <span class="fu">&gt;=</span> countVowels str
             <span class="kw">then</span> (<span class="dt">Just</span> (<span class="dt">Word'</span> str)) <span class="kw">else</span> <span class="dt">Nothing</span></code></pre></div>
<h3 id="validate-the-word">Validate the word</h3>
<p>see `12/StringProcessing.hs,</p>
<h3 id="its-only-natural">It’s only Natural</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--12/Natural.hs</span>
<span class="kw">module</span> <span class="dt">Natural</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">natToInteger ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
natToInteger nat <span class="fu">=</span> go nat <span class="dv">0</span> 
  <span class="kw">where</span>
    go <span class="dt">Zero</span> n <span class="fu">=</span> n
    go (<span class="dt">Succ</span> a) n <span class="fu">=</span> go a (n <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">integerToNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Nat</span>
integerToNat n 
  <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span>
  <span class="fu">|</span> otherwise <span class="fu">=</span> (<span class="dt">Just</span> <span class="fu">$</span> go n <span class="dt">Zero</span>) 
  <span class="kw">where</span>
    go <span class="dv">0</span> nat <span class="fu">=</span> nat
    go n nat <span class="fu">=</span> go (n <span class="fu">-</span> <span class="dv">1</span>) (<span class="dt">Succ</span> nat)</code></pre></div>
<h3 id="small-library-for-maybe">Small library for Maybe</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--12/MaybeLib.hs</span>
<span class="kw">module</span> <span class="dt">MaybeLib</span> <span class="kw">where</span>

<span class="co">-- 1</span>
<span class="ot">isJust ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
isJust <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">False</span>
isJust (<span class="dt">Just</span> a) <span class="fu">=</span> <span class="dt">True</span>

<span class="ot">isNothing ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> 
isNothing <span class="fu">=</span> not <span class="fu">.</span> isJust 

<span class="co">-- 2 </span>
<span class="ot">mayybee ::</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b
mayybee b f (<span class="dt">Just</span> a) <span class="fu">=</span> (f a) 
mayybee b f <span class="dt">Nothing</span> <span class="fu">=</span> b

<span class="co">-- 3</span>
<span class="ot">fromMaybe ::</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> a 
fromMaybe a m <span class="fu">=</span> mayybee a id m

<span class="co">-- 4</span>
<span class="ot">listToMaybe ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
listToMaybe [] <span class="fu">=</span> <span class="dt">Nothing</span>
listToMaybe (x<span class="fu">:</span>xs) <span class="fu">=</span> (<span class="dt">Just</span> x)

<span class="ot">maybeToList ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> [a]
maybeToList <span class="dt">Nothing</span> <span class="fu">=</span> []
maybeToList (<span class="dt">Just</span> a) <span class="fu">=</span> [a] 

<span class="co">-- 5</span>
<span class="ot">catMaybes ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> [a]
catMaybes [] <span class="fu">=</span> [] 
catMaybes ((<span class="dt">Just</span> a)<span class="fu">:</span>xs) <span class="fu">=</span> a <span class="fu">:</span> (catMaybes xs)
catMaybes (<span class="dt">Nothing</span><span class="fu">:</span>xs) <span class="fu">=</span> catMaybes xs 

<span class="co">-- 6</span>
<span class="ot">flipMaybe ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]
flipMaybe ms <span class="fu">=</span> go ms [] <span class="kw">where</span>
  go [] acc <span class="fu">=</span> <span class="dt">Just</span> acc
  go ((<span class="dt">Just</span> x)<span class="fu">:</span>xs) acc <span class="fu">=</span> go xs (x<span class="fu">:</span>acc)
  go (<span class="dt">Nothing</span><span class="fu">:</span>xs) _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre></div>
<h3 id="small-library-for-either">Small library for Either</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--12/EitherLib.hs</span>
<span class="kw">module</span> <span class="dt">EitherLib</span> <span class="kw">where</span>

<span class="ot">lefts' ::</span> [<span class="dt">Either</span> a b] <span class="ot">-&gt;</span> [a]
lefts' es <span class="fu">=</span> foldr f [] es <span class="kw">where</span>
  f (<span class="dt">Left</span> x) acc <span class="fu">=</span> x<span class="fu">:</span>acc
  f _ acc <span class="fu">=</span> acc

<span class="ot">rights' ::</span> [<span class="dt">Either</span> a b] <span class="ot">-&gt;</span> [b]
rights' es <span class="fu">=</span> foldr f [] es <span class="kw">where</span>
  f (<span class="dt">Right</span> x) acc <span class="fu">=</span> x<span class="fu">:</span>acc
  f _ acc <span class="fu">=</span> acc

<span class="ot">partitionEithers' ::</span> [<span class="dt">Either</span> a b] <span class="ot">-&gt;</span> ([a], [b])
partitionEithers' es <span class="fu">=</span> (lefts' es, rights' es)

<span class="ot">eitherMaybe' ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> c
eitherMaybe' f (<span class="dt">Left</span> a) <span class="fu">=</span> <span class="dt">Nothing</span>
eitherMaybe' f (<span class="dt">Right</span> b) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> f b

<span class="ot">either' ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> c 
either' f g (<span class="dt">Left</span> a) <span class="fu">=</span> f a
either' f g (<span class="dt">Right</span> b) <span class="fu">=</span> g b

<span class="ot">eitherMaybe'' ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> c
eitherMaybe'' f e <span class="fu">=</span> either' (const <span class="dt">Nothing</span>) (<span class="dt">Just</span> <span class="fu">.</span> f) e</code></pre></div>
<h3 id="write-your-own-iterate-and-unfoldr">Write your own iterate and unfoldr</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--12/Unfolds.hs</span>
<span class="kw">module</span> <span class="dt">Unfolds</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.List</span>

<span class="ot">myIterate ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
myIterate f a <span class="fu">=</span> a <span class="fu">:</span> myIterate f (f a)

<span class="ot">myUnfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]
myUnfoldr f s <span class="fu">=</span> go f s (f s) <span class="kw">where</span> 
  go f s <span class="dt">Nothing</span> <span class="fu">=</span> []
  go f s (<span class="dt">Just</span> (a, b)) <span class="fu">=</span> a <span class="fu">:</span> go f b (f b)

<span class="ot">betterIterate ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
betterIterate f s <span class="fu">=</span> myUnfoldr (g f) s <span class="kw">where</span>
  g f s <span class="fu">=</span> <span class="dt">Just</span> (s, (f s))</code></pre></div>
<h3 id="finally-something-other-than-a-list">Finally something other than a list</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--12/BinaryTreeUnfold.hs</span>
<span class="kw">module</span> <span class="dt">BinaryTreeUnfold</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">BinaryTree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">BinaryTree</span> a) a (<span class="dt">BinaryTree</span> a)
                    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)

<span class="ot">unfold ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b, a)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> b
unfold f s <span class="fu">=</span> <span class="kw">case</span> f s <span class="kw">of</span>
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Leaf</span>
  <span class="dt">Just</span> (l, v, r) <span class="ot">-&gt;</span> <span class="dt">Node</span> (unfold f l) v (unfold f r)

<span class="ot">treeBuild ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">BinaryTree</span> <span class="dt">Integer</span>
treeBuild n <span class="fu">=</span> unfold (f n) <span class="dv">0</span> <span class="kw">where</span>
  f n x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&gt;=</span> n <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (x<span class="fu">+</span><span class="dv">1</span>, x, x<span class="fu">+</span><span class="dv">1</span>) </code></pre></div>
<h1 id="building-projects">13 Building Projects</h1>
<h2 id="more-on-importing-modules">13.6 More on importing modules</h2>
<h2 id="imtermission-check-your-understanding">Imtermission: Check your understanding</h2>
<ol style="list-style-type: decimal">
<li><code>forever</code>, <code>when</code></li>
<li><code>Data.Bits</code>, <code>Database.Blacktip.Types</code></li>
<li>Types for <code>blacktip</code>’s database</li>
<li></li>
</ol>
<ul>
<li><ol style="list-style-type: lower-alpha">
<li><code>MV</code> is <code>Control.Concurrent.MVar</code>, <code>FPC</code> is <code>Filesystem.Path.CurrentOS</code>, <code>CC</code> is <code>Control.Concurrent</code></li>
</ol></li>
<li><ol start="2" style="list-style-type: lower-alpha">
<li><code>Filesystem</code></li>
</ol></li>
<li><ol start="3" style="list-style-type: lower-alpha">
<li><code>Control.Monad</code></li>
</ol></li>
</ul>
<h2 id="chapter-exercises-11">Chapter Exercises</h2>
<h3 id="hangman-game-logic">Hangman game logic</h3>
<p>See my <a href="https://github.com/johnchandlerburnham/haskellbook/tree/master/13/hangman">hangman project on GitHub</a></p>
<p>I debated whether or not to include code snippets of full-fledged stack projects in this document. I’ve decided against it. It’s one thing to include self-contained modules as question answers, but if I were to, for example, include the <code>Main.hs</code> file for the hangman project here, there’d be some implicit dependencies like dict.txt and hangman.cabal, and if the past 524 pages of this book have taught me anything, implicit dependencies are bad news.</p>
<h3 id="modifying-code">Modifying code</h3>
<ol style="list-style-type: decimal">
<li><pre><code>--13/CipherIO.hs
module CipherIO where

import Data.Char
import System.Exit (exitSuccess)

caesar :: Int -&gt; String -&gt; String
caesar key string = go key $ (map toLower . filter isAlpha) string
  where go _ &quot;&quot; = &quot;&quot;
        go n (c:cs) = chr ((ord c + n - ord 'a') `mod` 26 + ord 'a') : go n cs

unCaesar :: Int -&gt; String -&gt; String
unCaesar key string = caesar (negate key) string 

vignere :: String -&gt; String -&gt; String
vignere key cleartext = map caeserHelper $ zip key' clr' where
    pre = (map toLower . filter isAlpha)
    clr' = (pre cleartext)
    key' = take (length clr') $ cycle (pre key)
    caeserHelper (a, b) = chr ((ord a + ord b - 2*ord 'a') `mod` 26 + ord 'a')

unVignere :: String -&gt; String -&gt; String
unVignere key ciphertext = map caeserHelper $ zip key' ciphertext where
    pre = (map toLower . filter isAlpha)
    key' = take (length ciphertext) $ cycle (pre key)
    caeserHelper (a, b) = chr ((ord b - ord a) `mod` 26 + ord 'a')

testCaesar :: Int -&gt; String -&gt; Bool
testCaesar n s = (map toLower . filter isAlpha) s == (unCaesar n . caesar n) s 

testVignere :: String -&gt; String -&gt; Bool
testVignere key s = 
  (map toLower . filter isAlpha) s == (unVignere key . vignere key) s 

encrypt :: IO ()
encrypt = do
  putStrLn &quot;Cleartext:&quot;
  clearText &lt;- getLine
  putStrLn &quot;Caeser Key: &quot; 
  cKey &lt;- getLine
  putStrLn &quot;Vignere Key: &quot; 
  vKey &lt;- getLine
  putStrLn &quot;Caesar Ciphertext is: &quot;
  print (caesar (read cKey) clearText)
  putStrLn &quot;Vignere Ciphertext is: &quot;
  print (vignere vKey clearText)</code></pre></li>
<li><pre><code>--13/ExitSuccess.hs
module ExitSuccess where

import Data.Char
import Control.Monad
import System.Exit (exitSuccess)

palindrome :: IO ()
palindrome = forever $ do
  line1 &lt;- getLine
  if isPalindrome line1
  then putStrLn &quot;It's a palindrome!&quot;
  else do putStrLn &quot;nope&quot; 
          exitSuccess

isPalindrome :: String -&gt; Bool
isPalindrome str = (str' == reverse str')
  where str' = filter isAlpha $ map toLower str</code></pre></li>
<li><pre><code>--13/Person.hs
module Person where

type Name = String
type Age = Integer

data Person = Person Name Age deriving Show
data PersonInvalid = NameEmpty | AgeTooLow | Unknown String deriving (Eq, Show)

mkPerson :: Name -&gt; Age -&gt; Either PersonInvalid Person
mkPerson name age
  | name /= &quot;&quot; &amp;&amp; age &gt; 0 = Right $ Person name age
  | name == &quot;&quot;            = Left NameEmpty
  | not (age &gt; 0)         = Left AgeTooLow
  | otherwise             = Left $ Unknown $ &quot;Name was: &quot; ++ show name 
                                         ++ &quot; Age was: &quot;  ++ show age

gimmePerson :: IO ()
gimmePerson = do
  putStrLn &quot;Name: &quot;
  name &lt;- getLine 
  putStrLn &quot;Age: &quot;
  age &lt;- getLine
  let person = mkPerson name (read age) in
    case person of
      (Left _)  -&gt; putStrLn (&quot;Invalid person: &quot; ++ (show person))
      (Right _) -&gt; putStrLn (&quot;Valid person: &quot; ++ (show person))

-- best way to handle parse error for read is to change mkPerson</code></pre></li>
</ol>
<h2 id="follow-up-resources-7">13.15 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><a href="https://github.com/commercialhaskell/stack">Stack</a></li>
<li><a href="http://bitemyapp.com/posts/2014-11-18-how-i-start-haskell.html">How I Start: Haskell</a></li>
<li><a href="https://www.haskell.org/cabal/FAQ.html">Cabal FAQ</a></li>
<li><a href="https://www.haskell.org/cabal/users-guide/">Cabal user’s guide</a></li>
<li><a href="https://www.haskell.org/tutorial/modules.html">A Gentle Introduction to Haskell, Modules chapter.</a></li>
</ol>
<hr />
<h1 id="testing">14 Testing</h1>
<h2 id="intermission-short-exercise">Intermission: Short Exercise</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- /14/addition/Addition.hs</span>
<span class="kw">module</span> <span class="dt">Addition</span> <span class="kw">where</span> 

<span class="kw">import </span><span class="dt">Test.Hspec</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> hspec <span class="fu">$</span> <span class="kw">do</span>
  describe <span class="st">&quot;Addition&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    it <span class="st">&quot;1 + 1 is greater than 1&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) <span class="fu">&gt;</span> <span class="dv">1</span> <span class="ot">`shouldBe`</span> <span class="dt">True</span>
    it <span class="st">&quot;2 + 2 is equal to 4&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      <span class="dv">2</span> <span class="fu">+</span> <span class="dv">2</span> <span class="ot">`shouldBe`</span> <span class="dv">4</span>
    it <span class="st">&quot;x + 1 is always greater than x&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      property <span class="fu">$</span> \x <span class="ot">-&gt;</span> x <span class="fu">+</span> <span class="dv">1</span> <span class="fu">&gt;</span> (<span class="ot">x ::</span> <span class="dt">Int</span>)
  describe <span class="st">&quot;Division&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    it <span class="st">&quot;15 divided by 3 is 5&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      dividedBy <span class="dv">15</span> <span class="dv">3</span> <span class="ot">`shouldBe`</span> (<span class="dv">5</span>, <span class="dv">0</span>)
    it <span class="st">&quot;22 divided by 5 is 4 remainder 2&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      dividedBy <span class="dv">22</span> <span class="dv">5</span> <span class="ot">`shouldBe`</span> (<span class="dv">4</span>, <span class="dv">2</span>)
  describe <span class="st">&quot;Multiplication&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    it <span class="st">&quot;1 * 1 is 1&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      rMult <span class="dv">1</span> <span class="dv">1</span> <span class="ot">`shouldBe`</span> <span class="dv">1</span>
    it <span class="st">&quot;2 * 2 is 4&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      rMult <span class="dv">2</span> <span class="dv">2</span> <span class="ot">`shouldBe`</span> <span class="dv">4</span>
    it <span class="st">&quot;2 * 0 is 0&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      rMult <span class="dv">2</span> <span class="dv">0</span> <span class="ot">`shouldBe`</span> <span class="dv">0</span>
    it <span class="st">&quot;0 * 2 is 0&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      rMult <span class="dv">0</span> <span class="dv">2</span> <span class="ot">`shouldBe`</span> <span class="dv">0</span>
    it <span class="st">&quot;0 * 0 is 0&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      rMult <span class="dv">0</span> <span class="dv">0</span> <span class="ot">`shouldBe`</span> <span class="dv">0</span>
    it <span class="st">&quot;3 * 4 is 12&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      rMult <span class="dv">3</span> <span class="dv">4</span> <span class="ot">`shouldBe`</span> <span class="dv">12</span>

<span class="ot">dividedBy ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)
dividedBy num denom <span class="fu">=</span> go num denom <span class="dv">0</span>
  <span class="kw">where</span> go n d count
         <span class="fu">|</span> n <span class="fu">&lt;</span> d <span class="fu">=</span> (count, n)
         <span class="fu">|</span> otherwise <span class="fu">=</span> go (n <span class="fu">-</span> d) d (count <span class="fu">+</span> <span class="dv">1</span>)

<span class="ot">rMult ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
rMult a b <span class="fu">=</span> go a b <span class="dv">0</span>
  <span class="kw">where</span> go a b c
          <span class="fu">|</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> c
          <span class="fu">|</span> otherwise <span class="fu">=</span> go a (b <span class="fu">-</span> <span class="dv">1</span>) (c <span class="fu">+</span> a)

<span class="ot">sayHello ::</span> <span class="dt">IO</span> ()
sayHello <span class="fu">=</span> putStrLn <span class="st">&quot;hello!&quot;</span></code></pre></div>
<h2 id="chapter-exercises-12">14.7 Chapter Exercises</h2>
<h3 id="validating-numbers-into-words">Validating numbers into words</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- 14/exercises/test/Spec.hs</span>
<span class="kw">module</span> <span class="dt">ExercisesTest</span> <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">WordNumberTest</span> <span class="kw">as</span> <span class="dt">WN</span>
<span class="kw">import qualified</span> <span class="dt">Exercises</span> <span class="kw">as</span> <span class="dt">EX</span>
<span class="kw">import </span><span class="dt">Data.Char</span> (toUpper)
<span class="kw">import </span><span class="dt">Data.List</span> (sort)
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="co">-- 1</span>
<span class="ot">halfIdentity ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
halfIdentity <span class="fu">=</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">.</span> EX.half
 
<span class="ot">prop_twiceHalf ::</span> (<span class="dt">Eq</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_twiceHalf n <span class="fu">=</span> (halfIdentity n) <span class="fu">==</span> n

<span class="co">--2</span>
<span class="ot">listOrdered ::</span>  (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
listOrdered xs <span class="fu">=</span> snd <span class="fu">$</span> foldr go (<span class="dt">Nothing</span>, <span class="dt">True</span>) xs <span class="kw">where</span>
  go _ status<span class="fu">@</span>(_ , <span class="dt">False</span>) <span class="fu">=</span> status
  go y (<span class="dt">Nothing</span>, t) <span class="fu">=</span> (<span class="dt">Just</span> y, t)
  go y (<span class="dt">Just</span> x, t) <span class="fu">=</span> (<span class="dt">Just</span> y, x <span class="fu">&gt;=</span> y)

<span class="ot">prop_sort ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_sort <span class="fu">=</span> listOrdered <span class="fu">.</span> sort

<span class="co">-- 3</span>
<span class="ot">plusAssociative ::</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
plusAssociative x y z <span class="fu">=</span> x <span class="fu">+</span> (y <span class="fu">+</span> z) <span class="fu">==</span> (x <span class="fu">+</span> y) <span class="fu">+</span> z

<span class="ot">plusCommutative ::</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
plusCommutative x y <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">==</span> y <span class="fu">+</span> x

<span class="co">-- 4</span>
<span class="ot">multAssociative ::</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
multAssociative x y z <span class="fu">=</span> x <span class="fu">+</span> (y <span class="fu">+</span> z) <span class="fu">==</span> (x <span class="fu">+</span> y) <span class="fu">+</span> z

<span class="ot">multCommutative ::</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
multCommutative x y <span class="fu">=</span> x <span class="fu">+</span> y <span class="fu">==</span> y <span class="fu">+</span> x

<span class="co">-- 5</span>
<span class="ot">quotRemRule ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
quotRemRule x y <span class="fu">=</span> (quot x y)<span class="fu">*</span>y <span class="fu">+</span> (rem x y) <span class="fu">==</span> x

<span class="ot">divModRule ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
divModRule x y <span class="fu">=</span> (quot x y)<span class="fu">*</span>y <span class="fu">+</span> (rem x y) <span class="fu">==</span> x

<span class="co">-- 6</span>
<span class="ot">expAssociative ::</span> (<span class="dt">Num</span> a, <span class="dt">Integral</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
expAssociative x y z <span class="fu">=</span> (x <span class="fu">^</span> y) <span class="fu">^</span> z <span class="fu">==</span> x <span class="fu">^</span> (y <span class="fu">^</span> z)

<span class="ot">expCommutative ::</span> (<span class="dt">Num</span> a, <span class="dt">Integral</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
expCommutative x y <span class="fu">=</span> x <span class="fu">^</span> y <span class="fu">==</span> y <span class="fu">^</span> x

<span class="co">-- 7</span>
<span class="ot">listReverse ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
listReverse list <span class="fu">=</span> (reverse <span class="fu">.</span> reverse) list <span class="fu">==</span> list

<span class="co">-- 8 </span>
<span class="ot">prop_apply ::</span> (<span class="dt">Eq</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> 
prop_apply f x <span class="fu">=</span> (f <span class="fu">$</span> x) <span class="fu">==</span> (f x)

<span class="ot">prop_compose ::</span> (<span class="dt">Eq</span> c) <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_compose f g x <span class="fu">=</span> (f <span class="fu">.</span> g) x <span class="fu">==</span> f (g x)

<span class="kw">instance</span> <span class="dt">Show</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span> show _ <span class="fu">=</span> <span class="st">&quot;Arbitrary Function&quot;</span>

<span class="co">-- 9</span>
<span class="ot">prop_compareCons ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_compareCons xs ys <span class="fu">=</span> foldr (<span class="fu">:</span>) xs ys <span class="fu">==</span> (<span class="fu">++</span>) xs ys

<span class="ot">prop_compareCons' ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_compareCons' xs ys <span class="fu">=</span> foldr (<span class="fu">:</span>) xs ys <span class="fu">==</span> (flip (<span class="fu">++</span>)) xs ys

<span class="ot">prop_compareConcat ::</span> (<span class="dt">Eq</span> a, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_compareConcat xs <span class="fu">=</span> foldr (<span class="fu">++</span>) [] xs <span class="fu">==</span> concat xs

<span class="co">-- 10</span>
<span class="ot">prop_take ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_take n xs <span class="fu">=</span> length (take n xs) <span class="fu">==</span> n

<span class="co">-- 11</span>
<span class="ot">prop_read ::</span> (<span class="dt">Eq</span> a, <span class="dt">Show</span> a, <span class="dt">Read</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
prop_read x <span class="fu">=</span> (read (show x)) <span class="fu">==</span> x 

<span class="co">-- Idempotence </span>
twice f <span class="fu">=</span> f <span class="fu">.</span> f
fourTimes <span class="fu">=</span> twice <span class="fu">.</span> twice

<span class="ot">idem1 ::</span>  <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
idem1 x <span class="fu">=</span> (capw x <span class="fu">==</span> twice capw x) <span class="fu">&amp;&amp;</span> (capw x <span class="fu">==</span> fourTimes capw x) <span class="kw">where</span>
  capw (x<span class="fu">:</span>xs) <span class="fu">=</span> (toUpper x) <span class="fu">:</span> xs
  capw [] <span class="fu">=</span> []

<span class="ot">idem2 ::</span> (<span class="dt">Eq</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
idem2 x <span class="fu">=</span> (sort x <span class="fu">==</span> twice sort x) <span class="fu">&amp;&amp;</span> (sort x <span class="fu">==</span> fourTimes sort x)

<span class="co">-- Make a Gen</span>
<span class="kw">data</span> <span class="dt">Fool</span> <span class="fu">=</span> <span class="dt">Fulse</span> <span class="fu">|</span> <span class="dt">Frue</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Fool</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> frequency [(<span class="dv">1</span>, return <span class="dt">Fulse</span>), (<span class="dv">1</span>, return <span class="dt">Frue</span>)]

<span class="ot">foolGen ::</span> <span class="dt">Gen</span> <span class="dt">Fool</span>
foolGen <span class="fu">=</span> arbitrary

<span class="ot">fulsishFoolGen ::</span> <span class="dt">Gen</span> <span class="dt">Fool</span>
fulsishFoolGen <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> arbitrary
  frequency [(<span class="dv">2</span>, return a), (<span class="dv">1</span>, return a)]

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  WN.main
  quickCheck (<span class="ot">prop_twiceHalf ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_sort ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">plusAssociative ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">plusCommutative ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">multAssociative ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">multCommutative ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">quotRemRule ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">divModRule ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">expAssociative ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">expCommutative ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">listReverse ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_apply ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_compose ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_compareCons ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_compareCons' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_compareConcat ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_take ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">prop_read ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck idem1 
  quickCheck (<span class="ot">idem2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</code></pre></div>
<h3 id="using-quickcheck">Using QuickCheck</h3>
<p>see <code>14/exercises/test/Spec.hs</code></p>
<h3 id="failure">Failure</h3>
<p>Irrational numbers like e.g. the sqaure root of 2 cannot be represented with infinite precision in a finite amount of memory. So an expression like (sqrt 2) is not actually equal to the square root of 2, but rather is an accurate approximation to some precision. So even though square is the inverse of square root, because sqrt cannot be infinitely accurate the square of a square root will have some error. E.g.</p>
<pre><code>sqrt 2 = 1.4142135, (sqrt 2) ^ 2 = 1.9999999</code></pre>
<h3 id="idempotence">Idempotence</h3>
<p>see <code>14/exercises/test/Spec.hs</code></p>
<h3 id="make-a-gen-random-generator-for-the-datatype">Make a Gen random generator for the datatype</h3>
<p>see <code>14/exercises/test/Spec.hs</code></p>
<h3 id="hangman-testing">Hangman testing</h3>
<h3 id="validating-ciphers">Validating ciphers</h3>
<p>skipping these, I think that this testing chapter is probably better understood after you understand what monads are. The reader here only barely has the tools to build something for which testing is important.</p>
<h2 id="follow-up-resources-8">14.9 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><a href="https://www.fpcomplete.com/user/pbv/an-introduction-to-quickcheck-testing">Pedro Vasconcelos; An introduction to QuickCheck testing;</a></li>
<li>Koen Claessen and John Hughes; (2000) QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs</li>
<li><a href="http://www.dcc.fc.up.pt/dcc/Pubs/TReports/TR13/dcc-2013-06.pdf">Pedro Vasconcelos;Verifying a Simple Compiler Using Property-based Random Testing;</a></li>
</ol>
<hr />
<h1 id="monoid-semigroup">15 Monoid, Semigroup</h1>
<h2 id="reusing-algebras-by-asking-for-algebras">15.10 Reusing algebras by asking for algebras</h2>
<h3 id="exercise-optional-monoid">Exercise: Optional Monoid</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--15/Optional.hs</span>
<span class="kw">module</span> <span class="dt">Optional</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="kw">data</span> <span class="dt">Optional</span> a <span class="fu">=</span> <span class="dt">Nada</span> <span class="fu">|</span> <span class="dt">Only</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Optional</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Nada</span>
  mappend <span class="dt">Nada</span> <span class="dt">Nada</span> <span class="fu">=</span> <span class="dt">Nada</span>
  mappend <span class="dt">Nada</span> (<span class="dt">Only</span> x) <span class="fu">=</span> (<span class="dt">Only</span> x)
  mappend (<span class="dt">Only</span> x) <span class="dt">Nada</span> <span class="fu">=</span> (<span class="dt">Only</span> x)
  mappend (<span class="dt">Only</span> x) (<span class="dt">Only</span> y) <span class="fu">=</span> (<span class="dt">Only</span> (mappend x y))</code></pre></div>
<h2 id="madness">15.11 Madness</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--15/Madness.hs</span>
<span class="kw">module</span> <span class="dt">Madness</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="kw">type</span> <span class="dt">Verb</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Adjective</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Adverb</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Noun</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">Exclamation</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="ot">madlibbin' ::</span> <span class="dt">Exclamation</span> <span class="ot">-&gt;</span> <span class="dt">Adverb</span> <span class="ot">-&gt;</span> <span class="dt">Noun</span> <span class="ot">-&gt;</span> <span class="dt">Adjective</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
madlibbin' e adv noun adj <span class="fu">=</span> 
  e <span class="fu">&lt;&gt;</span> <span class="st">&quot;! he said&quot;</span> <span class="fu">&lt;&gt;</span> adv <span class="fu">&lt;&gt;</span> <span class="st">&quot; as he jumped into his car &quot;</span> <span class="fu">&lt;&gt;</span>
  noun  <span class="fu">&lt;&gt;</span> <span class="st">&quot; and drove off with his &quot;</span> <span class="fu">&lt;&gt;</span> adj <span class="fu">&lt;&gt;</span> <span class="st">&quot; wife.&quot;</span>

<span class="ot">madlibbinBetter' ::</span> <span class="dt">Exclamation</span> <span class="ot">-&gt;</span> <span class="dt">Adverb</span> <span class="ot">-&gt;</span> <span class="dt">Noun</span> <span class="ot">-&gt;</span> <span class="dt">Adjective</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
madlibbinBetter' e adv noun adj <span class="fu">=</span> 
  mconcat [ e, <span class="st">&quot;! he said&quot;</span>, adv, <span class="st">&quot; as he jumped into his car &quot;</span>, noun  
          , <span class="st">&quot; and drove off with his &quot;</span>, adj,  <span class="st">&quot; wife.&quot;</span>
          ]</code></pre></div>
<h2 id="better-living-through-quickcheck">15.12 Better living through QuickCheck</h2>
<h3 id="testing-quickchecks-patience">Testing QuickCheck’s patience</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--15/Patience.hs</span>
<span class="kw">module</span> <span class="dt">Patience</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="kw">data</span> <span class="dt">Bull</span> <span class="fu">=</span> <span class="dt">Fools</span> <span class="fu">|</span> <span class="dt">Twoo</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bull</span> <span class="kw">where</span> 
  arbitrary <span class="fu">=</span> frequency [ (<span class="dv">1</span>, return <span class="dt">Fools</span>), (<span class="dv">1</span>, return <span class="dt">Twoo</span>) ]

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Bull</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Fools</span>
  mappend _ _ <span class="fu">=</span> <span class="dt">Fools</span>

<span class="kw">type</span> <span class="dt">BullMappend</span> <span class="fu">=</span> <span class="dt">Bull</span> <span class="ot">-&gt;</span> <span class="dt">Bull</span> <span class="ot">-&gt;</span> <span class="dt">Bull</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="ot">monoidAssoc ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidAssoc a b c <span class="fu">=</span> (a <span class="fu">&lt;&gt;</span> (b <span class="fu">&lt;&gt;</span> c)) <span class="fu">==</span> ((a <span class="fu">&lt;&gt;</span> b) <span class="fu">&lt;&gt;</span> c)

<span class="ot">monoidLeftIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidLeftIdentity a <span class="fu">=</span> (mempty <span class="fu">&lt;&gt;</span> a) <span class="fu">==</span> a

<span class="ot">monoidRightIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidRightIdentity a <span class="fu">=</span> (a <span class="fu">&lt;&gt;</span> mempty) <span class="fu">==</span> a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> ma <span class="fu">=</span> monoidAssoc
      mli <span class="fu">=</span> monoidLeftIdentity
      mlr <span class="fu">=</span> monoidRightIdentity
  quickCheck (<span class="ot">ma ::</span> <span class="dt">BullMappend</span>)
  quickCheck (<span class="ot">mli ::</span> <span class="dt">Bull</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">mlr ::</span> <span class="dt">Bull</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</code></pre></div>
<h3 id="exercise-maybe-another-monoid">Exercise: Maybe Another Monoid</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--15/MaybeAnother.hs</span>
<span class="kw">module</span> <span class="dt">MaybeAnother</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="kw">data</span> <span class="dt">Optional</span> a <span class="fu">=</span> <span class="dt">Nada</span> <span class="fu">|</span> <span class="dt">Only</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Optional</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Nada</span>
  mappend <span class="dt">Nada</span> <span class="dt">Nada</span> <span class="fu">=</span> <span class="dt">Nada</span>
  mappend <span class="dt">Nada</span> (<span class="dt">Only</span> x) <span class="fu">=</span> (<span class="dt">Only</span> x)
  mappend (<span class="dt">Only</span> x) <span class="dt">Nada</span> <span class="fu">=</span> (<span class="dt">Only</span> x)
  mappend (<span class="dt">Only</span> x) (<span class="dt">Only</span> y) <span class="fu">=</span> (<span class="dt">Only</span> (mappend x y))

<span class="kw">newtype</span> <span class="dt">First'</span> a <span class="fu">=</span> <span class="dt">First'</span> {<span class="ot"> getFirst' ::</span> <span class="dt">Optional</span> a } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">First'</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> arbitrary
    oneof [return (<span class="dt">First'</span> (<span class="dt">Only</span> a)), return (<span class="dt">First'</span> <span class="dt">Nada</span>)]

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">First'</span> a ) <span class="kw">where</span> 
  mempty <span class="fu">=</span> <span class="dt">First'</span> <span class="dt">Nada</span>
  mappend (<span class="dt">First'</span> <span class="dt">Nada</span>) (<span class="dt">First'</span> <span class="dt">Nada</span>) <span class="fu">=</span> (<span class="dt">First'</span> <span class="dt">Nada</span>)
  mappend (<span class="dt">First'</span> <span class="dt">Nada</span>) (<span class="dt">First'</span> (<span class="dt">Only</span> x)) <span class="fu">=</span> (<span class="dt">First'</span> (<span class="dt">Only</span> x))
  mappend (<span class="dt">First'</span> (<span class="dt">Only</span> x)) _ <span class="fu">=</span> (<span class="dt">First'</span> (<span class="dt">Only</span> x))

<span class="kw">type</span> <span class="dt">FirstMappend</span> <span class="fu">=</span> <span class="dt">First'</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">First'</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">First'</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="kw">type</span> <span class="dt">FstId</span> <span class="fu">=</span> <span class="dt">First'</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="ot">monoidAssoc ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidAssoc a b c <span class="fu">=</span> (a <span class="fu">&lt;&gt;</span> (b <span class="fu">&lt;&gt;</span> c)) <span class="fu">==</span> ((a <span class="fu">&lt;&gt;</span> b) <span class="fu">&lt;&gt;</span> c)

<span class="ot">monoidLeftIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidLeftIdentity a <span class="fu">=</span> (mempty <span class="fu">&lt;&gt;</span> a) <span class="fu">==</span> a

<span class="ot">monoidRightIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidRightIdentity a <span class="fu">=</span> (a <span class="fu">&lt;&gt;</span> mempty) <span class="fu">==</span> a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  quickCheck (<span class="ot">monoidAssoc ::</span> <span class="dt">FirstMappend</span>)
  quickCheck (<span class="ot">monoidLeftIdentity ::</span> <span class="dt">FstId</span>)
  quickCheck (<span class="ot">monoidRightIdentity ::</span> <span class="dt">FstId</span>)</code></pre></div>
<h2 id="chapter-exercises-13">15.15 Chapter Exercises</h2>
<h3 id="semigroup-exercises-monoid-exercises">Semigroup exercises &amp; Monoid exercises</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--15/SemigroupMonoidExercises.hs</span>
<span class="kw">module</span> <span class="dt">SemigroupMonoidExercises</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Gen.Unsafe</span>
<span class="kw">import </span><span class="dt">Data.Semigroup</span>
<span class="kw">import qualified</span> <span class="dt">Data.Monoid</span> <span class="kw">as</span> <span class="dt">M</span>

<span class="co">-- 1</span>
<span class="kw">data</span> <span class="dt">Trivial</span> <span class="fu">=</span> <span class="dt">Trivial</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Trivial</span> <span class="kw">where</span>
  _ <span class="fu">&lt;&gt;</span> _ <span class="fu">=</span> <span class="dt">Trivial</span> 

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Trivial</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Trivial</span>
  mappend <span class="fu">=</span> (<span class="fu">&lt;&gt;</span>) 

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Trivial</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> return <span class="dt">Trivial</span>

<span class="kw">type</span> <span class="dt">TrivAssoc</span> <span class="fu">=</span> <span class="dt">Trivial</span> <span class="ot">-&gt;</span> <span class="dt">Trivial</span> <span class="ot">-&gt;</span> <span class="dt">Trivial</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="co">-- 2</span>
<span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Identity</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span> 
    a' <span class="ot">&lt;-</span> arbitrary 
    return (<span class="dt">Identity</span> a')

<span class="kw">instance</span> (<span class="dt">Semigroup</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Identity</span> a) <span class="kw">where</span>
  (<span class="dt">Identity</span> a1) <span class="fu">&lt;&gt;</span> (<span class="dt">Identity</span> a2) <span class="fu">=</span> (<span class="dt">Identity</span> (a1 <span class="fu">&lt;&gt;</span> a2))

<span class="kw">instance</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Identity</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Identity</span> mempty
  mappend (<span class="dt">Identity</span> a) (<span class="dt">Identity</span> b) <span class="fu">=</span> <span class="dt">Identity</span> ((<span class="fu">M.&lt;&gt;</span>) a b)

<span class="co">-- instance Semigroup (Identity a) where</span>
<span class="co">--  (Identity a) &lt;&gt; _ = (Identity a)</span>

<span class="kw">type</span> <span class="dt">IdentAssoc</span> <span class="fu">=</span> <span class="dt">Identity</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Identity</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Identity</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> 

<span class="co">-- 3</span>
<span class="kw">data</span> <span class="dt">Two</span> a b <span class="fu">=</span> <span class="dt">Two</span> a b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Two</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a' <span class="ot">&lt;-</span> arbitrary  
    b' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Two</span> a' b')

<span class="kw">instance</span> (<span class="dt">Semigroup</span> a, <span class="dt">Semigroup</span> b) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Two</span> a b) <span class="kw">where</span>
  (<span class="dt">Two</span> a1 b1) <span class="fu">&lt;&gt;</span> (<span class="dt">Two</span> a2 b2) <span class="fu">=</span> <span class="dt">Two</span> (a1 <span class="fu">&lt;&gt;</span> a2) (b1 <span class="fu">&lt;&gt;</span> b2)

<span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Two</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Two</span> mempty mempty
  mappend (<span class="dt">Two</span> a1 b1) (<span class="dt">Two</span> a2 b2) <span class="fu">=</span> <span class="dt">Two</span> ((<span class="fu">M.&lt;&gt;</span>) a1 a2) ((<span class="fu">M.&lt;&gt;</span>) b1 b2)

<span class="kw">type</span> <span class="dt">TwoAssoc</span> <span class="fu">=</span> 
  (<span class="dt">Two</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Two</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Two</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span> 

<span class="co">-- 4</span>
<span class="kw">data</span> <span class="dt">Three</span> a b c <span class="fu">=</span> <span class="dt">Three</span> a b c <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b, <span class="dt">Arbitrary</span> c) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Three</span> a b c) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a' <span class="ot">&lt;-</span> arbitrary  
    b' <span class="ot">&lt;-</span> arbitrary
    c' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Three</span> a' b' c')

<span class="kw">instance</span> (<span class="dt">Semigroup</span> a, <span class="dt">Semigroup</span> b, <span class="dt">Semigroup</span> c) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Three</span> a b c) <span class="kw">where</span>
  (<span class="dt">Three</span> a1 b1 c1) <span class="fu">&lt;&gt;</span> (<span class="dt">Three</span> a2 b2 c2) <span class="fu">=</span> <span class="dt">Three</span> (a1 <span class="fu">&lt;&gt;</span> a2) (b1 <span class="fu">&lt;&gt;</span> b2) (c1 <span class="fu">&lt;&gt;</span> c2)

<span class="kw">type</span> <span class="dt">ThreeAssoc</span> <span class="fu">=</span> (<span class="dt">Three</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                  (<span class="dt">Three</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                  (<span class="dt">Three</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                  <span class="dt">Bool</span> 

<span class="co">-- 5</span>
<span class="kw">data</span> <span class="dt">Four</span> a b c d <span class="fu">=</span> <span class="dt">Four</span> a b c d <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b, <span class="dt">Arbitrary</span> c, <span class="dt">Arbitrary</span> d) <span class="ot">=&gt;</span> 
  <span class="dt">Arbitrary</span> (<span class="dt">Four</span> a b c d) <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="kw">do</span>
      a' <span class="ot">&lt;-</span> arbitrary  
      b' <span class="ot">&lt;-</span> arbitrary
      c' <span class="ot">&lt;-</span> arbitrary
      d' <span class="ot">&lt;-</span> arbitrary
      return (<span class="dt">Four</span> a' b' c' d')

<span class="kw">instance</span> (<span class="dt">Semigroup</span> a, <span class="dt">Semigroup</span> b, <span class="dt">Semigroup</span> c, <span class="dt">Semigroup</span> d) <span class="ot">=&gt;</span> 
  <span class="dt">Semigroup</span> (<span class="dt">Four</span> a b c d) <span class="kw">where</span>
    (<span class="dt">Four</span> a1 b1 c1 d1) <span class="fu">&lt;&gt;</span> (<span class="dt">Four</span> a2 b2 c2 d2) <span class="fu">=</span> 
      <span class="dt">Four</span> (a1 <span class="fu">&lt;&gt;</span> a2) (b1 <span class="fu">&lt;&gt;</span> b2) (c1 <span class="fu">&lt;&gt;</span> c2) (d1 <span class="fu">&lt;&gt;</span> d2)

<span class="kw">type</span> <span class="dt">FourAssoc</span> <span class="fu">=</span> (<span class="dt">Four</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                 (<span class="dt">Four</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                 (<span class="dt">Four</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                 <span class="dt">Bool</span> 

<span class="co">-- 6</span>
<span class="kw">newtype</span> <span class="dt">BoolConj</span> <span class="fu">=</span> <span class="dt">BoolConj</span> <span class="dt">Bool</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">BoolConj</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Bool</span>
    return (<span class="dt">BoolConj</span> a)

<span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">BoolConj</span> <span class="kw">where</span>
  (<span class="dt">BoolConj</span> <span class="dt">True</span>) <span class="fu">&lt;&gt;</span> (<span class="dt">BoolConj</span> <span class="dt">True</span>) <span class="fu">=</span> (<span class="dt">BoolConj</span> <span class="dt">True</span>)
  _ <span class="fu">&lt;&gt;</span> _ <span class="fu">=</span> (<span class="dt">BoolConj</span> <span class="dt">False</span>)

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">BoolConj</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">BoolConj</span> <span class="dt">True</span>
  mappend (<span class="dt">BoolConj</span> <span class="dt">True</span>) (<span class="dt">BoolConj</span> <span class="dt">True</span>) <span class="fu">=</span> (<span class="dt">BoolConj</span> <span class="dt">True</span>)
  mappend _ _ <span class="fu">=</span> (<span class="dt">BoolConj</span> <span class="dt">False</span>)

<span class="kw">type</span> <span class="dt">BoolConjAssoc</span> <span class="fu">=</span> <span class="dt">BoolConj</span> <span class="ot">-&gt;</span> <span class="dt">BoolConj</span> <span class="ot">-&gt;</span> <span class="dt">BoolConj</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="co">-- 7</span>
<span class="kw">newtype</span> <span class="dt">BoolDisj</span> <span class="fu">=</span> <span class="dt">BoolDisj</span> <span class="dt">Bool</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">BoolDisj</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;- arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Bool</span>
    return (<span class="dt">BoolDisj</span> a)

<span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">BoolDisj</span> <span class="kw">where</span>
  (<span class="dt">BoolDisj</span> <span class="dt">False</span>) <span class="fu">&lt;&gt;</span> (<span class="dt">BoolDisj</span> <span class="dt">False</span>) <span class="fu">=</span> (<span class="dt">BoolDisj</span> <span class="dt">False</span>)
  _ <span class="fu">&lt;&gt;</span> _ <span class="fu">=</span> (<span class="dt">BoolDisj</span> <span class="dt">True</span>)

<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">BoolDisj</span> <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">BoolDisj</span> <span class="dt">False</span>
  mappend (<span class="dt">BoolDisj</span> <span class="dt">False</span>) (<span class="dt">BoolDisj</span> <span class="dt">False</span>) <span class="fu">=</span> (<span class="dt">BoolDisj</span> <span class="dt">False</span>)
  mappend _ _ <span class="fu">=</span> (<span class="dt">BoolDisj</span> <span class="dt">True</span>)

<span class="kw">type</span> <span class="dt">BoolDisjAssoc</span> <span class="fu">=</span> <span class="dt">BoolDisj</span> <span class="ot">-&gt;</span> <span class="dt">BoolDisj</span> <span class="ot">-&gt;</span> <span class="dt">BoolDisj</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>

<span class="co">-- 8 </span>
<span class="kw">data</span> <span class="dt">Or</span> a b <span class="fu">=</span> <span class="dt">Fst</span> a <span class="fu">|</span> <span class="dt">Snd</span> b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Or</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a' <span class="ot">&lt;-</span> arbitrary  
    b' <span class="ot">&lt;-</span> arbitrary
    oneof [return (<span class="dt">Fst</span> a'), return (<span class="dt">Snd</span> b')]

<span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Or</span> a b) <span class="kw">where</span>
  (<span class="dt">Snd</span> b) <span class="fu">&lt;&gt;</span> _       <span class="fu">=</span> (<span class="dt">Snd</span> b)
  _       <span class="fu">&lt;&gt;</span> (<span class="dt">Snd</span> b) <span class="fu">=</span> (<span class="dt">Snd</span> b)
  _       <span class="fu">&lt;&gt;</span> (<span class="dt">Fst</span> a) <span class="fu">=</span> (<span class="dt">Fst</span> a)

<span class="kw">type</span> <span class="dt">OrAssoc</span> <span class="fu">=</span> 
  (<span class="dt">Or</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Or</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Or</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span> 

<span class="co">-- 9 </span>
<span class="kw">newtype</span> <span class="dt">Combine</span> a b <span class="fu">=</span> <span class="dt">Combine</span> {<span class="ot"> unCombine ::</span> (a <span class="ot">-&gt;</span> b) }

<span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Show</span> b) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Combine</span> a b) <span class="kw">where</span> 
  show _ <span class="fu">=</span> <span class="st">&quot;Combine&quot;</span>

<span class="kw">instance</span> (<span class="dt">Semigroup</span> b) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Combine</span> a b) <span class="kw">where</span>
  (<span class="dt">Combine</span> f) <span class="fu">&lt;&gt;</span> (<span class="dt">Combine</span> g) <span class="fu">=</span> <span class="dt">Combine</span> (\n <span class="ot">-&gt;</span> (f n) <span class="fu">&lt;&gt;</span> (g n))

<span class="kw">instance</span> (<span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Combine</span> a b) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Combine</span> (\n <span class="ot">-&gt;</span> mempty) 
  mappend (<span class="dt">Combine</span> f) (<span class="dt">Combine</span> g) <span class="fu">=</span> <span class="dt">Combine</span> (\n <span class="ot">-&gt;</span> (<span class="fu">M.&lt;&gt;</span>) (f n) (g n))

<span class="kw">instance</span> (<span class="dt">CoArbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Combine</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> fmap <span class="dt">Combine</span> <span class="fu">$</span> promote (\n <span class="ot">-&gt;</span> coarbitrary n arbitrary)

<span class="ot">combineAssoc ::</span> (<span class="dt">Combine</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                (<span class="dt">Combine</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                (<span class="dt">Combine</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                <span class="dt">String</span> <span class="ot">-&gt;</span> 
                <span class="dt">Bool</span> 
combineAssoc a b c s <span class="fu">=</span> 
  (unCombine (a <span class="fu">&lt;&gt;</span> (b <span class="fu">&lt;&gt;</span> c)) s) <span class="fu">==</span> (unCombine ((a <span class="fu">&lt;&gt;</span> b) <span class="fu">&lt;&gt;</span> c) s)

<span class="ot">combineLeftIdentity ::</span> (<span class="dt">Combine</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
combineLeftIdentity a s <span class="fu">=</span> ((unCombine (mempty <span class="fu">M.&lt;&gt;</span> a)) s) <span class="fu">==</span> ((unCombine a) s)

<span class="ot">combineRightIdentity ::</span> (<span class="dt">Combine</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
combineRightIdentity a s <span class="fu">=</span> ((unCombine (a <span class="fu">M.&lt;&gt;</span> mempty)) s) <span class="fu">==</span> ((unCombine a) s)


<span class="co">-- 10 </span>
<span class="kw">newtype</span> <span class="dt">Comp</span> a <span class="fu">=</span> <span class="dt">Comp</span> {<span class="ot"> unComp ::</span> (a <span class="ot">-&gt;</span> a) }

<span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Comp</span> a) <span class="kw">where</span> 
  show _ <span class="fu">=</span> <span class="st">&quot;Comp&quot;</span>

<span class="kw">instance</span> (<span class="dt">Semigroup</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Comp</span> a) <span class="kw">where</span>
  (<span class="dt">Comp</span> f) <span class="fu">&lt;&gt;</span> (<span class="dt">Comp</span> g) <span class="fu">=</span> <span class="dt">Comp</span> (f <span class="fu">.</span> g)

<span class="kw">instance</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Comp</span> a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Comp</span> id
  mappend (<span class="dt">Comp</span> f) (<span class="dt">Comp</span> g) <span class="fu">=</span> <span class="dt">Comp</span> (f <span class="fu">.</span> g)

<span class="kw">instance</span> (<span class="dt">CoArbitrary</span> a, <span class="dt">Arbitrary</span> a) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Comp</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> fmap <span class="dt">Comp</span> <span class="fu">$</span> promote (\n <span class="ot">-&gt;</span> coarbitrary n arbitrary)

<span class="ot">compAssoc ::</span> (<span class="dt">Comp</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Comp</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> (<span class="dt">Comp</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> 
compAssoc a b c s <span class="fu">=</span> (unComp (a <span class="fu">&lt;&gt;</span> (b <span class="fu">&lt;&gt;</span> c)) s) <span class="fu">==</span> (unComp ((a <span class="fu">&lt;&gt;</span> b) <span class="fu">&lt;&gt;</span> c) s)

<span class="ot">compLeftIdentity ::</span> (<span class="dt">Comp</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
compLeftIdentity a s <span class="fu">=</span> ((unComp (mempty <span class="fu">M.&lt;&gt;</span> a)) s) <span class="fu">==</span> ((unComp a) s)

<span class="ot">compRightIdentity ::</span> (<span class="dt">Comp</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
compRightIdentity a s <span class="fu">=</span> ((unComp (a <span class="fu">M.&lt;&gt;</span> mempty)) s) <span class="fu">==</span> ((unComp a) s)

<span class="co">-- 11 </span>
<span class="kw">data</span> <span class="dt">Validation</span> a b <span class="fu">=</span> <span class="dt">Fail</span> a <span class="fu">|</span> <span class="dt">Pass</span> b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Validation</span> a b) <span class="kw">where</span> 
  (<span class="dt">Fail</span> a) <span class="fu">&lt;&gt;</span> (<span class="dt">Fail</span> b) <span class="fu">=</span> (<span class="dt">Fail</span> (a <span class="fu">&lt;&gt;</span> b))
  _        <span class="fu">&lt;&gt;</span> (<span class="dt">Fail</span> a) <span class="fu">=</span> (<span class="dt">Fail</span> a)
  (<span class="dt">Fail</span> a) <span class="fu">&lt;&gt;</span> _        <span class="fu">=</span> (<span class="dt">Fail</span> a)
  _        <span class="fu">&lt;&gt;</span> (<span class="dt">Pass</span> b) <span class="fu">=</span> (<span class="dt">Pass</span> b)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Validation</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> arbitrary  
    b <span class="ot">&lt;-</span> arbitrary
    oneof [return (<span class="dt">Fail</span> a), return (<span class="dt">Pass</span> b)]

<span class="kw">type</span> <span class="dt">ValidationAssoc</span> <span class="fu">=</span> (<span class="dt">Validation</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                       (<span class="dt">Validation</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                       (<span class="dt">Validation</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                       <span class="dt">Bool</span> 

<span class="co">-- 12 </span>
<span class="kw">newtype</span> <span class="dt">AccRight</span> a b <span class="fu">=</span> <span class="dt">AccRight</span> (<span class="dt">Validation</span> a b) <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Semigroup</span> b) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">AccRight</span> a b) <span class="kw">where</span>
  (<span class="dt">AccRight</span> (<span class="dt">Pass</span> a)) <span class="fu">&lt;&gt;</span> (<span class="dt">AccRight</span> (<span class="dt">Pass</span> b)) <span class="fu">=</span> <span class="dt">AccRight</span> (<span class="dt">Pass</span> (a <span class="fu">&lt;&gt;</span> b))
  (<span class="dt">AccRight</span> (<span class="dt">Fail</span> a)) <span class="fu">&lt;&gt;</span> _                   <span class="fu">=</span> <span class="dt">AccRight</span> (<span class="dt">Fail</span> a)
  _                   <span class="fu">&lt;&gt;</span> (<span class="dt">AccRight</span> (<span class="dt">Fail</span> b)) <span class="fu">=</span> <span class="dt">AccRight</span> (<span class="dt">Fail</span> b)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">AccRight</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> arbitrary  
    b <span class="ot">&lt;-</span> arbitrary
    oneof [return (<span class="dt">AccRight</span> (<span class="dt">Fail</span> a)), return (<span class="dt">AccRight</span> (<span class="dt">Pass</span> b))]

<span class="kw">type</span> <span class="dt">AccRightAssoc</span> <span class="fu">=</span> (<span class="dt">AccRight</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                     (<span class="dt">AccRight</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                     (<span class="dt">AccRight</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                     <span class="dt">Bool</span> 

<span class="co">-- 13</span>
<span class="kw">newtype</span> <span class="dt">AccBoth</span> a b <span class="fu">=</span> <span class="dt">AccBoth</span> (<span class="dt">Validation</span> a b) <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Semigroup</span> a, <span class="dt">Semigroup</span> b) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">AccBoth</span> a b) <span class="kw">where</span>
  (<span class="dt">AccBoth</span> (<span class="dt">Pass</span> a)) <span class="fu">&lt;&gt;</span> (<span class="dt">AccBoth</span> (<span class="dt">Pass</span> b)) <span class="fu">=</span> <span class="dt">AccBoth</span> (<span class="dt">Pass</span> (a <span class="fu">&lt;&gt;</span> b))
  (<span class="dt">AccBoth</span> (<span class="dt">Fail</span> a)) <span class="fu">&lt;&gt;</span> (<span class="dt">AccBoth</span> (<span class="dt">Fail</span> b)) <span class="fu">=</span> <span class="dt">AccBoth</span> (<span class="dt">Fail</span> (a <span class="fu">&lt;&gt;</span> b))
  _                  <span class="fu">&lt;&gt;</span> (<span class="dt">AccBoth</span> (<span class="dt">Fail</span> b)) <span class="fu">=</span> <span class="dt">AccBoth</span> (<span class="dt">Fail</span> b)
  (<span class="dt">AccBoth</span> (<span class="dt">Fail</span> a)) <span class="fu">&lt;&gt;</span> _                  <span class="fu">=</span> <span class="dt">AccBoth</span> (<span class="dt">Fail</span> a)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">AccBoth</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> arbitrary  
    b <span class="ot">&lt;-</span> arbitrary
    oneof [return (<span class="dt">AccBoth</span> (<span class="dt">Fail</span> a)), return (<span class="dt">AccBoth</span> (<span class="dt">Pass</span> b))]

<span class="kw">type</span> <span class="dt">AccBothAssoc</span> <span class="fu">=</span> (<span class="dt">AccBoth</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                    (<span class="dt">AccBoth</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                    (<span class="dt">AccBoth</span> <span class="dt">String</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> 
                    <span class="dt">Bool</span> 
<span class="co">-- Testing</span>
<span class="ot">semigroupAssoc ::</span> (<span class="dt">Eq</span> m, <span class="dt">Semigroup</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
semigroupAssoc a b c <span class="fu">=</span> (a <span class="fu">&lt;&gt;</span> (b <span class="fu">&lt;&gt;</span> c)) <span class="fu">==</span> ((a <span class="fu">&lt;&gt;</span> b) <span class="fu">&lt;&gt;</span> c)

<span class="ot">monoidLeftIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidLeftIdentity a <span class="fu">=</span> ((<span class="fu">M.&lt;&gt;</span>) mempty a) <span class="fu">==</span> a

<span class="ot">monoidRightIdentity ::</span> (<span class="dt">Eq</span> m, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>
monoidRightIdentity a <span class="fu">=</span> ((<span class="fu">M.&lt;&gt;</span>) a mempty) <span class="fu">==</span> a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">TrivAssoc</span>)
  quickCheck (<span class="ot">monoidLeftIdentity ::</span> <span class="dt">Trivial</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">monoidRightIdentity ::</span> <span class="dt">Trivial</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">IdentAssoc</span>)
  quickCheck (<span class="ot">monoidLeftIdentity ::</span> <span class="dt">Identity</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">monoidRightIdentity ::</span> <span class="dt">Identity</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">TwoAssoc</span>)
  quickCheck (<span class="ot">monoidLeftIdentity ::</span> <span class="dt">Two</span> <span class="dt">String</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">monoidRightIdentity ::</span> <span class="dt">Two</span> <span class="dt">String</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">ThreeAssoc</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">FourAssoc</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">BoolConjAssoc</span>)
  quickCheck (<span class="ot">monoidLeftIdentity ::</span> <span class="dt">BoolConj</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">monoidRightIdentity ::</span> <span class="dt">BoolConj</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">BoolDisjAssoc</span>)
  quickCheck (<span class="ot">monoidLeftIdentity ::</span> <span class="dt">BoolDisj</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">monoidRightIdentity ::</span> <span class="dt">BoolDisj</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">OrAssoc</span>)
  quickCheck combineAssoc
  quickCheck combineLeftIdentity
  quickCheck combineRightIdentity
  quickCheck compAssoc
  quickCheck compLeftIdentity
  quickCheck compRightIdentity
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">ValidationAssoc</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">AccRightAssoc</span>)
  quickCheck (<span class="ot">semigroupAssoc ::</span> <span class="dt">AccBothAssoc</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--15/Mem.hs</span>
<span class="kw">module</span> <span class="dt">Mem</span> <span class="kw">where</span> 

<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>

<span class="kw">newtype</span> <span class="dt">Mem</span> s a <span class="fu">=</span> <span class="dt">Mem</span> {<span class="ot"> runMem ::</span> s <span class="ot">-&gt;</span> (a , s) }

<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Mem</span> s a) <span class="kw">where</span>
  mempty <span class="fu">=</span> <span class="dt">Mem</span> (\n <span class="ot">-&gt;</span> (mempty, n))
  mappend (<span class="dt">Mem</span> f) (<span class="dt">Mem</span> g) <span class="fu">=</span> <span class="dt">Mem</span> h <span class="kw">where</span>
    h <span class="fu">=</span> (\n <span class="ot">-&gt;</span> ((fst <span class="fu">$</span> f n) <span class="fu">&lt;&gt;</span> (fst <span class="fu">$</span> g n), snd <span class="fu">$</span> f <span class="fu">$</span> snd <span class="fu">$</span> g n))

f' <span class="fu">=</span> <span class="dt">Mem</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (<span class="st">&quot;hi&quot;</span>, s <span class="fu">+</span> <span class="dv">1</span>)

main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> rmzero <span class="fu">=</span> runMem mempty <span class="dv">0</span>
      rmleft <span class="fu">=</span> runMem (f' <span class="fu">&lt;&gt;</span> mempty) <span class="dv">0</span>
      rmright <span class="fu">=</span> runMem (mempty <span class="fu">&lt;&gt;</span> f') <span class="dv">0</span>
  print <span class="fu">$</span> rmleft
  print <span class="fu">$</span> rmright
  print <span class="fu">$</span> (<span class="ot">rmzero ::</span> (<span class="dt">String</span>, <span class="dt">Int</span>))
  print <span class="fu">$</span> rmleft <span class="fu">==</span> runMem f' <span class="dv">0</span>
  print <span class="fu">$</span> rmright <span class="fu">==</span> runMem f' <span class="dv">0</span></code></pre></div>
<h2 id="follow-up-resources-9">15.17 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li>Algebraic structure; Simple English Wikipedia</li>
<li>Haskell Monoids and Their Uses; Dan Piponi</li>
</ol>
<hr />
<h1 id="functor">16 Functor</h1>
<h2 id="lets-talk-about-4-baby">16.4 Let’s talk about 4, baby</h2>
<h3 id="excercises-be-kind">Excercises: Be Kind</h3>
<ol style="list-style-type: decimal">
<li><code>*</code></li>
<li><code>b</code> is <code>* -&gt; *</code>, <code>T</code> is <code>* -&gt; *</code></li>
<li><code>* -&gt; * -&gt; *</code></li>
</ol>
<h2 id="commonly-used-functors">16.7 Commonly used functors</h2>
<h3 id="exercises-heavy-lifting">Exercises: Heavy Lifting</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--16/HeavyLifting.hs</span>
<span class="kw">module</span> <span class="dt">HeavyLifting</span> <span class="kw">where</span>

<span class="co">-- 1 </span>
a <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">&lt;$&gt;</span> read <span class="st">&quot;[1]&quot;</span><span class="ot"> ::</span> [<span class="dt">Int</span>]

<span class="co">-- 2</span>
b <span class="fu">=</span> (fmap <span class="fu">.</span> fmap) (<span class="fu">++</span> <span class="st">&quot;lol&quot;</span>) (<span class="dt">Just</span> [<span class="st">&quot;Hi,&quot;</span>, <span class="st">&quot;Hello&quot;</span>])

<span class="co">-- 3</span>
c <span class="fu">=</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> x <span class="fu">-</span> <span class="dv">2</span>)

<span class="co">-- 4 </span>
d <span class="fu">=</span> ((return <span class="ch">'1'</span> <span class="fu">++</span>) <span class="fu">.</span> show) <span class="fu">.</span> (\x <span class="ot">-&gt;</span> [x, <span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>])

<span class="co">-- 5, this one is a lot less scary if you break it into its pieces first</span>
<span class="co">--    the input and output are both IO Integer and the rest is just legos</span>
<span class="ot">e ::</span> <span class="dt">IO</span> <span class="dt">Integer</span>
e <span class="fu">=</span> <span class="kw">let</span> ioi <span class="fu">=</span> readIO <span class="st">&quot;1&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Integer</span>
        changed <span class="fu">=</span> read <span class="fu">&lt;$&gt;</span> (<span class="st">&quot;123&quot;</span><span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> show <span class="fu">&lt;$&gt;</span> ioi
    <span class="kw">in</span> (<span class="fu">*</span><span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> changed</code></pre></div>
<h2 id="exercises-instances-of-func">16.10 Exercises: Instances of Func</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--16/FunctorInstances.hs</span>
<span class="kw">module</span> <span class="dt">FunctorInstances</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Function</span>

<span class="co">-- 1</span>
<span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Identity</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span> 
    a' <span class="ot">&lt;-</span> arbitrary 
    return (<span class="dt">Identity</span> a')

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span>
  fmap f (<span class="dt">Identity</span> a) <span class="fu">=</span> <span class="dt">Identity</span> (f a)

<span class="co">-- 2 </span>
<span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Pair</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span> 
    a <span class="ot">&lt;-</span> arbitrary 
    a' <span class="ot">&lt;-</span> arbitrary 
    return (<span class="dt">Pair</span> a a')

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Pair</span> <span class="kw">where</span>
  fmap f (<span class="dt">Pair</span> a a') <span class="fu">=</span> <span class="dt">Pair</span> (f a) (f a')

<span class="co">-- 3</span>
<span class="kw">data</span> <span class="dt">Two</span> a b <span class="fu">=</span> <span class="dt">Two</span> a b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Two</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a' <span class="ot">&lt;-</span> arbitrary  
    b' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Two</span> a' b')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Two</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Two</span> a b) <span class="fu">=</span> <span class="dt">Two</span> a (f b)

<span class="co">-- 4</span>
<span class="kw">data</span> <span class="dt">Three</span> a b c <span class="fu">=</span> <span class="dt">Three</span> a b c <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b, <span class="dt">Arbitrary</span> c) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Three</span> a b c) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a' <span class="ot">&lt;-</span> arbitrary  
    b' <span class="ot">&lt;-</span> arbitrary
    c' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Three</span> a' b' c')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Three</span> a b) <span class="kw">where</span>
  fmap f (<span class="dt">Three</span> a b c) <span class="fu">=</span> <span class="dt">Three</span> a b (f c)

<span class="co">-- 5</span>
<span class="kw">data</span> <span class="dt">Three'</span> a b <span class="fu">=</span> <span class="dt">Three'</span> a b b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Three'</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> arbitrary  
    b <span class="ot">&lt;-</span> arbitrary
    b' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Three'</span> a b b')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Three'</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Three'</span> a b b') <span class="fu">=</span> <span class="dt">Three'</span> a (f b) (f b')

<span class="co">-- 6</span>
<span class="kw">data</span> <span class="dt">Four</span> a b c d <span class="fu">=</span> <span class="dt">Four</span> a b c d <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b, <span class="dt">Arbitrary</span> c, <span class="dt">Arbitrary</span> d) <span class="ot">=&gt;</span> 
  <span class="dt">Arbitrary</span> (<span class="dt">Four</span> a b c d) <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="kw">do</span>
      a' <span class="ot">&lt;-</span> arbitrary  
      b' <span class="ot">&lt;-</span> arbitrary
      c' <span class="ot">&lt;-</span> arbitrary
      d' <span class="ot">&lt;-</span> arbitrary
      return (<span class="dt">Four</span> a' b' c' d')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Four</span> a b c) <span class="kw">where</span>
  fmap f (<span class="dt">Four</span> a b c d) <span class="fu">=</span> <span class="dt">Four</span> a b c (f d)

<span class="co">-- 7</span>
<span class="kw">data</span> <span class="dt">Four'</span> a b <span class="fu">=</span> <span class="dt">Four'</span> a a a b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Four'</span> a b) <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="kw">do</span>
      a <span class="ot">&lt;-</span> arbitrary  
      a' <span class="ot">&lt;-</span> arbitrary
      a'' <span class="ot">&lt;-</span> arbitrary
      b <span class="ot">&lt;-</span> arbitrary
      return (<span class="dt">Four'</span> a a' a'' b)

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Four'</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Four'</span> a a' a'' b) <span class="fu">=</span> <span class="dt">Four'</span> a a' a'' (f b)

<span class="co">-- Testing</span>
<span class="kw">type</span> <span class="dt">IntToInt</span> <span class="fu">=</span> <span class="dt">Fun</span> <span class="dt">Int</span> <span class="dt">Int</span>

<span class="ot">functorIdentity ::</span> (<span class="dt">Functor</span> f, <span class="dt">Eq</span> (f a)) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
functorIdentity f <span class="fu">=</span> fmap id f <span class="fu">==</span> f

<span class="ot">functorCompose ::</span> (<span class="dt">Eq</span> (f c), <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
functorCompose f g x <span class="fu">=</span> (fmap g (fmap f x)) <span class="fu">==</span> (fmap (g <span class="fu">.</span> f) x)

<span class="ot">functorCompose' ::</span> (<span class="dt">Eq</span> (f c), <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Fun</span> a b <span class="ot">-&gt;</span> <span class="dt">Fun</span> b c <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
functorCompose' (<span class="dt">Fun</span> _ f) (<span class="dt">Fun</span> _ g) x <span class="fu">=</span> (fmap g (fmap f x)) <span class="fu">==</span> (fmap (g <span class="fu">.</span> f) x)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  quickCheck (<span class="ot">functorIdentity ::</span> (<span class="dt">Identity</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorCompose' ::</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> (<span class="dt">Identity</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorIdentity ::</span> (<span class="dt">Pair</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorCompose' ::</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> (<span class="dt">Pair</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorIdentity ::</span> (<span class="dt">Two</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorCompose' ::</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> (<span class="dt">Two</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorIdentity ::</span> (<span class="dt">Three</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorCompose' ::</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> (<span class="dt">Three</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorIdentity ::</span> (<span class="dt">Three'</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorCompose' ::</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> (<span class="dt">Three'</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorIdentity ::</span> (<span class="dt">Four</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorCompose' ::</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> (<span class="dt">Four</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorIdentity ::</span> (<span class="dt">Four'</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)
  quickCheck (<span class="ot">functorCompose' ::</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> <span class="dt">IntToInt</span> <span class="ot">-&gt;</span> (<span class="dt">Four'</span> <span class="dt">Int</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</code></pre></div>
<ol start="8" style="list-style-type: decimal">
<li>Trivial doesn’t have anything inside it that fmap can apply a function to, fmap doesn’t make sense for things with kind <code>*</code>, or rather fmap on type constants is just function application, which is all f and no map.</li>
</ol>
<h2 id="ignoring-possibilities">16.11 Ignoring possibilities</h2>
<h3 id="exercise-possibly">Exercise: Possibly</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--16/PossiblyEither.hs</span>
<span class="kw">module</span> <span class="dt">PossiblyEither</span> <span class="kw">where</span>

<span class="kw">data</span> <span class="dt">Possibly</span> a <span class="fu">=</span> <span class="dt">LolNope</span> <span class="fu">|</span> <span class="dt">Yeppers</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Possibly</span> <span class="kw">where</span> 
  fmap f (<span class="dt">Yeppers</span> a) <span class="fu">=</span> <span class="dt">Yeppers</span> (f a)

<span class="kw">data</span> <span class="dt">Sum</span> a b <span class="fu">=</span> <span class="dt">First</span> a <span class="fu">|</span> <span class="dt">Second</span> b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)


<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Sum</span> a) <span class="kw">where</span> 
  fmap f (<span class="dt">Second</span> b) <span class="fu">=</span> <span class="dt">Second</span> (f b)
  fmap _ (<span class="dt">First</span> a) <span class="fu">=</span> <span class="dt">First</span> a</code></pre></div>
<h3 id="short-exercise">Short Exercise</h3>
<p>see PossiblyEither.hs</p>
<ol start="2" style="list-style-type: decimal">
<li>The <code>a</code> in <code>First a</code> might be a different type than the <code>b</code> in <code>Second b</code>. The function we pass to fmap can only operate on one of those types, but not both. In other words the function that fmap maps is of type <code>b -&gt; c</code> and kind <code>*</code>. Furthermore, we have to apply the function to <code>Second b</code> rather than <code>First a</code>, because the structure that fmaps maps onto is of kind <code>* -&gt; *</code>. Our structure is <code>(Sum a)</code> because <code>Sum</code> is of kind <code>* -&gt; * -&gt; *</code> and it needs to have accepted every type constructer but the last before its something that fmap can work on. But that doesn’t mean we’re barred from writing another function that does something different to <code>Sum</code>, but something different wont be fmap.</li>
</ol>
<h2 id="chapter-exercises-14">16.7 Chapter Exercises</h2>
<p>Determine if a valid Fucntor can be written for the datatype provided:</p>
<ol style="list-style-type: decimal">
<li>No, Bool has kind <code>*</code> but fmap only works on <code>* -&gt; *</code></li>
<li>Yes, note that <code>False'</code> and <code>True'</code> both take the same type <code>a</code></li>
<li>Yes, fmap can ignore <code>Falsish</code></li>
<li>Yes… but why…</li>
<li>Nope, theres nothing to fmap over, kind <code>*</code></li>
</ol>
<p>Rearrange the arguments:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--16/Rearrange.hs</span>
<span class="kw">module</span> <span class="dt">Rearrange</span> <span class="kw">where</span>

<span class="co">-- 1. </span>
<span class="kw">data</span> <span class="dt">Sum</span> b a <span class="fu">=</span> <span class="dt">First</span> a <span class="fu">|</span> <span class="dt">Second</span> b

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Sum</span> e) <span class="kw">where</span>
  fmap f (<span class="dt">First</span> a)<span class="fu">=</span> <span class="dt">First</span> (f a)
  fmap f (<span class="dt">Second</span> b) <span class="fu">=</span> <span class="dt">Second</span> b

<span class="co">-- 2. </span>
<span class="kw">data</span> <span class="dt">Company</span> a c b <span class="fu">=</span> <span class="dt">DeepBlue</span> a c <span class="fu">|</span> <span class="dt">Something</span> b

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Company</span> e e') <span class="kw">where</span>
  fmap f (<span class="dt">Something</span> b) <span class="fu">=</span> <span class="dt">Something</span> (f b)
  fmap _ (<span class="dt">DeepBlue</span> a c) <span class="fu">=</span> <span class="dt">DeepBlue</span> a c

<span class="co">-- 3.</span>
<span class="kw">data</span> <span class="dt">More</span> b a <span class="fu">=</span> <span class="dt">L</span> a b a <span class="fu">|</span> <span class="dt">R</span> b a b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">More</span> x) <span class="kw">where</span>
  fmap f (<span class="dt">L</span> a b a') <span class="fu">=</span> <span class="dt">L</span> (f a) b (f a')
  fmap f (<span class="dt">R</span> b a b') <span class="fu">=</span> <span class="dt">R</span> b (f a) b'</code></pre></div>
<p>Write Functor instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--16/Instances.hs</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="kw">module</span> <span class="dt">Instances</span> <span class="kw">where</span>

<span class="co">-- 1</span>
<span class="kw">data</span> <span class="dt">Quant</span> a b <span class="fu">=</span> <span class="dt">Finance</span> <span class="fu">|</span> <span class="dt">Desk</span> a <span class="fu">|</span> <span class="dt">Bloor</span> b

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Quant</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Bloor</span> b) <span class="fu">=</span> <span class="dt">Bloor</span> (f b)
  fmap _ (<span class="dt">Desk</span> a) <span class="fu">=</span> (<span class="dt">Desk</span> a)
  fmap _ <span class="dt">Finance</span> <span class="fu">=</span> <span class="dt">Finance</span>

<span class="co">-- 2</span>
<span class="kw">data</span> <span class="dt">K</span> a b <span class="fu">=</span> <span class="dt">K</span> a 

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">K</span> a) <span class="kw">where</span>
  fmap _ (<span class="dt">K</span> a) <span class="fu">=</span> (<span class="dt">K</span> a)

<span class="co">-- 3</span>
<span class="kw">newtype</span> <span class="dt">Flip</span> f a b <span class="fu">=</span> <span class="dt">Flip</span> (f b a) <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>) 

<span class="kw">newtype</span> <span class="dt">K'</span> a b <span class="fu">=</span> <span class="dt">K'</span> a

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Flip</span> <span class="dt">K'</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Flip</span> (<span class="dt">K'</span> a)) <span class="fu">=</span> <span class="dt">Flip</span> (<span class="dt">K'</span> (f a)) 

<span class="co">-- 4</span>
<span class="kw">data</span> <span class="dt">EvilGoateeConst</span> a b <span class="fu">=</span> <span class="dt">GoatyConst</span> b

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">EvilGoateeConst</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">GoatyConst</span> b) <span class="fu">=</span> <span class="dt">GoatyConst</span> (f b)

<span class="co">-- 5 </span>
<span class="kw">data</span> <span class="dt">LiftItOut</span> f a <span class="fu">=</span> <span class="dt">LiftItOut</span> (f a)

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">LiftItOut</span> f) <span class="kw">where</span>
  fmap f (<span class="dt">LiftItOut</span> fa ) <span class="fu">=</span> <span class="dt">LiftItOut</span> (fmap f fa)

<span class="co">-- 6 </span>
<span class="kw">data</span> <span class="dt">Parappa</span> f g a <span class="fu">=</span> <span class="dt">DaWrappa</span> (f a) (g a)

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Parappa</span> f g) <span class="kw">where</span>
  fmap f (<span class="dt">DaWrappa</span> fa gb) <span class="fu">=</span> <span class="dt">DaWrappa</span> (fmap f fa) (fmap f gb)

<span class="co">-- 7</span>

<span class="kw">data</span> <span class="dt">IgnoreOne</span> f g a b <span class="fu">=</span> <span class="dt">IgnoringSomething</span> (f a) (g b)

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">IgnoreOne</span> f g a) <span class="kw">where</span>
  fmap f (<span class="dt">IgnoringSomething</span> fa gb) <span class="fu">=</span> <span class="dt">IgnoringSomething</span> fa (fmap f gb)

<span class="co">-- 8</span>
<span class="kw">data</span> <span class="dt">Notorious</span> g o a t <span class="fu">=</span> <span class="dt">Notorious</span> (g o) (g a) (g t)

<span class="kw">instance</span> (<span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Notorious</span> g o a) <span class="kw">where</span>
  fmap f (<span class="dt">Notorious</span> go ga gt) <span class="fu">=</span> <span class="dt">Notorious</span> go ga (fmap f gt)

<span class="co">-- 9</span>
<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span>
  fmap f (<span class="dt">Cons</span> a l) <span class="fu">=</span> <span class="dt">Cons</span> (f a) (fmap f l)
  fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>

<span class="co">-- 10</span>

<span class="kw">data</span> <span class="dt">GLord</span> a <span class="fu">=</span> <span class="dt">NoG</span> <span class="fu">|</span> <span class="dt">OneG</span> a <span class="fu">|</span> <span class="dt">MoreG</span> (<span class="dt">GLord</span> a) (<span class="dt">GLord</span> a) (<span class="dt">GLord</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">GLord</span> <span class="kw">where</span>
  fmap f (<span class="dt">MoreG</span> g g' g'') <span class="fu">=</span> <span class="dt">MoreG</span> (fmap f g) (fmap f g') (fmap f g'')
  fmap f (<span class="dt">OneG</span> a) <span class="fu">=</span> <span class="dt">OneG</span> (f a)
  fmap _ <span class="dt">NoG</span> <span class="fu">=</span> <span class="dt">NoG</span>

<span class="co">-- 11</span>
<span class="kw">data</span> <span class="dt">TalkToMe</span> a <span class="fu">=</span> <span class="dt">Halt</span> <span class="fu">|</span> <span class="dt">Print</span> <span class="dt">String</span> a <span class="fu">|</span> <span class="dt">Read</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">TalkToMe</span> <span class="kw">where</span>
  fmap f (<span class="dt">Read</span> g) <span class="fu">=</span> <span class="dt">Read</span> (f <span class="fu">.</span> g)
  fmap f (<span class="dt">Print</span> s a) <span class="fu">=</span> <span class="dt">Print</span> s (f a)
  fmap _ <span class="dt">Halt</span> <span class="fu">=</span> <span class="dt">Halt</span></code></pre></div>
<h2 id="follow-up-resources-10">16.19 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p><a href="https://en.wikibooks.org/wiki/Haskell/The_Functor_class">Haskell Wikibook; The Functor class.</a></p></li>
<li><p>Mark P. Jones; A system of constructor classes: overloading and implicit higher-order polymorphism.</p></li>
<li><p>Gabriel Gonzalez; The functor design pattern.</p></li>
</ol>
<hr />
<h1 id="applicative">17 Applicative</h1>
<h2 id="applicative-in-use">17.5 Applicative in use</h2>
<h3 id="exercises-lookups">Exercises: Lookups</h3>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--17/Lookups.hs</span>
<span class="kw">module</span> <span class="dt">Lookups</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.List</span> (elemIndex)

<span class="co">-- 1</span>
<span class="ot">added ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
added <span class="fu">=</span> (<span class="fu">+</span><span class="dv">3</span>) <span class="fu">&lt;$&gt;</span> (lookup <span class="dv">3</span> <span class="fu">$</span> zip [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])

<span class="co">-- 2 </span>
<span class="ot">y ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
y <span class="fu">=</span> lookup <span class="dv">2</span> <span class="fu">$</span> zip [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]

<span class="ot">z ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
z <span class="fu">=</span> lookup <span class="dv">2</span> <span class="fu">$</span> zip [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]

<span class="ot">tupled ::</span> <span class="dt">Maybe</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)
tupled <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> y <span class="fu">&lt;*&gt;</span> z

<span class="ot">tupled2 ::</span> <span class="dt">Maybe</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>)
tupled2 <span class="fu">=</span> (pure (,)) <span class="fu">&lt;*&gt;</span> y <span class="fu">&lt;*&gt;</span> z

<span class="co">-- that's cool, the first tupled builds the function ((,) y) inside the maybe</span>
<span class="co">-- the second tupled lifts (,) inside the maybe then applies both args to it</span>

<span class="co">-- 3</span>
<span class="ot">x3 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
x3 <span class="fu">=</span> elemIndex <span class="dv">3</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]

<span class="ot">y3 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
y3 <span class="fu">=</span> elemIndex <span class="dv">4</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]

<span class="ot">max' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
max' <span class="fu">=</span> max

<span class="ot">maxed ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
maxed <span class="fu">=</span> (pure max') <span class="fu">&lt;*&gt;</span> x3 <span class="fu">&lt;*&gt;</span> y3

<span class="co">-- 4</span>
xs <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]
ys <span class="fu">=</span> [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]

<span class="ot">x4 ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
x4 <span class="fu">=</span> lookup <span class="dv">3</span> <span class="fu">$</span> zip xs ys

<span class="ot">y4 ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
y4 <span class="fu">=</span> lookup <span class="dv">2</span> <span class="fu">$</span> zip xs ys

<span class="ot">summed ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
summed <span class="fu">=</span> (pure sum) <span class="fu">&lt;*&gt;</span> ((,) <span class="fu">&lt;$&gt;</span> x4 <span class="fu">&lt;*&gt;</span> y4)

<span class="ot">summed2 ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>
summed2 <span class="fu">=</span> sum <span class="fu">&lt;$&gt;</span> ((,) <span class="fu">&lt;$&gt;</span> x4 <span class="fu">&lt;*&gt;</span> y4)</code></pre></div>
<h2 id="exercises-identity-instance">Exercises: Identity Instance</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--17/Identity.hs</span>
<span class="kw">module</span> <span class="dt">Identity</span> <span class="kw">where</span>

<span class="kw">newtype</span> <span class="dt">Identity</span> a <span class="fu">=</span> <span class="dt">Identity</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span>
  fmap f (<span class="dt">Identity</span> a) <span class="fu">=</span> <span class="dt">Identity</span> (f a) 

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Identity</span> <span class="kw">where</span>
  pure f <span class="fu">=</span> (<span class="dt">Identity</span> f) 
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Identity</span> f) (<span class="dt">Identity</span> a) <span class="fu">=</span> <span class="dt">Identity</span> (f a)</code></pre></div>
<h2 id="exercise-fixer-upper">Exercise: Fixer Upper</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--17/FixerUpper.hs</span>
<span class="kw">module</span> <span class="dt">FixerUpper</span> <span class="kw">where</span>

<span class="co">-- 1</span>
one <span class="fu">=</span> const <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="st">&quot;Hello&quot;</span> <span class="fu">&lt;*&gt;</span> (pure <span class="st">&quot;World&quot;</span>)

<span class="co">-- 2</span>
two <span class="fu">=</span> (,,,) <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">90</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="dv">10</span> <span class="fu">&lt;*&gt;</span> <span class="dt">Just</span> <span class="st">&quot;Tierness&quot;</span> <span class="fu">&lt;*&gt;</span> pure [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<h2 id="list-applicative-exercise">List Applicative Exercise</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--17/applicativeexercises/src/ListApplicative.hs</span>
<span class="kw">module</span> <span class="dt">ListApplicative</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Checkers</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Classes</span>

<span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a) <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span>
  fmap f (<span class="dt">Cons</span> a as) <span class="fu">=</span> <span class="dt">Cons</span> (f a) (fmap f as)
  fmap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">List</span> <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Cons</span> x <span class="dt">Nil</span>
  (<span class="fu">&lt;*&gt;</span>) _  <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span> 
  (<span class="fu">&lt;*&gt;</span>) <span class="dt">Nil</span> _ <span class="fu">=</span> <span class="dt">Nil</span> 
  (<span class="fu">&lt;*&gt;</span>) fs as <span class="fu">=</span> flatMap (flip fmap as) fs
<span class="co">--  (&lt;*&gt;) (Cons f fs) as = (fmap f as) `append` ((&lt;*&gt;) fs as)</span>
<span class="co">--  (&lt;*&gt;) fs as = flatMap (\f -&gt; fmap f as) fs</span>

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    as <span class="ot">&lt;-</span> arbitrary 
    return (mkList as)

<span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">List</span> a) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="kw">newtype</span> <span class="dt">ZipList'</span> a <span class="fu">=</span> <span class="dt">ZipList'</span> (<span class="dt">List</span> a) <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">ZipList'</span> a) <span class="kw">where</span>
  xs <span class="fu">=-=</span> ys <span class="fu">=</span> xs' <span class="ot">`eq`</span> ys'
    <span class="kw">where</span> xs' <span class="fu">=</span> <span class="kw">let</span> (<span class="dt">ZipList'</span> l) <span class="fu">=</span> xs
                <span class="kw">in</span> take' <span class="dv">3000</span> l
          ys' <span class="fu">=</span> <span class="kw">let</span> (<span class="dt">ZipList'</span> l) <span class="fu">=</span> ys
                <span class="kw">in</span> take' <span class="dv">3000</span> l

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ZipList'</span> <span class="kw">where</span>
  fmap f (<span class="dt">ZipList'</span> xs) <span class="fu">=</span> <span class="dt">ZipList'</span> <span class="fu">$</span> fmap f xs

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">ZipList'</span> <span class="kw">where</span>
  pure a <span class="fu">=</span> <span class="dt">ZipList'</span> <span class="fu">$</span> repeat' a 
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">ZipList'</span> fs) (<span class="dt">ZipList'</span> xs) <span class="fu">=</span> <span class="dt">ZipList'</span> (zipWith' fs xs)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">ZipList'</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    as <span class="ot">&lt;-</span> arbitrary 
    return (<span class="dt">ZipList'</span> as)

<span class="ot">zipWith' ::</span> <span class="dt">List</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b
zipWith' <span class="dt">Nil</span> _ <span class="fu">=</span> <span class="dt">Nil</span>
zipWith' _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span>
zipWith' (<span class="dt">Cons</span> f fs) (<span class="dt">Cons</span> x xs) <span class="fu">=</span> <span class="dt">Cons</span> (f x) <span class="fu">$</span> zipWith' fs xs

<span class="ot">take' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
take' n xs <span class="fu">=</span> go n <span class="dt">Nil</span> xs <span class="kw">where</span>
  go <span class="dv">0</span> ys _ <span class="fu">=</span> ys
  go n ys <span class="dt">Nil</span> <span class="fu">=</span> ys
  go n ys (<span class="dt">Cons</span> x xs) <span class="fu">=</span> go (n <span class="fu">-</span> <span class="dv">1</span>) (<span class="dt">Cons</span> x ys) xs

<span class="ot">repeat' ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
repeat' a <span class="fu">=</span> <span class="dt">Cons</span> a <span class="fu">$</span> (repeat' a)

<span class="ot">append ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
append <span class="dt">Nil</span> ys <span class="fu">=</span> ys
append (<span class="dt">Cons</span> x xs) ys <span class="fu">=</span> <span class="dt">Cons</span> x (append xs ys)

<span class="ot">fold ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> b
fold _ b <span class="dt">Nil</span> <span class="fu">=</span> b
fold f b (<span class="dt">Cons</span> h t) <span class="fu">=</span> f h (fold f b t)

<span class="ot">concat' ::</span> <span class="dt">List</span> (<span class="dt">List</span> a) <span class="ot">-&gt;</span> <span class="dt">List</span> a 
concat' <span class="fu">=</span> fold append <span class="dt">Nil</span>

<span class="ot">flatMap ::</span> (a <span class="ot">-&gt;</span> <span class="dt">List</span> b) <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b
flatMap f as <span class="fu">=</span> concat' (fmap f as)

<span class="ot">mkList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">List</span> a
mkList xs <span class="fu">=</span> foldr <span class="dt">Cons</span> <span class="dt">Nil</span> xs

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> test <span class="fu">=</span> [(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>)]<span class="ot"> ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]
  quickBatch <span class="fu">$</span> applicative (mkList test)
  quickBatch <span class="fu">$</span> applicative (<span class="dt">ZipList'</span> <span class="fu">$</span> mkList test)</code></pre></div>
<h2 id="ziplist-applicative-exercise">ZipList Applicative Exercise</h2>
<p>see <code>applicativeexercises/src/ListApplicative.hs</code></p>
<h2 id="exercise-variations-on-either">Exercise: Variations on Either</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--17/applicativeexercises/src/VariationEither.hs</span>
<span class="kw">module</span> <span class="dt">VariationEither</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Checkers</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Classes</span>

<span class="kw">data</span> <span class="dt">Validation'</span> e a <span class="fu">=</span> <span class="dt">Failure'</span> e <span class="fu">|</span> <span class="dt">Success'</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Validation'</span> e) <span class="kw">where</span>
  fmap f (<span class="dt">Success'</span> a) <span class="fu">=</span> <span class="dt">Success'</span> (f a)
  fmap f (<span class="dt">Failure'</span> e) <span class="fu">=</span> <span class="dt">Failure'</span> e

<span class="kw">instance</span> <span class="dt">Monoid</span> e <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Validation'</span> e) <span class="kw">where</span>
  pure a <span class="fu">=</span> <span class="dt">Success'</span> a
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Failure'</span> e) (<span class="dt">Failure'</span> r) <span class="fu">=</span> <span class="dt">Failure'</span> (e <span class="ot">`mappend`</span> r)
  (<span class="fu">&lt;*&gt;</span>) _           (<span class="dt">Failure'</span> e) <span class="fu">=</span> <span class="dt">Failure'</span> e
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Failure'</span> e) _           <span class="fu">=</span> <span class="dt">Failure'</span> e
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Success'</span> a) (<span class="dt">Success'</span> b) <span class="fu">=</span> <span class="dt">Success'</span> (a b)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> e, <span class="dt">Arbitrary</span> a) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Validation'</span> e a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> arbitrary
    e <span class="ot">&lt;-</span> arbitrary
    oneof [return (<span class="dt">Failure'</span> e), return (<span class="dt">Success'</span> a)]

<span class="kw">instance</span> (<span class="dt">Eq</span> e, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">Validation'</span> e a) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span><span class="ot"> test ::</span> <span class="dt">Validation'</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">String</span>) (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">String</span>)
      test <span class="fu">=</span> <span class="dt">Success'</span> (<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
  quickBatch <span class="fu">$</span> applicative test </code></pre></div>
<h2 id="chapter-exercises-15">17.9 Chapter Exercises</h2>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--17/applicativeexercises/src/ChapterExercises.hs</span>
<span class="kw">module</span> <span class="dt">ChapterExercises</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Checkers</span>
<span class="kw">import </span><span class="dt">Test.QuickCheck.Classes</span>

<span class="co">-- Specialize</span>
<span class="co">-- 1</span>
<span class="ot">listPure ::</span> a <span class="ot">-&gt;</span> [a]
listPure <span class="fu">=</span> pure 

<span class="ot">listApply ::</span> [(a <span class="ot">-&gt;</span> b)] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
listApply <span class="fu">=</span> (<span class="fu">&lt;*&gt;</span>) 

<span class="co">-- 2</span>
<span class="ot">ioPure ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
ioPure <span class="fu">=</span> pure 

<span class="ot">ioApply ::</span> <span class="dt">IO</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b
ioApply <span class="fu">=</span> (<span class="fu">&lt;*&gt;</span>)
 
<span class="co">-- 3</span>
<span class="ot">tuplePure  ::</span> (<span class="dt">Monoid</span> a, <span class="dt">Monoid</span> c) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (c, a)
tuplePure <span class="fu">=</span> pure

<span class="ot">tupleApply ::</span> (<span class="dt">Monoid</span> a, <span class="dt">Monoid</span> c) <span class="ot">=&gt;</span> (c, (a <span class="ot">-&gt;</span> b)) <span class="ot">-&gt;</span> (c, a) <span class="ot">-&gt;</span> (c, b)
tupleApply <span class="fu">=</span> (<span class="fu">&lt;*&gt;</span>)

<span class="co">-- 4</span>
<span class="ot">funcPure ::</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> a)
funcPure <span class="fu">=</span> pure

<span class="ot">funcApply ::</span> (e <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> b)
funcApply <span class="fu">=</span> (<span class="fu">&lt;*&gt;</span>)

<span class="co">-- Instances</span>
<span class="co">-- 1 </span>
<span class="kw">data</span> <span class="dt">Pair</span> a <span class="fu">=</span> <span class="dt">Pair</span> a a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Arbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Pair</span> a) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span> 
    a <span class="ot">&lt;-</span> arbitrary 
    a' <span class="ot">&lt;-</span> arbitrary 
    return (<span class="dt">Pair</span> a a')

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Pair</span> <span class="kw">where</span>
  fmap f (<span class="dt">Pair</span> a a') <span class="fu">=</span> <span class="dt">Pair</span> (f a) (f a')

<span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Pair</span> <span class="kw">where</span>
  pure a <span class="fu">=</span> <span class="dt">Pair</span> a a 
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Pair</span> f f') (<span class="dt">Pair</span> a a') <span class="fu">=</span> <span class="dt">Pair</span> (f a) (f' a')

<span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">Pair</span> a) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="co">-- 2 </span>
<span class="kw">data</span> <span class="dt">Two</span> a b <span class="fu">=</span> <span class="dt">Two</span> a b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Two</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a' <span class="ot">&lt;-</span> arbitrary  
    b' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Two</span> a' b')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Two</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Two</span> a b) <span class="fu">=</span> <span class="dt">Two</span> a (f b)

<span class="kw">instance</span> <span class="dt">Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Two</span> a) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Two</span> mempty x
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Two</span> a b) (<span class="dt">Two</span> c d) <span class="fu">=</span> <span class="dt">Two</span> (a <span class="fu">&lt;&gt;</span> c) (b d)

<span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> b) <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">Two</span> a b) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="co">-- 3</span>
<span class="kw">data</span> <span class="dt">Three</span> a b c <span class="fu">=</span> <span class="dt">Three</span> a b c <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b, <span class="dt">Arbitrary</span> c) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Three</span> a b c) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a' <span class="ot">&lt;-</span> arbitrary  
    b' <span class="ot">&lt;-</span> arbitrary
    c' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Three</span> a' b' c')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Three</span> a b) <span class="kw">where</span>
  fmap f (<span class="dt">Three</span> a b c) <span class="fu">=</span> <span class="dt">Three</span> a b (f c)

<span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Monoid</span> b) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Three</span> a b) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Three</span> mempty mempty x
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Three</span> a b c) (<span class="dt">Three</span> e f g) <span class="fu">=</span> <span class="dt">Three</span> (a <span class="fu">&lt;&gt;</span> e) (b <span class="fu">&lt;&gt;</span> f) (c g)

<span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> b, <span class="dt">Eq</span> c) <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">Three</span> a b c) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="co">-- 4</span>

<span class="kw">data</span> <span class="dt">Three'</span> a b <span class="fu">=</span> <span class="dt">Three'</span> a b b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Three'</span> a b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> arbitrary  
    b <span class="ot">&lt;-</span> arbitrary
    b' <span class="ot">&lt;-</span> arbitrary
    return (<span class="dt">Three'</span> a b b')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Three'</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Three'</span> a b b') <span class="fu">=</span> <span class="dt">Three'</span> a (f b) (f b')

<span class="kw">instance</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Three'</span> a) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Three'</span> mempty x x
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Three'</span> a b c) (<span class="dt">Three'</span> e f g) <span class="fu">=</span> <span class="dt">Three'</span> (a <span class="fu">&lt;&gt;</span> e) (b f) (c g)

<span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> b) <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">Three'</span> a b ) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="co">-- 5</span>

<span class="kw">data</span> <span class="dt">Four</span> a b c d <span class="fu">=</span> <span class="dt">Four</span> a b c d <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b, <span class="dt">Arbitrary</span> c, <span class="dt">Arbitrary</span> d) <span class="ot">=&gt;</span> 
  <span class="dt">Arbitrary</span> (<span class="dt">Four</span> a b c d) <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="kw">do</span>
      a' <span class="ot">&lt;-</span> arbitrary  
      b' <span class="ot">&lt;-</span> arbitrary
      c' <span class="ot">&lt;-</span> arbitrary
      d' <span class="ot">&lt;-</span> arbitrary
      return (<span class="dt">Four</span> a' b' c' d')

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Four</span> a b c) <span class="kw">where</span>
  fmap f (<span class="dt">Four</span> a b c d) <span class="fu">=</span> <span class="dt">Four</span> a b c (f d)

<span class="kw">instance</span> (<span class="dt">Monoid</span> a, <span class="dt">Monoid</span> b, <span class="dt">Monoid</span> c) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Four</span> a b c) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Four</span> mempty mempty mempty x
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Four</span> a b c d) (<span class="dt">Four</span> e f g h) <span class="fu">=</span> <span class="dt">Four</span> (a <span class="fu">&lt;&gt;</span> e) (b <span class="fu">&lt;&gt;</span> f) (c <span class="fu">&lt;&gt;</span> g) (d h)

<span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> b, <span class="dt">Eq</span> c, <span class="dt">Eq</span> d) <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">Four</span> a b c d) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="co">-- 6</span>

<span class="kw">data</span> <span class="dt">Four'</span> a b <span class="fu">=</span> <span class="dt">Four'</span> a a a b <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> (<span class="dt">Arbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (<span class="dt">Four'</span> a b) <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="kw">do</span>
      a <span class="ot">&lt;-</span> arbitrary  
      a' <span class="ot">&lt;-</span> arbitrary
      a'' <span class="ot">&lt;-</span> arbitrary
      b <span class="ot">&lt;-</span> arbitrary
      return (<span class="dt">Four'</span> a a' a'' b)

<span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Four'</span> a) <span class="kw">where</span>
  fmap f (<span class="dt">Four'</span> a a' a'' b) <span class="fu">=</span> <span class="dt">Four'</span> a a' a'' (f b)

<span class="kw">instance</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Four'</span> a) <span class="kw">where</span>
  pure x <span class="fu">=</span> <span class="dt">Four'</span> mempty mempty mempty x
  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">Four'</span> a b c d) (<span class="dt">Four'</span> e f g h) <span class="fu">=</span> <span class="dt">Four'</span> (a <span class="fu">&lt;&gt;</span> e) (b <span class="fu">&lt;&gt;</span> f) (c <span class="fu">&lt;&gt;</span> g) (d h)

<span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Eq</span> b) <span class="ot">=&gt;</span> <span class="dt">EqProp</span> (<span class="dt">Four'</span> a b) <span class="kw">where</span>
  (<span class="fu">=-=</span>) <span class="fu">=</span> eq

<span class="co">-- Combinations</span>

<span class="ot">stops ::</span> <span class="dt">String</span>
stops <span class="fu">=</span> <span class="st">&quot;pbtdkg&quot;</span>

<span class="ot">vowels ::</span> <span class="dt">String</span>
vowels <span class="fu">=</span> <span class="st">&quot;aeiou&quot;</span>

<span class="ot">combos ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c] <span class="ot">-&gt;</span> [(a, b, c)]
<span class="co">-- combos a b c = liftA3 (\a b c -&gt; (a, b, c)) a b c</span>
combos a b c <span class="fu">=</span> liftA3 (,,) a b c

<span class="co">-- Testing</span>

test <span class="fu">=</span> (<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> test <span class="fu">=</span> (<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
  quickBatch <span class="fu">$</span> applicative (<span class="dt">Pair</span> test test)
  quickBatch <span class="fu">$</span> applicative (<span class="dt">Two</span> test test)
  quickBatch <span class="fu">$</span> applicative (<span class="dt">Three</span> test test test)
  quickBatch <span class="fu">$</span> applicative (<span class="dt">Three'</span> test test test)
  quickBatch <span class="fu">$</span> applicative (<span class="dt">Four</span> test test test test)
  quickBatch <span class="fu">$</span> applicative (<span class="dt">Four'</span> test test test test)</code></pre></div>
<h2 id="follow-up-resources-11">17.11 Follow-up resources</h2>
<ol style="list-style-type: decimal">
<li><p><a href="http://hackage.haskell.org/package/validation">Tony Morris; Nick Partridge; Validation library</a></p></li>
<li><p><a href="http://staff.city.ac.uk/~ross/papers/Applicative.html">Conor McBride; Ross Paterson; Applicative Programming with Effects</a></p></li>
<li><p>Jeremy Gibbons; Bruno C. d. S. Oliveira; Essence of the Iterator Pattern</p></li>
<li><p><a href="http://staff.city.ac.uk/~ross/papers/Constructors.html">Ross Paterson; Constructing Applicative Functors</a></p></li>
</ol>
<p>5.Sam Lindley; Philip Wadler; Jeremy Yallop; Idioms are oblivi- ous, arrows are meticulous, monads are promiscuous. Note:Idiom means applicative functor and is a useful search term for published work on applicative functors.</p>
<hr />
<h1 id="monad">18 Monad</h1>

        </div>
        <div id="footer">
          <p>&copy; <script>document.write(new Date().getFullYear());</script>
             John Chandler Burnham. 
            Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a> 
          </p>
        </div>
    </body>
</html>
