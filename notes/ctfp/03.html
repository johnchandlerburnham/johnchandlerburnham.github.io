<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>John Chandler Burnham - Notes (CTFP 03/31): Categories Great and Small</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../../">jcb</a>
                <a href="../../posts.html">posts</a>
                <a href="../../projects.html">projects</a>
                <a href="https://github.com/johnchandlerburnham">github</a>
                <a href="https://twitter.com/John_C_Burnham">twitter</a>
            </div>
        </div>
        <div id="content">
            <h1>Notes (CTFP 03/31): Categories Great and Small</h1>
          <div id="title" class="info">
    Posted on December 15, 2017
    
        by jcb
    
<hr>
</div>

<h1 id="categories-great-and-small">3 Categories Great and Small</h1>
<h2 id="no-objects">3.1 No objects</h2>
<p>The empty category!</p>
<h2 id="simple-graphs">3.2 Simple Graphs</h2>
<p><strong>free category</strong>: A category generated by a directed graph by turning nodes into objects, edges into arrows and adding new edges for every composition of arrows.</p>
<p>Okay so generating free categories is what I was doing in chapter 2 that was confusing me. Subtle!</p>
<h2 id="orders">3.3 Orders</h2>
<p><strong>preorder</strong>: If a set <code>P</code> has a binary relation <code>pre :: P -&gt; P -&gt; Bool</code> such that for all</p>
<pre><code>x :: P, y :: P, z :: P

pre x x = True                      -- reflexive
pre x y &amp;&amp; pre y z =&gt; pre x z       -- transitive</code></pre>
<p>Then <code>pre</code> is a preorder.</p>
<p><strong>partial order</strong>: If a set <code>P</code> has a binary relation <code>part :: P -&gt; P -&gt; Bool</code> such that for all</p>
<pre><code>x :: P, y :: P

part x y = pre x y                 -- part is a preorder
part x y &amp;&amp; part y x =&gt; x == y     -- antisymmetric</code></pre>
<p>then <code>part</code> is a partial order</p>
<p><strong>total order</strong>: If a set <code>P</code> has a binary relation <code>tot :: P -&gt; P -&gt; Bool</code>, such that for all</p>
<pre><code>x :: P, y :: P

tot x y = part x y                 -- tot is a partial order
tot x y || tot y x = True          -- total (defined for all P)</code></pre>
<p>then <code>tot</code> is a total order.`</p>
<p><strong>thin category</strong>: A category where between any two objects <code>X</code> and <code>Y</code> there is at most one arrow <code>X -&gt; Y</code> from <code>X</code> to <code>Y</code>.</p>
<p><strong>hom-set</strong>: The set of arrows from an object <code>X</code> to an object <code>Y</code>.</p>
<pre><code>hom-set :: Category -&gt; Object -&gt; Object -&gt; {Arrow}</code></pre>
<p>I don’t really like the name “hom-set”. I get that “hom” stands for “homomorphism”, but I hate using apocope (eliding syllables from the ends of words) to generate new terms. It’s slangy, offloads important “info” onto implicit context, sounds ugly and confuses me. Hate it.</p>
<p>I’ve read that some books use “morphisms” as a way to describe “hom-set”. That’s a lot better, but still not perfect…</p>
<p>I kind of like thinking about the set of morphisms from <code>X</code> to <code>Y</code> as the “volley” of arrows from <code>X</code> to <code>Y</code>. I especially like that “volley” comes from Latin “volare: to fly”. And that’s really what we’re after, which arrows “fly” from <code>X</code> to <code>Y</code>:</p>
<pre><code>volley :: Category -&gt; Object -&gt; Object -&gt; {Arrow}</code></pre>
<p>We’ll also need term for all the arrow in a whole category, not just between two ojects:</p>
<pre><code>vol :: Category -&gt; {Arrow}</code></pre>
<p>Okay, it’s another apocope, but this is actually a meaningful one. “Vol” is a French word meaning “flight”. And we can think of all the arrows in a category as being like a “flock” or a “flight” of arrows.</p>
<p>I’ve also read that the vol (hom-set) of a category is not necessarily a set. So I think the term “hom-set” really fails utterly in all parts for clearly conveying the concept.</p>
<p>I’m going to use my own made-up “vol”, “volley” terminology, mostly because I think it’s pretty. I’ll try to include definitions whenever I stray to far from this context:</p>
<pre><code>volley C a b = hom-set_C(a, b)
vol C = all morphisms of C</code></pre>
<p>[TODO: Extend archery terminology to other category theory concepts]</p>
<h2 id="monoid-as-set">3.4 Monoid as Set</h2>
<p><strong>monoid</strong> A set <code>M</code> with a binary operation</p>
<pre><code>mappend :: M -&gt; M -&gt; M</code></pre>
<p>and an element `</p>
<pre><code>mempty :: M</code></pre>
<p>such that for all</p>
<pre><code>a :: M, b :: M, c :: M

mappend (mappend a b) c = mappend a (mappend b c)  -- associative
mappend mempty a = mappend a mempty = a            -- identity element</code></pre>
<p>Addition of integers is a monoid:</p>
<pre><code>(a + b) + c = a + (b + c)
0 + a = a + 0 = a</code></pre>
<p>So is multiplication of integers:</p>
<pre><code>(a * b) * c = a * (b * c)
1 * a = a * 1 = a</code></pre>
<h2 id="monoid-as-category">3.5 Monoid as Category</h2>
<p>Treat <code>M</code> as an object, rather than a set. We can convert all elements of <code>M</code> into arrows:</p>
<p>The identity element turns into the identity arrow:</p>
<pre><code>mappend a mempty = mappend mempty a = id_M a = a id_M = a  -- identity arrow</code></pre>
<p>And every element <code>x</code> of <code>M</code> turns into:</p>
<pre><code>mappend x :: M -&gt; M</code></pre>
<p>where composition of arrows becomes:</p>
<pre><code>(mappend x1) . (mappend x2) = (mappend (mappend x1 x2)) :: M -&gt; M</code></pre>
<p>E.g, if the monoid is addition of integers:</p>
<pre><code>(+ 2) . (+ 3) = (+ (2 + 3)) = (+ 5)</code></pre>
<p>And since <code>mappend</code> is associative, so is composition</p>
<pre><code>(mappend x1) . (mappend x2) . (mappend x3)
= ((mappend x1) . (mappend x2)) . (mappend x3)
= (mappend (mappend x1 x2)) . (mappend x3)
= mappend (mappend (mappend x1 x2) x3)
= mappend (mappend x1 (mappend x2 x3))
= (mappend x1) . (mappend (mappend x2 x3))
= (mappend x1) . ((mappend x2) . (mappend x3))</code></pre>
<p>E.g. with the integer addition monoid:</p>
<pre><code>(+2) . (+3) . (+4) = ((+5) . (+4)) = (+9)
                   = ((+2) . (+7)) = (+9)</code></pre>
<p>And thus we’ve turned <code>M</code> into a category!</p>
<p>And we can just as easily turn <code>M</code> back into a set by taking the set of arrow with <code>vol :: Category -&gt; {Arrow}</code>, (hom-set).</p>
<h2 id="challenges">3.6 Challenges</h2>
<ol style="list-style-type: decimal">
<li><ol style="list-style-type: lower-alpha">
<li><p>Graph <code>G</code> with node <code>A</code> and no edges. Adding</p>
<pre><code>id_a :: A -&gt; A</code></pre>
<p>Gives a category.</p></li>
<li>This is a category</li>
<li><p>Graph <code>G</code> with nodes <code>A</code>, <code>B</code> and edge <code>A -&gt; B</code>. Adding</p>
<pre><code>id_A :: A -&gt; A
id_B :: B -&gt; B</code></pre>
<p>Gives a category.</p></li>
<li><p>Let the single node be the object <code>String</code>. from each edge generate prepender and appender arrows for each letter, so the <code>'a'</code> edge becomes <code>(++ &quot;a&quot;)</code> and <code>(&quot;a&quot; ++)</code>. Then add an empty string (++ “”) arrow, which is the identity. Then add arrows for the compositions of all arrows. And now we have the <code>String</code> monoid category.</p></li>
</ol></li>
<li><ol style="list-style-type: lower-alpha">
<li><p>Inclusion is</p>
<ul>
<li>reflexive, since by definition all elements of <code>A</code> are in <code>A</code></li>
<li>transitive, since if <code>A</code> is in <code>B</code> all elements of <code>A</code> are also in <code>B</code></li>
<li>antisymmetric, since if <code>A</code> is in <code>B</code> and <code>B</code> is in <code>A</code>. there are no elements that they do not share, so all their elements are the same, and thus <code>A == B</code></li>
<li>not necessarily total from the information given. If the set of sets is the set of sets of integers, for example, then <code>{1}, {2}</code> are both in the set, but <code>{2}</code> is not in <code>{1}</code> and <code>{1}</code> is not in <code>{2}</code>.</li>
</ul>
<p>But if the set of sets is, e.g. the set of the empty set <code>{{}}</code>, then the inclusion relation could be total. So this is actually an interesting question:</p>
<p>I think we can define this recursively: a set with total order is either the empty set or a set of sets with total order:</p>
<p><code>T-Set = {} | Set T</code></p>
<p>But then the question is how complicated does this set get? Because all the Von Neumann ordinals:</p>
<p><code>0 = {}   1 = {0} = {{}}   2 = {1} = {{{}}}   ...</code> are in <code>T-set</code>.</p>
<p>Oh, actually, this doesn’t work, because the inclusion relation the question only goes one level deep, I think. <code>A,B,C,D</code> are not elements of <code>{{A, B}, {C, D}}</code>, so <code>0</code> is not in <code>2</code> with Von Neumann encoding.</p>
<p>But if we changed our inclusion relation to:</p>
<p><code>A</code> is in <code>B</code> if all the elements of <code>A</code> are <em>included</em> in elements of <code>B</code>.</p>
<p>Then I think we get the <code>T-Set</code> above for all the sets with total order.</p>
<p>But I’m at the limits of my set theory here. I think I’ll add a book to my reading list and come back to this.</p>
<p>[TODO. Do a workthrough on set theory]</p></li>
<li><p>Skipping. Don’t care about <code>C++</code></p></li>
</ol></li>
<li><p>And-Monoid:</p>
<pre><code>mempty = True
mappend = (&amp;&amp;)

x &amp;&amp; True = x
True &amp;&amp; x = x

(x &amp;&amp; y) &amp;&amp; z = z &amp;&amp; (y &amp;&amp; z)</code></pre>
<p>Or-Monoid:</p>
<pre><code>mempty = False
mappend = (||)

x || False = x
False || x = x

(x || y) || z = z || (y || z)</code></pre></li>
<li><p>Bool Monoid Category, has object bool and arrows:</p>
<pre><code>andTrue :: Bool -&gt; Bool   -- identity
andFalse :: Bool -&gt; Bool  -- always returns false

andFalse . andFalse = andFalse</code></pre>
<p>And is commutative, so thats all there is.</p></li>
<li><p>Addition Mod 3, has object Int3 and arrows:</p>
<pre><code>(+ 0) :: Int3 -&gt; Int3    -- identity
(+ 1) :: Int3 -&gt; Int3
(+ 2) :: Int3 -&gt; Int3

(+ 1) . (+ 2) = (+ 2) . (+ 1) = (+ 0)
(+ 1) . (+ 1) = (+ 2)
(+ 2) . (+ 2) = (+ 1)</code></pre></li>
</ol>

        </div>
        <div id="footer">
          <p>&copy; <script>document.write(new Date().getFullYear());</script>
             John Chandler Burnham.
            Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </p>
        </div>
    </body>
</html>
