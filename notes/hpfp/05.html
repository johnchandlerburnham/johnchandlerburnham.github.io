<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>John Chandler Burnham - Notes (HPFP 05/31): Types</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="navigation">
                <a href="../../">jcb</a>
                <a href="../../posts.html">posts</a>
                <a href="../../projects.html">projects</a>
                <a href="https://github.com/johnchandlerburnham">github</a>
                <a href="https://twitter.com/John_C_Burnham">twitter</a>
            </div>
        </div>
        <div id="content">
            <h1>Notes (HPFP 05/31): Types</h1>
          <div id="title" class="info">
    Posted on November  1, 2017
    
        by jcb
    
<hr>
</div>

<h1 id="types">5 Types</h1>
<p>I want to acknowledge how apt and lovely the quote at the beginning of this chapter is. It is an excerpt from the Wallace Stevens poem: <a href="https://www.poetryfoundation.org/poems/43431/the-idea-of-order-at-key-west">The Idea of Order at Key West</a></p>
<h2 id="how-to-read-type-signatures">5.3 How to read type signatures</h2>
<p>The type constructor for function <code>(-&gt;)</code> isn’t magic. It’s exactly like any other type constructor. Recall how previously with lists the type constructor was <code>[]</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i []</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">data</span> [] a <span class="fu">=</span> [] <span class="fu">|</span> a <span class="fu">:</span> [a]  <span class="co">-- Defined in ‘GHC.Types’</span></a></code></pre></div>
<p>There isn’t any reason other than cleaner syntax that <code>[] a</code> or <code>[a]</code> couldn’t be <code>List a</code>.</p>
<p>Well the function type is almost exactly the same. There isn’t any reason why <code>a -&gt; b</code>, which is <code>(-&gt;) a b</code>, couldn’t be <code>Fun a b</code>. It’s just more syntactic sugar (Haskell is a very sugary language. That’s why it’s so sweet!)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">Prelude</span><span class="fu">&gt;</span> <span class="fu">:</span>i (<span class="ot">-&gt;</span>)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">data</span> (<span class="ot">-&gt;</span>) t1 t2   <span class="co">-- Defined in ‘GHC.Prim’</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">infixr</span> <span class="dv">0</span> <span class="ot">`(-&gt;)`</span></a></code></pre></div>
<p>There isn’t any definition for the function type though because it’s a primitive (hence the <code>GHC.Prim</code>).</p>
<h3 id="exercises-type-matching">Exercises: Type Matching</h3>
<ol type="1">
<li><ol type="a">
<li><code>not :: Bool -&gt; Bool</code></li>
<li><code>length :: [a] -&gt; Int</code></li>
<li><code>concat :: [[a]] -&gt; [a]</code></li>
<li><code>head :: [a] -&gt; a</code></li>
<li><code>(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Bool</code></li>
</ol></li>
</ol>
<h2 id="currying">5.4 Currying</h2>
<p>All these types for <code>f</code> are equivalent:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Fun</span> <span class="fu">=</span> (<span class="ot">-&gt;</span>)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">f ::</span> (<span class="ot">-&gt;</span>) a ((<span class="ot">-&gt;</span>) a a)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">f ::</span> <span class="dt">Fun</span> a (<span class="dt">Fun</span> a a)</a></code></pre></div>
<p>Functions in Haskell return one and only one thing. Partial application is kind of a silly term. What’s partial about applying a <code>Fun a (Fun a a)</code> to an <code>a</code>? You give it an <code>a</code>, it gives you a function. Nothing partial about that. Maybe we wanted a function.</p>
<p>It’s only partial if you think of functions of somehow not being final values. Which is how they are in imperative-land. But we’re not in imperative-land anymore. Here functions are first-class, so they actually are values like anything else.</p>
<p>In fact, if you remember any of Chapter 1, there’s a good argument to be made that functions are more real than any other value. Lambda calculus builds the whole universe out of functions. Sure literals exist, but they’re a convenience (a huge convenience) not a strict necessity.</p>
<p>The <code>curry</code> and <code>uncurry</code> functions in the text are useful to understand conceptually.</p>
<p>Sectioning is basically bad practice. It’s a great way to confuse yourself and others. Do yourself a favor and throw an abstraction on top of it:</p>
<p>Not</p>
<pre><code>y = (2^)
z = (^2)</code></pre>
<p>But rather,</p>
<pre><code>y = \x -&gt; 2^x
z = \x -&gt; x^2</code></pre>
<p>You see how much nicer that is? Don’t abuse infix operators please. They’re there to make text more legible, not more terse and inscrutable. There are definitely cases where a clever sectioning of an infix operator can make things clearer. These cases are exceptions.</p>
<h3 id="exercises-type-arguments">Exercises: Type Arguments</h3>
<ol type="1">
<li>a</li>
<li>d</li>
<li>d</li>
<li>c</li>
<li>a</li>
<li>e</li>
<li>e</li>
<li>e</li>
<li>c</li>
</ol>
<h2 id="polymorphism">5.5 Polymorphism</h2>
<p>Greek words abound in Haskell jargon. If we lived in an age that believed in proper education you would already know them. We do not live in such an age.</p>
<p>Important words:</p>
<pre><code>hyle: matter
morphe: form

polys: - many
monos: - one

autos: self
endon: in
ectos: out
isos: equal

ana: up
kata: down
epi:  upon
meta: beyond, with
para: beside
meter: measure</code></pre>
<p>So when you read “parametric polymorphism”, fear not, you are really reading “beside-measure many-form-thing.” The latter doesn’t sound nearly as clever at cocktail parties, but that’s actually what the words mean, and knowing the meanings of the words you use helps you remember the concepts they describe.</p>
<p>A parameter is quite literally a “side measure.” When we measure a thing by looking at it next to something else, we’re using a parameter. Ever ask whether something was bigger than a breadbox? That’s measuring size in terms of breadboxes. It’s a side measures. It’s a parameter.</p>
<h2 id="exercises-parametricity">Exercises: Parametricity</h2>
<ol type="1">
<li>This is impossible because id has to work for a type that only one member. If a type only has one member, then the only thing a function with signature a -&gt; a can do if passed a value of that type is return the same value (or bottom, which is in every type) without breaking the type signature.</li>
<li><code>f x y = x</code> or <code>f x y = y</code></li>
<li><code>a -&gt; b -&gt; b</code> is the same as <code>a -&gt; (b -&gt; b)</code> and the only thing with type <code>(b -&gt; b)</code> is the id function. So this function is a kind of constant function that takes two arguments and returns the second, as opposed to <code>const :: a -&gt; b -&gt; a</code> which takes two arguments and returns the first. One implementation would be <code>const id</code>, but I am unsure whether <code>flip const</code> counts as a separate implementation.</li>
</ol>
<h2 id="type-inference">5.6 Type Inference</h2>
<p>Type inference is a cool tool for helping us build better programs. But it works best when you give it annotations to infer from. A lot of Haskell programming involves defining the types of the top-level expressions in your program before you actually start constructing anything, so this isn’t exactly any extra work.</p>
<p>And if you want to see real type system magic at work: <a href="https://aphyr.com/posts/342-typing-the-technical-interview">Typing the technical interview</a></p>
<h3 id="exercises-apply-yourself">Exercises: Apply Yourself</h3>
<ol type="1">
<li><code>[Char] -&gt; [Char]</code></li>
<li><code>Fractional a =&gt; a -&gt; a</code></li>
<li><code>Int -&gt; [Char]</code></li>
<li><code>Int -&gt; Bool</code></li>
<li><code>Char -&gt; Bool</code></li>
</ol>
<h2 id="chapter-exercises">5.8 Chapter Exercises</h2>
<h3 id="multiple-choice">Multiple Choice</h3>
<ol type="1">
<li>c</li>
<li>a</li>
<li>b</li>
<li>c</li>
</ol>
<h3 id="determine-the-type">Determine the type:</h3>
<ol type="1">
<li><ol type="a">
<li><code>Num a =&gt; a</code></li>
<li><code>Num a =&gt; (a, [Char])</code></li>
<li><code>(Integer, [Char])</code></li>
<li><code>Bool</code></li>
<li><code>Int</code></li>
<li><code>Bool</code></li>
</ol></li>
<li><code>Num a =&gt; a</code></li>
<li><code>Num a =&gt; a -&gt; a</code></li>
<li><code>Fractional a =&gt; a</code></li>
<li><code>[Char]</code></li>
</ol>
<h3 id="does-it-compile">Does it compile?:</h3>
<ol type="1">
<li><code>bignum $ 10</code> doesn’t make sense <code>5^10</code> is a number not a function</li>
<li>This should work.</li>
<li>c and d need a function.</li>
<li>c not in scope.</li>
</ol>
<h3 id="type-variable-or-specific-type-constructor">Type variable or specific type constructor?</h3>
<ol type="1">
<li></li>
</ol>
<ul>
<li>0: constrained polymorphic type var</li>
<li>1: fully polymorphic type var</li>
<li>2: concrete</li>
<li>3: concrete</li>
</ul>
<ol start="2" type="1">
<li></li>
</ol>
<ul>
<li>0: fully polymorphic</li>
<li>1: concrete</li>
<li>2: concrete</li>
</ul>
<ol start="3" type="1">
<li></li>
</ol>
<ul>
<li>0: fully polymorphic</li>
<li>1: constrained polymorphic</li>
<li>2: concrete</li>
</ul>
<ol start="4" type="1">
<li></li>
</ol>
<ul>
<li>0: fully polymorphic</li>
<li>1: fully polymorphic</li>
<li>2: concrete</li>
</ul>
<h3 id="write-a-type-signature">Write a type signature:</h3>
<ol type="1">
<li><code>[a] -&gt; a</code></li>
<li><code>(Ord a, Ord b) =&gt; a -&gt; b -&gt; Bool</code></li>
<li><code>(a, b) -&gt; b</code></li>
</ol>
<h3 id="given-a-type-write-the-function">Given a type, write the function:</h3>
<ol type="1">
<li><code>i = id</code></li>
<li><code>c x y = x</code></li>
<li><code>yes</code></li>
<li><code>c' x y = y</code></li>
<li><code>r = tail</code></li>
<li><code>co x y z = x $ y z</code></li>
<li><code>a x y = fst(y, x y)</code></li>
<li><code>a' x y = x y</code></li>
</ol>
<h3 id="fix-it">Fix it</h3>
<ol type="1">
<li><div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Sing</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">fstString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">fstString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; in the rain&quot;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="ot">sndString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">sndString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; over the rainbow&quot;</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">sing <span class="fu">=</span> <span class="kw">if</span> (x <span class="fu">&gt;</span> y) <span class="kw">then</span> fstString x <span class="kw">else</span> sndString y <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">       x <span class="fu">=</span> <span class="st">&quot;Singin&quot;</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">       y <span class="fu">=</span> <span class="st">&quot;Somewhere&quot;</span></a></code></pre></div></li>
<li><div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Sing</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">fstString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">fstString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; in the rain&quot;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="ot">sndString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">sndString x <span class="fu">=</span> x <span class="fu">++</span> <span class="st">&quot; over the rainbow&quot;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">sing <span class="fu">=</span> <span class="kw">if</span> (x <span class="fu">&lt;</span> y) <span class="kw">then</span> fstString x <span class="kw">else</span> sndString y <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">       x <span class="fu">=</span> <span class="st">&quot;Singin&quot;</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">       y <span class="fu">=</span> <span class="st">&quot;Somewhere&quot;</span></a></code></pre></div></li>
<li><div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Arith3Broken</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  print <span class="fu">$</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  print <span class="dv">10</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  print <span class="fu">$</span> negate (<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  print <span class="fu">$</span> <span class="dv">0</span> <span class="fu">+</span> blah</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">where</span> blah <span class="fu">=</span> negate <span class="dv">1</span></a></code></pre></div></li>
</ol>
<h3 id="type-kwon-do">Type-Kwon-Do</h3>
<ol type="1">
<li><code>h x = g $ f x</code></li>
<li><code>e x = w $ q x</code></li>
<li><code>xform (x, y) = (xz x, yz y)</code></li>
<li><code>munge f g x = fst $ g $ f x</code></li>
</ol>
<h2 id="follow-up-resources">5.10 Follow-up resources</h2>
<ol type="1">
<li><p><a href="https://github.com/johnchandlerburnham/hpffp-resources/blob/master/Chapter-05/Principal%20type-schemes%20for%20functional%20programs.pdf">Luis Damas; Robin Milner. Principal type-schemes for functional programs</a></p></li>
<li><p><a href="https://github.com/johnchandlerburnham/hpffp-resources/blob/master/Chapter-05/Fundamental%20Concepts%20in%20Programming%20Languages.pdf">Christopher Strachey. Fundamental Concepts in Programming Languages</a> Popular origin of the parametric/ad-hoc polymorphism distinction.</p></li>
</ol>
<hr />

        </div>
        <div id="footer">
          <p>&copy; <script>document.write(new Date().getFullYear());</script>
             John Chandler Burnham.
            Generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </p>
        </div>
    </body>
</html>
